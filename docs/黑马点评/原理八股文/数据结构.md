---
title: 数据结构
date: 2026-1-28
---
## 数据结构

### 动态字符串sds

Redis 的 **SDS（Simple Dynamic String，简单动态字符串）** 是 Redis 自己实现的字符串数据结构，**完全替代了 C 语言原生的 `char\*` 字符串**，用于高效、安全地处理字符串操作。它不仅是 Redis 中所有字符串值的底层存储结构，也广泛用于 **Key、Value、命令参数等几乎所有字符串场景**。

结构：

```c
struct sdshdr {
    int len;        // 已使用字节数（不包括 \0）
    int alloc;      // 总分配字节数（不包括 \0）
    char flags;     // 类型标志（不同长度用不同结构体，Redis 5+ 优化）
    char buf[];     // 实际字符数组（柔性数组），末尾自动加 \0
};
```

> 📌 注意：Redis 5.0 后对 SDS 做了内存优化，按字符串长度分 5 种类型（sdshdr5/8/16/32/64），但核心思想不变。

在 Redis 中，**所有的 Key 和 Value（当类型为 string 时）都是用 SDS 存储的**。

 **🔑 1.** ***\*Key 是 SDS\****

- 当你执行 `SET user:1001 "Alice"`：

  - `"user:1001"` 这个 key → 用 SDS 存储
- 便于快速比较、哈希计算、内存管理

 **💾 2.** ***\*String 类型的 Value 是 SDS\****

- `"Alice"` 这个 value → 也是 SDS
- 支持高效追加（`APPEND`）、截取（`GETRANGE`）、长度获取（`STRLEN`）

 **🧱 3.** ***\*其他类型内部也大量使用 SDS\****

- Hash 的 field 和 value
- List 的每个元素
- Set 的每个成员
- Sorted Set 的 member
- Stream 的 field/value
- Lua 脚本中的字符串
- 客户端输入的命令、参数

> ✅ **可以说：Redis 中几乎所有的“字符串”都是 SDS！**

相比较于c的原生字符数组的优化：

 **1.** ***\*空间预分配（Preallocate）\****

- 当 SDS 需要扩容时：
  - 若新长度 < 1MB → 分配 **2 × 新长度**
  - 若 ≥ 1MB → 分配 **新长度 + 1MB**
- 目的：减少连续 append 导致的频繁 realloc

 **2.** ***\*惰性空间释放（Lazy Free）\****

- 当字符串缩短（如 `SETRANGE`），**不立即释放内存**
- `alloc` 不变，`len` 减小
- 后续增长可复用空闲空间
- 也可通过 `SDS_NOINIT` 或显式调用 `sdsRemoveFreeSpace()` 强制释放

> 💡 这些策略让 Redis 在高频写入场景下依然保持高性能。



### intSet

`intset`（整数集合）是 Redis 内部用于高效存储**整数类型元素的有序集合（Set）** 的一种底层数据结构。当一个 Set 中**所有元素都是整数**，且**元素数量较少**时，Redis 会自动使用 `intset` 而不是更通用的 `hashtable`（哈希表），以节省内存并提升性能。

大致结构：

```c
typedef struct intset {
    uint32_t encoding;  // 编码方式：INTSET_ENC_INT16 / INT32 / INT64
    uint32_t length;    // 元素个数
    int8_t contents[];  // 柔性数组，存储实际整数（按 encoding 解释）
} intset;
```

| 字段       | 说明                                                         |
| :--------- | :----------------------------------------------------------- |
| `encoding` | 当前使用的整数类型： • `INTSET_ENC_INT16` → 16 位有符号整数（-32768 ～ 32767） • `INTSET_ENC_INT32` → 32 位（-2³¹ ～ 2³¹-1） • `INTSET_ENC_INT64` → 64 位（-2⁶³ ～ 2⁶³-1） |
| `length`   | 集合中元素的数量                                             |
| `contents` | 紧凑存储的整数数组，**按升序排列**，无重复                   |

> 💡 所有整数在 `contents` 中占用相同字节数（由 `encoding` 决定）。

- **节省内存**：相比 hashtable，intset 是紧凑的数组结构
- **保持有序**：元素天然升序排列，支持快速查找
- **自动升级**：根据存入的整数大小，动态选择最合适的整数类型（int16 / int32 / int64）
- **仅用于 Set 类型**：是 Redis Set 对象的一种编码方式（`encoding = INTSET`）



### dict

在 Redis 中，**`dict`（字典）** 是其最核心的底层数据结构之一，**几乎支撑了 Redis 所有键值对存储和哈希类型的操作**。它是 Redis 自己实现的高效哈希表（Hash Table），用于：

- 存储整个数据库的 **key-value 映射**（即你 `SET name Alice` 中的全局 K-V）
- 实现 **Hash 类型**（如 `HSET user:1001 name Alice age 25`）
- 用作 **Set、ZSet 的底层结构之一**（当元素较多或含非整数时）
- 模块系统、过期 key 管理、客户端连接管理等内部模块

Redis 的 `dict` 由两个主要结构体组成：

 **1.** **`dictEntry` \**—— 哈希桶中的节点\****

```c
typedef struct dictEntry {
    void *key;                // 键
    union {                   // 值（支持多种类型）
        void *val;
        uint64_t u64;
        int64_t s64;
        double d;
    } v;
    struct dictEntry *next;   // 链表指针（解决哈希冲突）
} dictEntry;
```

 **2.** **`dictht` \**—— 哈希表本身\****

```c
typedef struct dictht {
    dictEntry **table;     // 哈希桶数组（每个元素是一个链表头）
    unsigned long size;    // 哈希表大小（桶的数量，总是 2^n）
    unsigned long sizemask; // size - 1，用于快速取模：hash & sizemask
    unsigned long used;    // 已存元素数量
} dictht;
```

 **3.** **`dict` \**—— 字典对象（包含两个哈希表，用于 rehash）\****

```c
typedef struct dict {
    dictType *type;        // 类型函数指针（如 key 的 hash/compare/dup/free）
    void *privdata;        // 私有数据（传给 type 函数）
    dictht ht[2];          // 两个哈希表：ht[0] 正常使用，ht[1] 用于 rehash
    long rehashidx;        // rehash 状态：-1=未进行，≥0=正在 rehash 到 ht[1]
    int16_t pauserehash;   // 是否暂停 rehash（Redis 6+）
} dict;
```

> 🔑 **关键设计：`ht[2]` + `rehashidx` → 支持渐进式 rehash！**

使用场景

| 场景                 | 说明                                                         |
| :------------------- | :----------------------------------------------------------- |
| **Redis 数据库本身** | 每个 DB（0～15）都是一个 `dict`，key 是 SDS，value 是 `redisObject` |
| **Hash 类型**        | 当 Hash 元素较多或 value 较大时，底层编码从 `ziplist` 升级为 `hashtable`（即 `dict`） |
| **Set 类型**         | 当 Set 含非整数 或 元素 > 512 时，从 `intset` 升级为 `hashtable` |
| **ZSet（有序集合）** | ZSet 是 `dict` + `skiplist` 的组合： • `dict` 用于 O(1) 查找 score • `skiplist` 用于范围查询 |
| **过期 key 管理**    | `expires` 字典：key → 过期时间戳                             |
| **客户端连接管理**   | `clients` 字典：fd → client 对象                             |

> 💡 **可以说：没有 `dict`，就没有 Redis 的 KV 模型！**

> **Redis 在查找 key 时，底层使用的是基于哈希表（Hash Table）的 `dict` 结构**，这是 Redis 实现 **O(1) 平均时间复杂度** 查找的关键。

基本就是和之前学的hashmap一样的hash数组，**冲突**使用**拉链表**的方式，到链表里面再次遍历来解决。

而就像hashmap，这样的表需要扩容以减少链表过长导致查找长度过长的问题，那么在每次插入新数据时就会检查负载因子是否超标，超过阈值时就会进行哈希表扩容；当删除元素时，同样也会检查是否减少到某一阈值，触发则会收缩哈希表。

不管是扩容还是收缩，都会对键值对的所有元素进行重新hash并迁移到新的哈希表中。 在这过程中，redis内部可能已经存在了大量的key，这时候全部都一口气hash完可能会导致主线程被阻塞过长时间，这时候我们就需要**渐进式rehash**

**渐进式 Rehash（Incremental Rehashing）** 是 Redis 为解决 **哈希表（dict）扩容/缩容时阻塞主线程** 而设计的核心优化机制。它将原本**一次性完成的大量数据迁移工作**，**分摊到多次请求处理中逐步完成**，从而避免服务卡顿，保证 Redis 的高响应性。

- 不再一次性迁移所有数据
- 每次处理客户端命令时，**顺带迁移一小部分数据**
- 同时支持 **定时任务主动推进**（防止长时间无请求）
- 整个过程对用户透明，服务不中断

**实现步骤：**

 **1.** ***\*双哈希表结构（\**`ht[0]` \**和\** `ht[1]`\**）\****

```c
typedef struct dict {
    dictht ht[2];      // ht[0] = 当前表, ht[1] = 新表（rehash 时使用）
    long rehashidx;    // -1=未 rehash, ≥0=当前迁移的桶索引
} dict;
```

 **2.** ***\*Rehash 触发条件\****

| 操作     | 条件                                                 |
| :------- | :--------------------------------------------------- |
| **扩容** | `used / size ≥ 1`（普通 dict）或 ≥5（Hash 类型）     |
| **缩容** | `used / size < 0.1` 且 `size > DICT_HT_INITIAL_SIZE` |

 **3.** ***\*Rehash 执行流程\****

 **步骤 1：初始化**

- 分配 `ht[1]` 内存（扩容：2×size；缩容：0.5×size）
- 设置 `rehashidx = 0`

 **步骤 2：渐进迁移（关键！）**

每次执行以下任一操作时，**自动触发一次小批量迁移**：

- 客户端命令（GET/SET/HGET 等）
- 定时任务（`serverCron`，每 100ms 检查）

**迁移逻辑：**

```c
// 伪代码
if (dictIsRehashing(dict)) {
    // 迁移 1 个桶（或多个，由配置决定）
    _dictRehashStep(dict); 
    rehashidx++;
}
```

 **步骤 3：读写操作如何处理？**

| 操作            | 行为                               |
| :-------------- | :--------------------------------- |
| **查找（GET）** | 先查 `ht[0]`，再查 `ht[1]`         |
| **删除（DEL）** | 在两个表中都尝试删除               |
| **新增（SET）** | **只写入 `ht[1]`**（避免重复迁移） |

 **步骤 4：完成 Rehash**

- 当 `rehashidx == ht[0].size`（所有桶迁移完毕）
- 释放 `ht[0]` 内存
- 将 `ht[1]` 赋值给 `ht[0]`
- `rehashidx = -1`



### ZipList

`ziplist`（压缩列表）是 Redis 内部实现的一种**紧凑、连续内存存储的双向链表结构**，专为**节省内存**而设计。它被用作 **Hash、List、ZSet 等数据类型的底层编码之一**，当这些结构中的元素**数量较少且每个元素较小时**，Redis 会自动使用 `ziplist` 而非更通用的 `hashtable` 或 `linkedlist`。

| 特性                 | 说明                                                  |
| :------------------- | :---------------------------------------------------- |
| **连续内存布局**     | 所有数据存放在一块连续内存中，无指针                  |
| **变长编码**         | 整数/字符串按实际大小存储，支持多种长度编码           |
| **双向遍历**         | 可从前向后或从后向前遍历（通过记录前一个 entry 长度） |
| **内存紧凑**         | 无内存碎片，适合存储大量小对象                        |
| **仅适用于小数据集** | 元素多或值大时会退化为其他结构                        |

**内存中ziplist的结构**：

```c
// ziplist 整体内存布局（字节序列）
<zlbytes><zltail><zllen><entry1><entry2>...<entryN><zlend>
```

| 字段              | 长度   | 说明                                      |
| :---------------- | :----- | :---------------------------------------- |
| `zlbytes`         | 4 字节 | 整个 ziplist 占用的总字节数               |
| `zltail`          | 4 字节 | 最后一个 entry 的偏移量（用于快速 `POP`） |
| `zllen`           | 2 字节 | entry 数量（≤65535，否则需遍历）          |
| `entry1...entryN` | 变长   | 实际数据项（每个 entry 结构见下文）       |
| `zlend`           | 1 字节 | 结束标记（值为 `0xFF`）                   |

  

**每个** `entry` **的结构**:

```
<prevlen><encoding><data>
```

| 部分           | 说明                                                         |
| :------------- | :----------------------------------------------------------- |
| **`prevlen`**  | 前一个 entry 的长度（用于反向遍历） • 若前一个 entry 长度 < 254 → **用 1 字节存储** • 否则 → 用 5 字节（1 字节标记 + 4 字节长度） |
| **`encoding`** | 当前 entry 的数据类型和长度编码（1～5 字节） • 可表示整数（int16/int32/int64） • 或字符串（长度 0～65535） |
| **`data`**     | 实际数据内容（按 encoding 解释）                             |

Redis 会在以下情况使用 `ziplist` 作为底层编码：

 **1.** ***\*List 类型\****

- 条件：
  - 元素数量 ≤ `list-max-ziplist-entries`（默认 **512**）
  - 每个元素大小 ≤ `list-max-ziplist-value`（默认 **64 字节**）
- 命令：`LPUSH`, `RPUSH`, `LPOP`, `RPOP`, `LRANGE` 等

 **2.** ***\*Hash 类型\****

- 条件：
  - field-value 对数量 ≤ `hash-max-ziplist-entries`（默认 **512**）
  - 每个 field 或 value 大小 ≤ `hash-max-ziplist-value`（默认 **64 字节**）（过长变成`hashtable`）
- 命令：`HSET`, `HGET`, `HGETALL` 等

 **3.** ***\*ZSet（有序集合）\****（Redis 7.0 之前）

- 条件：
  - 元素数量 ≤ `zset-max-ziplist-entries`
  - 每个 member/score 大小 ≤ `zset-max-ziplist-value`
- ⚠️ 注意：**Redis 7.0+ 已移除 ziplist 对 ZSet 的支持**，改用 `listpack`

> 📌 配置示例（redis.conf）：
>
> ```bash
> hash-max-ziplist-entries 512
> hash-max-ziplist-value 64
> list-max-ziplist-entries 512
> list-max-ziplist-value 64
> ```



### QuickList

`QuickList` 是 Redis 从 **3.2 版本开始**引入的、用于替代早期 `ziplist + linkedlist` 组合的 **List 类型底层数据结构**。它的核心思想是：**将多个 `ziplist`（或 `listpack`，Redis 7.0+）作为节点，用双向链表（linked list）连接起来**，从而在**内存效率**和**操作性能**之间取得最佳平衡。

| 版本  | 底层结构                              | 问题                                                         |
| :---- | :------------------------------------ | :----------------------------------------------------------- |
| < 3.2 | `ziplist` 或 `adlist`（普通双向链表） | • `ziplist`：修改开销大（连锁更新） • `adlist`：内存浪费（每个节点有 prev/next 指针 + 内存对齐） |
| ≥ 3.2 | **`QuickList`**                       | ✅ 结合两者优点： • 内存紧凑（每个节点是 ziplist） • 修改局部化（只影响一个 ziplist） |

> 💡 **目标：既要省内存，又要避免大 ziplist 的性能陷阱。**

整体结构：

```
QuickList
│
├── head → [ziplist1] ↔ [ziplist2] ↔ [ziplist3] ← tail
│          (节点1)     (节点2)     (节点3)
│
└── count: 总元素数量
    len:   ziplist 节点数量
    fill:  每个 ziplist 的最大容量（由配置决定）
```

节点的结构：

```c
typedef struct quicklistNode {
    struct quicklistNode *prev;
    struct quicklistNode *next;
    unsigned char *zl;            // 指向 ziplist（或 listpack）的指针
    size_t sz;                    // ziplist 占用字节数
    unsigned int count : 16;      // 该 ziplist 中的元素个数
    unsigned int encoding : 2;    // RAW=1（未压缩）, LZF=2（LZF 压缩）
    // ... 其他标志位
} quicklistNode;
```

> ⚠️ 注意：**每个节点内部是一个完整的 ziplist（Redis 7.0+ 是 listpack）**。



### SkipList

`SkipList`（跳表）是 Redis 中 **有序集合（Sorted Set，ZSet）** 的核心底层数据结构之一（另一个是 `dict`）。它是一种**概率性、多层链表结构**，能在 **O(log N) 平均时间复杂度** 下完成插入、删除、查找和范围查询，同时实现简单、易于并发扩展。

| 数据结构            | 优点                                                         | 缺点                         | Redis 选择原因     |
| :------------------ | :----------------------------------------------------------- | :--------------------------- | :----------------- |
| **红黑树 / AVL 树** | 严格 O(log N)                                                | 实现复杂，旋转操作难并发     | ❌ 复杂度高         |
| **B/B+ 树**         | 磁盘友好                                                     | 内存中无优势                 | ❌ 不适合内存数据库 |
| **SkipList**        | ✅ 实现简单 ✅ 天然支持范围查询 ✅ 易于并发（加锁粒度小） ✅ 内存局部性较好 | 概率性 O(log N) 额外指针开销 | ✅                  |

> **“给链表加索引” —— 类似书籍目录**

- 底层（Level 0）：包含所有元素的**有序双向链表**
- 上层（Level 1～N）：**部分元素的“快速通道”**
- 每一层都是下一层的**子集**，越高层越稀疏
- 查找时从**最高层开始**，逐步向下“跳转”，大幅减少比较次数

 **节点结构（`zskiplistNode`）**

```c
typedef struct zskiplistNode {
    sds ele;                // 成员对象（字符串，如 "user:1001"）
    double score;           // 分值（用于排序）
    struct zskiplistNode *backward; // 后退指针（仅 Level 0 有效）
    struct zskiplistLevel {
        struct zskiplistNode *forward; // 前进指针
        unsigned long span;            // 到 forward 节点的跨度（用于 rank 计算）
    } level[];              // 柔性数组，每层一个 forward + span
} zskiplistNode;
```

 **跳表结构（`zskiplist`）**

```c
typedef struct zskiplist {
    struct zskiplistNode *header, *tail; // 头尾节点
    unsigned long length;                // 元素总数
    int level;                           // 当前最大层数
} zskiplist;
```

 **🔑 关键设计亮点：**

- **双向链表**：`backward` 指针支持反向遍历（如 `ZREVRANGE`）
- **span 字段**：记录到下一节点的**跨度**，使得 `ZRANK` 可在 O(log N) 内完成
- **头节点（header）**：不存实际数据，`level` 固定为 32 层（最大支持）



### RedisObject

`redisObject`（常缩写为 **robj**）是 Redis 中**最核心的对象封装结构**，**所有 Redis 数据类型（String、List、Hash、Set、ZSet）的值在内存中都以 `redisObject` 的形式存在**。它不仅统一了不同类型数据的表示方式，还支持**内存优化、引用计数、LRU 淘汰、类型检查**等关键功能。

```c
typedef struct redisObject {
    unsigned type:4;        // 对象类型（5种基本类型）
    unsigned encoding:4;    // 编码方式（底层数据结构）
    unsigned lru:24;        // LRU 时间戳 或 LFU 计数（用于淘汰）
    int refcount;           // 引用计数（内存回收）
    void *ptr;              // 指向实际数据的指针
} robj;
```

 **`type` —— 对象类型（用户可见）**

| 值   | 宏定义       | 说明     |
| :--- | :----------- | :------- |
| 0    | `OBJ_STRING` | 字符串   |
| 1    | `OBJ_LIST`   | 列表     |
| 2    | `OBJ_SET`    | 集合     |
| 3    | `OBJ_ZSET`   | 有序集合 |
| 4    | `OBJ_HASH`   | 哈希     |

> ✅ 通过 `TYPE key` 命令返回的就是这个值。

**`encoding`—— 编码方式（底层实现）**

| 类型       | 可能的 encoding          | 底层结构                           |
| :--------- | :----------------------- | :--------------------------------- |
| **String** | `OBJ_ENCODING_INT`       | long 整数（直接存数值）            |
|            | `OBJ_ENCODING_EMBSTR`    | embstr 编码 SDS（≤44字节）         |
|            | `OBJ_ENCODING_RAW`       | raw 编码 SDS（>44字节）            |
| **List**   | `OBJ_ENCODING_QUICKLIST` | QuickList（Redis 3.2+）            |
| **Hash**   | `OBJ_ENCODING_ZIPLIST`   | ziplist（小 Hash）                 |
|            | `OBJ_ENCODING_HASHTABLE` | dict（大 Hash）                    |
| **Set**    | `OBJ_ENCODING_INTSET`    | intset（整数集合）                 |
|            | `OBJ_ENCODING_HT`        | dict（含字符串或大集合）           |
| **ZSet**   | `OBJ_ENCODING_ZIPLIST`   | ziplist（小 ZSet，Redis 6 及以前） |
|            | `OBJ_ENCODING_SKIPLIST`  | skiplist + dict（大 ZSet）         |

> 📌 **可通过 `OBJECT ENCODING key` 查看当前编码**。







## 五种基本数据类型的编码方式

### String

| 编码（`encoding`） | 存储形式               | 适用条件                                                     | 内存/性能特点                                                |
| :----------------- | :--------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| **`INT`**          | 直接存储 `long` 整数值 | 字符串内容是 **可表示为 long 的整数** （如 `"123"`, `"-456"`） | ⭐⭐⭐ • 零额外内存（值直接存指针中） • 计算极快（如 `INCR` 直接 +1） |
| **`EMBSTR`**       | **embstr 编码的 SDS**  | 字符串长度 **≤ 44 字节**（Redis 3.2+）                       | ⭐⭐ • 一次内存分配 • robj + SDS 连续存储 • 只读（修改会转为 RAW） |
| **`RAW`**          | **raw 编码的 SDS**     | 字符串长度 **> 44 字节**                                     | ⭐ • robj 和 SDS 分两次分配 • 可变（支持 APPEND 等修改）      |

> 🔑 所有 String 对象的 `type = OBJ_STRING`，但 `encoding` 不同。



### List

Redis 的 **List（列表）** 是一个**有序、可重复、支持双向操作**的字符串集合，底层基于 **QuickList**（Redis 3.2+）实现。它广泛用于消息队列、最新动态、任务调度等场景。

| 特性         | 说明                                       |
| :----------- | :----------------------------------------- |
| **有序**     | 元素按插入顺序排列，支持索引访问（0 起始） |
| **可重复**   | 允许相同元素多次出现                       |
| **双向操作** | 支持头尾高效插入/删除（O(1)）              |
| **阻塞操作** | `BLPOP`/`BRPOP` 可实现阻塞队列             |
| **最大长度** | 理论上 2³² - 1 个元素（约 42 亿）          |

```bash
# 每个 listpack 最大容量（默认 -2 = ≤8KB）
list-max-listpack-size -2

# 压缩深度（0=不压缩，1=除头尾外都压缩）
list-compress-depth 0
```



### Set

Redis 的 **Set（集合）** 是一个**无序、唯一、支持高效交并差运算**的字符串集合。它底层根据数据特征自动在 **`intset`（整数集合）** 和 **`hashtable`（哈希表）** 之间切换，兼顾内存效率与操作性能。

| 特性         | 说明                                                    |
| :----------- | :------------------------------------------------------ |
| **无序**     | 元素没有顺序（不保证插入顺序）                          |
| **唯一性**   | 自动去重，相同元素只存一份                              |
| **成员类型** | 所有元素都是字符串（但可表示整数）                      |
| **高效操作** | 添加/删除/查找平均 **O(1)**                             |
| **集合运算** | 支持交集（`SINTER`）、并集（`SUNION`）、差集（`SDIFF`） |

Redis Set 会根据 **元素类型** 和 **数量** 自动选择最优编码：

| 编码            | 底层结构             | 触发条件                                                     |
| :-------------- | :------------------- | :----------------------------------------------------------- |
| **`intset`**    | 紧凑整数数组         | • 所有元素都是**整数** • 元素数量 ≤ `set-max-intset-entries`（默认 **512**） |
| **`hashtable`** | Redis dict（哈希表） | • 含**非整数元素** • 或元素数量 **> 512**                    |

> 📌 配置项（redis.conf）：
>
> ```bash
> set-max-intset-entries 512
> ```



### ZSet

Redis 的 **ZSet（Sorted Set，有序集合）** 是 Redis 最强大的数据结构之一，它结合了 **Set 的唯一性** 和 **Score 的排序能力**，支持 **按分值范围高效查询、排名计算、Top N 排行榜** 等操作。其底层由 **`dict` + `skiplist`** 共同实现，兼顾单点查找与范围扫描。

| 特性           | 说明                                                         |
| :------------- | :----------------------------------------------------------- |
| **唯一性**     | member（成员）不可重复                                       |
| **有序性**     | 按 **score（分值）** 升序排列（score 可相同，此时按 member 字典序） |
| **双索引**     | • 通过 member → O(1) 查 score • 通过 score 范围 → O(log N + M) 查 members |
| **支持浮点数** | score 是 double 类型（64 位浮点）                            |
| **典型应用**   | 排行榜、延迟队列、带权重的任务调度                           |

Redis 的 ZSet **不是单一结构**，而是两个数据结构的组合：


| 结构           | 作用                                            | 时间复杂度                       |
| :------------- | :---------------------------------------------- | :------------------------------- |
| **`dict`**     | • Key = member（SDS） • Value = score（double） | `ZSCORE`, `ZREVRANK` → **O(1)**  |
| **`skiplist`** | • 按 score 排序的双向链表 • 每层带 span（跨度） | `ZRANGE`, `ZRANK` → **O(log N)** |

> 💡 **两者共享 member 和 score 数据**，通过指针关联，内存不重复。

 **🔍 为什么不用平衡树？**

- SkipList 实现更简单、易于调试
- 天然支持范围查询（链表顺序遍历）
- span 字段可高效计算 rank



### Hash

Redis 的 **Hash（哈希）** 是一个**键值对集合**，特别适合存储**对象的多个字段**（如用户资料、商品属性）。它在内存中根据数据规模自动在 **`ziplist`（或 `listpack`）** 和 **`hashtable`（dict）** 之间切换，兼顾小对象的内存效率与大对象的操作性能。

| 特性         | 说明                                                         |
| :----------- | :----------------------------------------------------------- |
| **结构**     | field-value 映射（field 和 value 都是字符串）                |
| **无序**     | 不保证 field 的顺序（Redis 4.0+ 按插入顺序遍历，但不承诺有序） |
| **高效访问** | 单个 field 的增删改查为 **O(1)**                             |
| **内存优化** | 小 Hash 使用紧凑编码（ziplist/listpack）                     |
| **典型用途** | 存储对象（如 user:{id} 包含 name/age/email）                 |

Redis Hash 会根据 **field-value 数量** 和 **值大小** 自动选择编码：

| 编码                                                     | 底层结构             | 触发条件（默认）                                             |
| :------------------------------------------------------- | :------------------- | :----------------------------------------------------------- |
| **`ziplist`**（Redis 7.0） **`listpack`**（Redis ≥ 7.0） | 紧凑连续内存         | • field-value 对数 ≤ **512** • 每个 field 或 value 长度 ≤ **64 字节** |
| **`hashtable`**                                          | Redis dict（哈希表） | • 超出上述任一限制                                           |

> 📌 配置项（redis.conf）：
>
> ```
> hash-max-listpack-entries 512    # 原名 hash-max-ziplist-entries
> hash-max-listpack-value 64       # 原名 hash-max-ziplist-value
> ```

> 💡 **注意**：Redis 7.0+ 底层已用 `listpack` 替代 `ziplist`（消除连锁更新），但配置名仍保留 `*ziplist*` 兼容旧版。
