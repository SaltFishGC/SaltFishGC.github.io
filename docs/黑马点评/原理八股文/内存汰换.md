---
title: 内存回收
date: 2026-1-28
---

## 过期key策略

### 确定过期时间

Redis 为每个数据库维护两个字典：

```c
typedef struct redisDb {
    dict *dict;      // 主键空间：key → value
    dict *expires;   // 过期字典：key → expire_time (Unix timestamp)
} redisDb;
```

- `SET key value EX 10` → 同时写入 `dict` 和 `expires`
- `TTL key` → 查询 `expires` 字典
- 删除时，同时从两个字典中移除

> 💡 **只有 `expires` 中的 key 才会被定期删除扫描！**



### 惰性删除

 **📌 原理：**

- **只在访问 key 时检查是否过期**
- 如果过期 → 立即删除，并返回空（如 `GET` 返回 `nil`）

 **📌 触发时机：**

```c
// Redis 源码：db.c
robj *lookupKeyRead(redisDb *db, robj *key) {
    if (expireIfNeeded(db, key)) return NULL; // 检查并删除过期 key
    return lookupKey(db, key);
}
```

- 所有读写命令（`GET`、`SET`、`HGET` 等）都会触发此检查

 **✅ 优点：**

- **零 CPU 开销**（不访问就不检查）
- **保证一致性**：永远不会返回过期数据

 **❌ 缺点：**

- **过期 key 可能长期驻留内存**（如果 never accessed）
- 极端情况下导致内存泄漏（如大量冷 key 设置了 TTL）



### **定期删除**

 **📌 原理：**

- Redis **每秒进行 10 次**（可配置）主动扫描
- 每次**随机抽查** **20 个**设置了过期时间的 key
- 删除其中已过期的 key
- **如果过期比例 > 25%**，则继续抽查下一批（避免漏删）

 **📌 配置参数：**

```bash
# redis.conf
hz 10          # 默认每秒 10 次（范围 1～500）
dynamic-hz yes # 高负载时自动提高频率（6.0+）
```

 **📌 扫描流程（简化）：**

```python
def activeExpireCycle():
    for db in all_dbs:
        sampled = 0
        expired = 0
        while sampled < 20:
            key = random_pick_from_expired_dict(db)
            if key.ttl <= now:
                delete(key)
                expired += 1
            sampled += 1
        
        if expired / sampled > 0.25:
            continue  # 继续抽查
        else:
            break     # 本轮结束
```

 **✅ 优点：**

- **主动清理**，防止过期 key 积压
- 即使 key never accessed，最终也会被删除

 **❌ 缺点：**

- **占用 CPU 时间**（但通过限制次数/比例控制开销）
- **不能保证实时性**（可能延迟数百毫秒到数秒）



## 内存淘汰策略

除了ttl超时过期删除键值对，当我们的内存压力过大时，Redis也会删除键值对以缓解压力：

Redis 的 **内存淘汰策略（Memory Eviction Policy）** 是其作为缓存系统的核心机制之一。当 Redis 内存使用达到上限（`maxmemory`）时，它会根据配置的策略自动删除部分数据，以腾出空间给新写入的数据。

### 触发条件

只有在以下两个条件**同时满足**时，才会触发内存淘汰：

1. 配置了 `maxmemory`（单位：bytes）

   ```bash
   maxmemory 2gb
   ```

2. **当前内存使用 ≥ `maxmemory`**

> ⚠️ 如果未设置 `maxmemory`，Redis 会持续使用内存直到系统 OOM（Out-Of-Memory）被 kill。



### 淘汰策略

| 策略名称            | 含义                                                         | 适用场景                       |
| :------------------ | :----------------------------------------------------------- | :----------------------------- |
| **noeviction**      | 默认策略。**不淘汰**，写命令返回错误（如 `OOM command not allowed`） | 不希望丢失数据（如持久化存储） |
| **volatile-lru**    | 从**设置了过期时间（TTL）的 key**中，用 LRU 算法淘汰         | 缓存 + 有明确过期时间          |
| **volatile-lfu**    | 从**设置了 TTL 的 key**中，用 LFU 算法淘汰（Redis 4.0+）     | 热点缓存，区分访问频率         |
| **volatile-random** | 从**设置了 TTL 的 key**中，随机淘汰                          | 简单场景，无访问模式           |
| **volatile-ttl**    | 从**设置了 TTL 的 key**中，优先淘汰**剩余时间最短**的        | 临时数据，越快过期越先删       |
| **allkeys-lru**     | 从**所有 key**中，用 LRU 淘汰                                | 通用缓存（最常用）             |
| **allkeys-lfu**     | 从**所有 key**中，用 LFU 淘汰（Redis 4.0+）                  | 高频访问热点数据               |
| **allkeys-random**  | 从**所有 key**中，随机淘汰                                   | 极简场景，性能最高             |

> 🔑 **关键区别**：
>
> - `volatile-*`：只淘汰**有 TTL 的 key**
> - `allkeys-*`：淘汰**任意 key**（包括永不过期的）



### 淘汰算法

**LRU——最久未被访问/最近最少使用**

 **原理：**

- 淘汰**最久未被访问**的 key

- Redis 使用

  近似 LRU

  （非精确）：

  - 每个 key 记录一个 24 位的“最近访问时间戳”（`lru` 字段）
  - 淘汰时随机采样 N 个 key（默认 5 个），选其中 `lru` 最小的淘汰

 **配置采样数（提高精度）：**

```bash
maxmemory-samples 10  # 默认 5，值越大越接近真实 LRU，但 CPU 开销增加
```

 **优点：**

- 符合“局部性原理”，适合大多数缓存场景



**LFU——一段时间使用频次最少/最不经常使用**

 **原理：**

- 淘汰**访问频率最低**的 key
- Redis 使用近似 LFU：
  - 每个 key 的 `lru` 字段改为存储 **访问频次 + 衰减时间**
  - 频次会随时间衰减（避免历史热点永远不被淘汰）

 **配置参数：**

```
lfu-log-factor 10    # 控制频次增长速度（越大越平滑）
lfu-decay-time 1     # 多少分钟衰减一次（默认 1 分钟）
```

 **适用场景：**

- 区分“偶尔访问” vs “持续高频访问”
- 例如：首页 banner（每天刷 1 次） vs 商品详情页（每秒刷 100 次）



 **Random——随机淘汰**

- 完全随机选择 key 删除
- **CPU 开销最小**，但可能误删热点数据
- 仅用于对一致性要求极低的场景
