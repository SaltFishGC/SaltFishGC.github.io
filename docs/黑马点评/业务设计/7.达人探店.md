---
title: 达人探店
date: 2025-1-19
---

## 发表探店笔记

**产品需求**：

- 上传照片，撰写文案
- 可以评论

**实现方案**：

- 用户前端准备好图片以及文章后点击提交时，对文件以及输入文章进行上传存储

- 数据库设置对应表记录文章
- MultipartFile获取文件，使用本地文件存储，将文件流存至本地
- 数据库记录评论，评论项记录文章id

> **其他方案**：
>
> 上传照片一般使用自制的文件服务器或者**OSS**，如果是使用OSS：
>
> 前端发送文件操作请求至后端，后端根据操作类型向OSS服务器请求一个token用于专门处理该操作（策略等方式严格指定token的使用对象，途径，范围以防止前端恶意获取token进行破坏），后端将这个特化token传回前端，前端使用OSS-Client向指定OSS服务器发送请求，带上此token以完成所需操作。



## 查看探店笔记

**产品需求**：

- 通过id查看笔记文章
- 额外展示用户信息（头像等）
- 提供用户关注接口

**实现方案**：

- 接口获取文章id，根据id获取文章对象（带上是否已经点赞等信息）
- 根据文章的作者id获取相关信息并提供给前端（使用`@TableField(exist = false)`直接给Blog不必额外封装）



## 点赞

**产品需求**：

- 提供点赞接口
- 限制单用户对同一笔记的点赞次数

**实现方案**：

- 点赞后数据库对应项点赞数+1，若已经点过赞再次点击取消点赞
- Redis的zset记录点赞用户，score为时间戳，当存在当前用户ID时就是已经点过赞了
- 使用锁防止同一用户并发点赞同一文章（占用一定资源）



## 点赞排行榜

**产品需求**：

- 展示最早点赞的前几个用户

**实现方案**：

- 利用先前点赞的zset记录获取score排序为0,4的用户id
- 按照时间戳先后顺序返回（早在前）







----



## Zset——Sorted Set

支持排序的set，每个set都有自己的score，可以根据score加速查找以及排序（而set是不支持在redis中排序的）

zadd/remove key value score

```java
stringRedisTemplate.opsForZSet().add(key, loginUser.getId().toString(), System.currentTimeMillis());
stringRedisTemplate.opsForZSet().remove(key, loginUser.getId().toString());
```

像是set的ismember就被替代为了score（获取value的score）

```java
Double isMember = stringRedisTemplate.opsForZSet().score(key, loginUser.getId().toString());
```

倘若存在就会得到score，反之则是null

如果需要一个score范围的对象Set，那就可以

zrange key 0 5（从0到5，一共6个元素）

```java
Set<String> top5 = stringRedisTemplate.opsForZSet().range(key, 0, 5);
```



## sql中的field(id, ...)

我们根据zset的时间戳score获取到了前五个id，想要根据id查到对应用户信息并按照**时间先后**返回结果（早的在前）：

```java
Set<String> top5 = stringRedisTemplate.opsForZSet().range(key, 0, 4);
if (top5 == null || top5.isEmpty()) {
	return Result.ok(Collections.emptyList());
}
List<Long> ids = top5.stream().map(Long::valueOf).collect(Collectors.toList());
String idsStr = StrUtil.join(",", ids);
List<User> users = userService.list(new QueryWrapper<User>().
        in("id", ids).
        last(" order by field(id, " + idsStr + ")")
);
```

> last为mybatisplus的QueryWrapper提供的添加最后一行sql语句，和UpdateWrapper的setsql类似，可以**自己直接写sql**

`ORDER BY FIELD()` 是一种**自定义排序**的方式，允许你按照指定的字段值顺序进行排序，而不是默认的升序（ASC）或降序（DESC）。

这里直接返回会按照id的大小自动升序排序，假如我们需要自定义顺序，就可以给出列，按照自己的列的value排序

```sql
SELECT * FROM table_name
ORDER BY FIELD(column_name, value1, value2, value3, ...);
```

- `column_name`：你要排序的列。
- `value1, value2, ...`：你希望该列按此顺序排列的值。
- 不在 `FIELD()` 列表中的值会被排在**最后**（视为 0），并按自然顺序排列（通常在末尾）。

**但注意这个要求你一定清楚结果中含对应列的结果！这里的in和他就是完美搭配！**

> 其实如果不想用这个也可以自己new一个List，遍历ids（时间先后顺序遍历），查到一个add一个就可以保证是时间先后顺序的了。
