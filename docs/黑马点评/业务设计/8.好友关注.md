---
title: 好友关注
date: 2025-1-20
---

## 关注与取关

**产品需求**：

- 提供关注以及取关接口

**实现方案**：

- 构建**关注关系表**，利用这个表来实现关系的记录以及其他操作
- 关注即添加数据项到表中，取关即从表中删除该项
- 通过查询是否存在该项，实现关注查询



## 共同关注

**产品需求**：

- 提供根据**用户ID**查询**用户信息**以及其的**所有blog**接口
- 提供当前登录用户以及目标用户的共同关注对象
- 提供关注列表接口

**实现方案**：

- curd简单实现用户ID查询信息以及blog
- 额外使用Redis的**set**缓存用户的**关注对象表**，关注时add，取关时remove，尝试获取关注列表时提取Redis的set集合即可
- 使用Redis的set集合提供的**交集**功能实现共同关注的快速查询

> ```java
> Set<String> intersect = stringRedisTemplate.opsForSet().intersect(key, key2);
> ```
>
> map转成List后，使用List获取用户信息并返回



## 关注推送

**产品需求**：

- 即**内容推送**，根据用户信息推送相关类型文章，所谓“Feed”流，用户量较少，直接使用**写扩散**（推送）
- 为每个用户维护自己的收件箱，关注对象发布文章时将文章id存储至自己的收件箱中
- 当下拉时分页获取关注对象的推送文章

**实现方案**：

- 发布文章时从数据库的**关注表**获取自己的**粉丝List**，根据List内容将文章id存储至对应“收件箱”（**zset**，score为**时间戳**）（可以**MQ**）
- 用户获取推送时从zset中获取文章，**滚动分页**记录**上次查询score**，range分页获取文章id，再到数据库查询获取完整文章

> zset根据score排序range范围查询：
>
> | 命令                                                         | 功能                           |
> | :----------------------------------------------------------- | :----------------------------- |
> | `ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]` | **按 score 范围升序** 获取成员 |
> | `ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count]` | **按 score 范围降序** 获取成员 |
> | `ZRANGE key start stop [BYSCORE] [REV] [WITHSCORES]`（Redis 6.2+） | 统一语法，更灵活               |
>
> 命令解析：
>
> ```bash
> ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]
> ```
>
> - `key`：ZSet 的键名
> - `min` / `max`：score 的最小值和最大值（可为 `-inf` / `+inf`）
> - `WITHSCORES`：是否返回 score（默认只返回成员）
> - `LIMIT offset count`：分页支持（类似 SQL 的 LIMIT）
>
> 排行榜，以及需要分页的情况，考虑使用zset

> 注意！**粉丝List**不适合做Redis的set集合！正常**关注列表**较大的可能也就1000多个，**占用空间比较小**，所以可以使用Redis存储；但是粉丝列表可能会有几万个几百万个，这种情况下再使用Redis存储就**太占用内存**了，所以我们还是使用**数据库**关联查询。
>
> （实际上关注列表也占用相当大的资源，还有可能其实和粉丝列表其实差不多大）
>
> 同时，相比起**关注List**在实际业务中会**频繁**查询其中的信息，比如点开动态，共同关注等很多操作；而专门使用粉丝List的功能比较少，基本就是**推送**以及**查看粉丝列表**的时候会简单看一下。















----



## Redis的Set提供的额外功能

Redis 的 **Set（集合）** 是一种无序、不重复的字符串集合数据结构，底层基于哈希表实现，因此具有 **O(1) 平均时间复杂度** 的增删查操作。除了基本的添加、删除、判断成员是否存在等操作外，Redis 的 Set 还提供了许多**强大的额外功能**，尤其在**集合运算**和**高级应用场景**方面非常实用。

### **一、核心额外功能：集合运算（Set Operations）**

这是 Redis Set 最突出的优势 —— 支持高效的**多集合之间的数学运算**：

| 命令                               | 功能                                                  | 时间复杂度                             |
| :--------------------------------- | :---------------------------------------------------- | :------------------------------------- |
| `SINTER key1 [key2 ...]`           | 求多个集合的**交集**                                  | O(N×M)，N 为最小集合大小，M 为集合数量 |
| `SUNION key1 [key2 ...]`           | 求多个集合的**并集**                                  | O(N+M+...)，总元素数                   |
| `SDIFF key1 key2 [key3 ...]`       | 求 key1 与其他集合的**差集**（key1 - key2 - key3...） | O(N+M+...)                             |
| `SINTERSTORE dest key1 [key2 ...]` | 将交集结果**存储到新集合** `dest`                     | 同 SINTER                              |
| `SUNIONSTORE dest key1 [key2 ...]` | 将并集结果存储                                        | 同 SUNION                              |
| `SDIFFSTORE dest key1 key2 ...`    | 将差集结果存储                                        | 同 SDIFF                               |

> ✅ **典型应用**：
>
> - 共同关注（A 和 B 都关注的人）→ `SINTER user:A:follows user:B:follows`
> - 推荐系统（看过商品 A 的人还看了哪些商品）→ 并集去重
> - 权限校验（用户权限 ∩ 系统所需权限 ≠ ∅？）

------

### **二、随机操作（Random Element）**

| 命令                      | 功能                                                         |
| :------------------------ | :----------------------------------------------------------- |
| `SRANDMEMBER key [count]` | 随机返回一个或多个元素（**不移除**） • `count > 0`：返回不重复元素 • `count < 0`：允许重复（类似抽样放回） |
| `SPOP key [count]`        | 随机**弹出**一个或多个元素（**会移除**）                     |

> ✅ **典型应用**：
>
> - 抽奖系统（从用户池中随机抽 N 人）
> - A/B 测试分组
> - 缓存预热时随机加载部分数据

------

### **三、集合信息与扫描**

| 命令                                             | 功能                                               |
| :----------------------------------------------- | :------------------------------------------------- |
| `SCARD key`                                      | 获取集合元素个数（O(1)）                           |
| `SSCAN key cursor [MATCH pattern] [COUNT count]` | **增量迭代**集合元素（避免 `SMEMBERS` 阻塞大集合） |

> ⚠️ 注意：不要对大集合使用 `SMEMBERS`，它会一次性返回所有元素，可能导致 Redis 阻塞。应使用 `SSCAN` 分批处理。

------

### **四、移动元素（跨集合操作）**

| 命令                              | 功能                                                         |
| :-------------------------------- | :----------------------------------------------------------- |
| `SMOVE source destination member` | 将 `member` 从 `source` 集合**原子性地移动**到 `destination` 集合 |

> ✅ **典型应用**：
>
> - 任务队列状态转移（如：`pending_tasks` → `processing_tasks`）
> - 用户分群迁移（如：从“新用户”移到“活跃用户”）

------

### **五、高级应用场景（结合其他数据结构）**

虽然 Set 本身是独立结构，但常与其他类型配合使用：

#### **1.** ***\*去重 + 计数\****

- 用 Set 存储唯一 ID（如 UV 统计），用 `SCARD` 快速获取去重数量。
- 对比：HyperLogLog 虽省内存，但有误差；Set 精确但耗内存。

#### **2.** ***\*标签系统\****

- 每个标签对应一个 Set（如 `tag:python` 包含所有带该标签的文章 ID）
- 查找同时带多个标签的内容：`SINTER tag:python tag:redis`

#### **3.** ***\*好友关系 & 社交网络\****

- `user:123:friends` = Set of friend IDs
- 共同好友：`SINTER user:123:friends user:456:friends`
- 可能认识的人：`(A 的好友 ∪ B 的好友) - (A ∩ B) - {A, B}`

#### **4.** ***\*实时协同过滤\****

- 用户行为存为 Set（如 `user:123:viewed_items`）
- 找相似用户：计算与其他用户 Set 的交集大小

------

### **六、注意事项**

1. **元素必须是字符串**：Set 中所有成员都是 string 类型（即使你存数字，也是按字符串比较）。
2. **无序性**：Set 不保证元素顺序，不要依赖遍历顺序。
3. **内存消耗**：每个元素约占用 20–30 字节（含哈希表开销），不适合超大规模去重（此时考虑 Bloom Filter 或 HyperLogLog）。
4. **原子性**：所有命令都是原子操作，适合并发场景。

------

### **总结：Redis Set 的“额外价值”**


| 功能类别     | 核心优势                 |
| :----------- | :----------------------- |
| **集合运算** | 交/并/差集，支持存储结果 |
| **随机操作** | 安全抽样、弹出           |
| **高效计数** | `SCARD` O(1)             |
| **原子移动** | `SMOVE` 跨集合转移       |
| **组合应用** | 标签、社交、推荐系统基石 |

> 💡 如果你需要**精确去重 + 集合逻辑运算 + 快速成员判断**，Redis Set 是非常强大的工具。



## 推送模式

> 此处仅讨论**关注博主**的**文章推送**，对于AI模型实现的用户模式匹配以及算法推送不讨论

| 模式       | 别名           | 核心思想                                                 | 适合对象         | 优缺点                                   |
| :--------- | :------------- | :------------------------------------------------------- | :--------------- | ---------------------------------------- |
| **写扩散** | 推模式（Push） | 发布时**主动推送给所有粉丝**，存入他们的收件箱           | 普通up，热情粉丝 | 粉丝获取**快**；占用资源大，数据库压力大 |
| **读扩散** | 拉模式（Pull） | 发布时**只存一份**，粉丝读取时**实时拉取关注列表的内容** | 大V，僵尸粉      | 粉丝获取**慢**；占用资源少，数据库压力小 |

在**用户量比较少**的情况下，我们**一般**使用**写扩散**，**读扩散**看似简单，用户只需要从所有关注对象的发布内容表中读取更新文章内容到自己的收件箱中，但实际上要针对这些内容做速率优化，要实现的东西不是一点两点的；

而**写扩散**只需将作者的文章内容写入所有粉丝的收件箱即可，不仅**读得快**，而且由于用户量比较少，每个用户的收件箱所需资源加起来也不是不能接受。

一般情况下，认为**活跃用户**不超过**一百万**可以简单使用**写扩散**来解决**推送问题**。

### 读扩散（拉）

更新后需要读者**主动**获取更新内容

**流程**：

1. 用户 A 发布动态 → **只存一份**到全局帖子表（发件箱）（如 `posts:A:123`）
2. 粉丝 B 打开首页时：
   - 先查 B 关注了哪些人（如 [A, C, D]）
   - **并发拉取 A、C、D 的最新 N 条帖子**
   - 合并排序后返回前端

**优点**：

- 写操作轻量（只写一次）
- 存储节省（无冗余）
- 适合**超大 V 场景**

**缺点**：

- 读操作**复杂、慢**（需查多个用户 + 合并排序）
- 关注人数多（如关注 5000 人）→ 读扩散**爆炸**
- 实时性依赖拉取频率

> 🌰 举例：Twitter 早期全用写扩散，后来对大 V（如 Lady Gaga）改用读扩散。



### 写扩散（推）

更新后自动复制推送至所有粉丝的收件箱，读者可直接在自己的收件箱获取推送内容

**流程**：

1. 用户 A 发布一条动态（如“今天天气真好”）
2. 系统查出 A 的所有粉丝（比如 100 万人）
3. 将这条动态写入每个粉丝的“个人时间线”（Timeline）集合中（收件箱）
   - 例如：`timeline:user:1001` → 添加 post_id
   - `timeline:user:1002` → 添加 post_id
   - ...
4. 粉丝 B 打开首页时，**直接读自己的 timeline**，O(1) 获取最新内容

**优点**：

- 读极快（只需查自己 timeline）
- 适合**粉丝少 or 中等规模**的普通用户

**缺点**：

- 大 V（百万粉）发一条内容 → **瞬间写扩散 100 万次**
- 可能**压垮数据库**（Redis / DB 写瓶颈）
- **存储冗余高**（同一条内容存百万份）

> 🌰 举例：微信朋友圈早期对普通用户用写扩散，但对“公众号”或“大 V”禁用。

### 混合方案

纯推 or 纯拉都有缺陷，**主流系统都采用混合策略**：

| 用户类型                       | 策略                                                         |
| :----------------------------- | :----------------------------------------------------------- |
| **普通用户**（粉丝 < 1000）    | ✅ 写扩散（推）                                               |
| **大 V / 明星**（粉丝 > 10万） | ✅ 读扩散（拉）                                               |
| **超级大 V**（粉丝 > 100万）   | ⚠️ 只允许发短内容 or 限流                                     |
| **热情活跃粉丝**               | ✅ 写扩散（普通推流前先对用户群体检测，存在该类粉丝则先对其写扩散） |

### **🔧 实现技巧：**

- **粉丝数阈值**：动态判断用推还是拉
- **缓存优化**：大 V 的最新 N 条帖子缓存在 Redis，减少 DB 压力
- **异步队列**：写扩散走 Kafka / MQ，避免阻塞发布接口
- **分页兼容**：第一页用写扩散（快），翻页用读扩散（省存储）



## 滚动分页查询

利用Redis的zset可以实现按照score排序实现对于收件箱信息的范围查询， 我们就可以逆序获取最新的几条文章。当前端滚动到底部，我们根据**最后**获取到的文章的时间戳（**最小/早时间戳**）去**跳过自己**再逆序获取count个文章id即可。

但是需要注意使用时间戳进行排序可能会遇到最小**时间戳一样**的情况（虽然基本不可能），那么这时候我们就需要记录本次查询所得的**相同最小时间戳的个数**并在下一次查询跳过，一般**不会重复**的时候，我们也需要**跳过自己**（逆序获取也会将max自己加入结果集），即count取1：

比如收件箱记录了：9 8 8 6 6 6 5 4 3 2 1

而我们现在需要去逆序查询5个数据，还要保证下次查询的不会和先前重复

第一次：98866

如果不做跳过offset条数据操作的第二次，取最小时间戳为6，仅跳过最后一个：66543

这里我们很容易发现重复了一个时间戳为6的项，正确的应该为：65432

那么这时候就需要我们去记录与**本次查询结果的最小时间戳相同的项的个数**，首先，最后一个项时间戳肯定是最小的，也就是说至少一个。而当我们遍历这个**逆序时间戳**时，我们可以记录当前时间戳（一定是已遍历过的时间戳中最小的）假如下一个和自己不一样，那么它一定更小；如果一样，说明都一样最小。针对这两种情况，我们就可以进行最小时间戳计数了：

当前时间戳和上一个不一样，说明当前时间戳最小，计数重置为1；当前时间戳和上一个一样，说明都是最小的时间戳，计数+1：

```java
/**
 * 查询关注用户发布的博文
 * @param max 时间戳
 * @param offset 偏移量
 * @return 博文列表
 */
@Override
public Result queryBlogOfFollow(Long max, Integer offset) {
    // 获取当前用户
    UserDTO user = UserHolder.getUser();
    // 查询收件箱 ZREVRANGEBYSCORE key max min LIMIT offset count (逆序获取最新的，由于是使用时间戳的形式来做范围查询，不需要考虑新加入的文章的丢失，下次再查即可)
    // 我们查完了之后会返回这一次查询的最小时间戳minTime以及本次获取到的相同时间戳项数量offset，下次再查的时候，从这里开始跳过offset条相同时间戳数据，这样就可以避免重复查询，查询新数据
    Set<ZSetOperations.TypedTuple<String>> typedTuples = stringRedisTemplate.opsForZSet().
            reverseRangeByScoreWithScores(FEED_KEY + user.getId(), 0, max, offset, 2);
    if (typedTuples == null || typedTuples.isEmpty()) {
        return Result.ok();
    }
    List<Long> ids = new ArrayList<>(typedTuples.size());
    long minTime = 0;
    int os = 1;
    for (ZSetOperations.TypedTuple<String> tuple : typedTuples) {
        // 获取id
        ids.add(Long.parseLong(Objects.requireNonNull(tuple.getValue())));
        // 获取时间戳
        long timeStamp = Objects.requireNonNull(tuple.getScore()).longValue();
        if (timeStamp == minTime) { // 相同时间戳，说明都是最小的时间戳，所以要跳过
            os++;
        }else { // 不同时间戳，说明不是最小的时间戳，更新时间戳一集计数
            minTime = timeStamp;
            os = 1;
        }
    }

    // 数据库查询博客，根据id的输入顺序获取博客，防止结果集按照id升序排布，结果要求是按照时间戳降序
    String idsStr = StrUtil.join(",", ids);
    List<Blog> blogs = list(new QueryWrapper<Blog>().in("id", ids).last("ORDER BY FIELD(id," + idsStr + ")"));
    blogs.forEach(blog -> {
        isLike(blog);
        queryAuthor(blog);
    });

    // 封装分页结果并返回
    ScrollResult scrollResult = new ScrollResult();
    scrollResult.setList(blogs);
    scrollResult.setOffset(os);
    scrollResult.setMinTime(minTime);

    return Result.ok(scrollResult);
}
```



## @RequestParam 和 @PathVariable的区别

| 特性             | `@RequestParam`                                              | `@PathVariable`                                        |
| :--------------- | :----------------------------------------------------------- | :----------------------------------------------------- |
| **来源**         | URL 的 **查询参数**（Query Parameters） 如：`/users?name=alice&age=25` | URL 的 **路径变量**（Path Variables） 如：`/users/123` |
| **位置**         | 在方法参数上使用                                             | 在方法参数上使用                                       |
| **URL 示例**     | `GET /api/users?name=Tom`                                    | `GET /api/users/123`                                   |
| **是否必需**     | 默认是必需的（可设 `required = false`）                      | 默认是必需的（路径必须匹配）                           |
| **适用请求类型** | GET、POST 等都支持（只要 URL 有 query）                      | 所有 HTTP 方法（只要路径有占位符）                     |

`@RequestParam`：使用**？拼接**得到请求参数

```java
@GetMapping("/search")
public String search(
    @RequestParam String keyword,          // 必须传 keyword
    @RequestParam(defaultValue = "1") int page, // 可不传，默认值 1
    @RequestParam(required = false) String sort // 可选参数
)
```

- ✅ `/search?keyword=spring` → `page=1`, `sort=null`
- ✅ `/search?keyword=spring&page=2&sort=date`

`@PathVariable`：请求参数直接在**路径中**

```java
@GetMapping("/orders/{orderId}/items/{itemId}")
public Item getItem(
    @PathVariable Long orderId,
    @PathVariable Long itemId
)
```

- ✅ `/orders/111/items/15` → `orders=111`, `items=15`

| 场景                                                        | 使用                                     |
| :---------------------------------------------------------- | :--------------------------------------- |
| 分页、搜索条件、过滤参数（如 `?page=1&size=10`）            | ✅ `@RequestParam`                        |
| 资源 ID、层级路径（如 `/users/123`, `/posts/456/comments`） | ✅ `@PathVariable`                        |
| 可选参数、带默认值的参数                                    | ✅ `@RequestParam`（支持 `defaultValue`） |
| RESTful 风格的资源定位                                      | ✅ `@PathVariable`（符合 REST 规范）      |

混合使用：

```java
@GetMapping("/users/{userId}/messages")
public List<Message> getMessages(
    @PathVariable Long userId,               // 路径中的用户ID
    @RequestParam(defaultValue = "0") int offset,
    @RequestParam(defaultValue = "20") int limit,
    @RequestParam(required = false) String status
) {
    // 查询用户 userId 的消息，分页 + 状态过滤
}
```

