---
title: uv统计
date: 2025-1-24
---

### UV与PV

- **UV：**Unique Visitor，独立访问量，指的是访问用户量，记录一段时间内有**多少个人**访问了网站，一个用户计数时间内访问多次，只计一次。
- **PV：**Page View，页面访问量，记录一段时间内有**多少个页面访问请求**，一个用户一天访问多次，计多次。可以作为访问流量的统计。

我们如果使用Redis去记录PV，那么只需要前端发一次请求，我们对当前日期的pv记录+1，只需要存储计数本身即可。

可是如果要使用Redis的set去用于统计UV的去重，那么我们还需要存储今日访问过的用户用于判断是否本次请求是否计数+1，那么这就会需要很大的额外空间用于存储该set。

那么这里我们要**怎么去存储用户在某一段时间的登录情况**是需要研究的问题。

> 其实也可以去查一下该用户上次登录/签到时间，假如不是今日就+1并刷新登录/签到时间；假如今日已登录/签到过则不计数



### HyperLogLog

HyperLogLog 是一种**概率型数据结构（probabilistic data structure）**，主要用于**高效估算大规模数据集中不重复元素的基数（cardinality）**，即集合中不同元素的数量。它由 Philippe Flajolet 等人在 2007 年提出，是对早期 LogLog 算法的改进。

------

 **核心思想**

HyperLogLog 的核心思想基于一个有趣的观察：

> 在一个随机均匀分布的哈希函数输出中，如果某个哈希值以很多个 0 开头（比如二进制表示为 `000...01xxxx`），那么出现这种情况的概率非常低。因此，如果我们在一组哈希值中观察到“最长前导零”的长度为 k*k* ，就可以估计这组数据大概有 2k2*k* 个不同的元素。

但仅靠一次观测误差很大，所以 HyperLogLog 使用 **分桶（stochastic averaging）** 技术：

- 将哈希值的前若干位作为“桶索引”（register index），剩下的部分用于计算前导零的个数。
- 比如使用 14 位作为桶索引，就有 m=214=16384*m*=214=16384 个桶。
- 每个桶记录该组中观察到的最大前导零数量。

最后通过调和平均（harmonic mean）对所有桶的估计值进行聚合，得到更稳定的基数估计。

------

 **优点**

- **内存占用极小**：例如，Redis 中的 HyperLogLog 只需约 **12KB** 内存，就能以 **<1% 的标准误差** 估算多达 264264 个唯一元素。
- **支持合并**：两个 HyperLogLog 结构可以合并（union），合并后的结构仍能准确估计并集的基数。这对分布式系统非常有用。
- **单次遍历**：只需扫描数据一次，适合流式处理。

------

 **缺点**

- **只能估算基数**，不能知道具体有哪些元素。
- **无法删除元素**（因为是概率结构，没有存储原始数据）。
- 对于很小的基数（比如 < 100），误差相对较大（不过可通过线性计数等修正方法优化）。

------

 **应用场景**

- 统计网站的独立访客数（UV）。
- 社交网络中统计某内容的独立点赞用户数。
- 大数据系统中去重计数（如 Spark、Redis、Google BigQuery 都内置了类似结构）。
- 网络流量分析中的源 IP 去重统计。



### 在业务中借助HLL实现UV统计

根据以上的优缺点，我们可以发现HLL确实是比较符合UV统计的场景要求的。其占用资源小，虽然存在一定的误差概率问题，但是在大用户量的情况下，UV统计也不在乎这么一点出错。

```java
@Test
public void testHLL() {
    String key = "hl:user:view:";
    for (int i = 0; i < 10; i++) {
        redisTemplate.opsForHyperLogLog().add(key, "1", "2", "3", "4", "5");
    }
    long count = redisTemplate.opsForHyperLogLog().size(key);
}
```

最终我们可以发现测试结果为5，符合要求。

放到业务中，我们可以将年月日等时间设置一个key，在用户**登录**的时候对所对应的key尝试add用户的userid，在管理后台尝试size获取对应key所存储的结果。

> 这里的uv统计操作可以放入异步消息队列。