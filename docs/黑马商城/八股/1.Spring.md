---
title: Spring八股
date: 2026-1-30
---

## 为什么不推荐使用`@Autoweird`了？

------

### 一、什么是 **依赖注入（Dependency Injection, DI）**？

**依赖注入是一种设计模式**，属于“控制反转（IoC）”的一种实现方式。

#### 核心思想：

> **一个对象的依赖（即它需要使用的其他对象），不由它自己创建，而是由外部“注入”进来。**

#### 举个例子（不用 Spring）：

```java
// 不好的做法：自己 new 依赖
public class OrderService {
    private PaymentService payment = new AlipayPaymentService(); // 紧耦合！
}

// 好的做法：依赖由外部提供（注入）
public class OrderService {
    private PaymentService payment;

    // 通过构造器注入
    public OrderService(PaymentService payment) {
        this.payment = payment;
    }
}
```

这样，`OrderService` 不再绑定具体实现，可以轻松切换为 `WechatPaymentService`，也更容易测试（传 mock 对象即可）。

✅ **这就是依赖注入的本质——解耦 + 可配置 + 可测试。**

------

### 二、`@Autowired` 是依赖注入吗？

✅ **是的！但它是 Spring 框架提供的“自动依赖注入”的一种实现方式。**

Spring 通过 `@Autowired` 注解，**自动查找容器中匹配类型的 Bean，并把它注入到目标位置**（字段、构造器、方法等）。

所以：

- **依赖注入** 是 **概念/模式**
- **`@Autowired`** 是 Spring 实现该模式的 **具体技术手段**

> 类比：
> “交通工具” 是概念，
> “汽车” 是具体实现。
> 同理，“依赖注入” 是概念，“`@Autowired`” 是 Spring 的实现方式之一。

------

### 三、为什么又叫 **字段注入（Field Injection）**？

因为 `@Autowired` **可以写在字段上**，这种用法就叫“字段注入”：

```java
@Service
public class OrderService {
    @Autowired               // ← 注解直接写在字段上
    private PaymentService paymentService;
}
```

除了字段，`@Autowired` 还可以用在：

- **构造器上** → 构造器注入
- **Setter 方法上** → Setter 注入

所以：

| 写法                          | 名称                                |
| ----------------------------- | ----------------------------------- |
| `@Autowired` on field         | 字段注入（Field Injection）         |
| `@Autowired` on constructor   | 构造器注入（Constructor Injection） |
| `@Autowired` on setter method | Setter 注入（Setter Injection）     |

它们都是 **依赖注入的不同实现形式**，而 `@Autowired` 是触发 Spring 自动注入的“开关”。

------

### 四、为什么不推荐字段注入？

虽然字段注入代码简洁，但**存在严重缺陷**，因此 Spring 官方和主流架构师都**不推荐在生产代码中使用**。

#### ❌ 主要问题：

#### 1. **隐藏了类的真实依赖**

```java
public class OrderService {
    @Autowired
    private PaymentService payment;
    @Autowired
    private NotificationService notifier;
    @Autowired
    private InventoryService inventory;
    // ... 可能还有更多
}
```

- 从类的 public 接口（构造器/方法）**看不出它依赖什么**
- 别人阅读代码时无法快速理解其依赖关系
- 违反了“显式优于隐式”的设计原则

> 对比构造器注入：
>
> ```java
> public OrderService(PaymentService p, NotificationService n, InventoryService i) { ... }
> ```
>
> 一眼就知道需要哪些依赖！

------

#### 2. **无法将依赖设为 `final`**

字段注入的字段必须是非 final 的（因为 Spring 通过反射赋值）：

```java
@Autowired
private PaymentService payment; // 不能加 final
```

而构造器注入可以：

```java
private final PaymentService payment; // ✅ 安全、不可变
```

不可变对象更安全，尤其在并发环境下。

------

#### 3. **难以单元测试**

字段注入的类**无法在不启动 Spring 容器的情况下被正确实例化**：

```java
@Test
void testOrderService() {
    // ❌ paymentService 是 null！
    OrderService service = new OrderService();
    service.processOrder(); // NPE!
}
```

你必须：

- 使用 `@SpringBootTest`（慢）
- 或用反射手动设值（丑陋）
- 或用 Mockito 的 `@InjectMocks`（有局限）

而构造器注入：

```java
@Test
void testOrderService() {
    PaymentService mock = Mockito.mock(PaymentService.class);
    OrderService service = new OrderService(mock); // ✅ 直接传参，简单干净
    service.processOrder();
}
```

------

#### 4. **可能导致 `NullPointerException`**

如果某个字段注入失败（比如 Bean 未定义），Spring 启动时可能不报错（尤其是可选依赖），运行时才 NPE。

而构造器注入：**只要依赖缺失，应用启动就失败**，问题尽早暴露。

------

#### 5. **容易违反单一职责原则**

因为字段注入太方便，开发者可能不知不觉注入 10 个、20 个依赖，导致类变得臃肿。

而构造器注入参数太多时，你会立刻意识到：“这个类是不是做得太多了？” → 促使你重构。

------

### ✅ 正确做法：优先使用 **构造器注入**

```java
@Service
public class OrderService {

    private final PaymentService paymentService;
    private final NotificationService notificationService;

    public OrderService(
        PaymentService paymentService,
        NotificationService notificationService
    ) {
        this.paymentService = paymentService;
        this.notificationService = notificationService;
    }
}
```

> 🎉 从 Spring 4.3 开始，**如果只有一个构造器，连 `@Autowired` 都可以省略！**

------

### 🔚 总结

| 问题                            | 回答                                                     |
| ------------------------------- | -------------------------------------------------------- |
| **什么是依赖注入？**            | 一种设计模式：依赖由外部提供，而非自己创建               |
| **`@Autowired` 是依赖注入吗？** | 是，它是 Spring 实现依赖注入的注解                       |
| **为什么叫字段注入？**          | 因为 `@Autowired` 写在字段上，通过反射赋值               |
| **为什么不推荐字段注入？**      | 隐藏依赖、不能 final、难测试、易出错、鼓励坏设计         |
| **应该用什么？**                | **构造器注入**（必需依赖） + **Setter 注入**（可选依赖） |

> 💡 记住：**依赖注入 ≠ 字段注入**。字段注入只是依赖注入的一种（不推荐的）实现方式。

### **🔧 补充：配合 Lombok 使用（超简洁！）**

如果你用 [Lombok](https://projectlombok.org/)，代码可以更干净：

```java
@Service
@RequiredArgsConstructor // 自动生成包含 final 字段的构造器
public class OrderService {

    private final PaymentService paymentService;
    private final NotificationService notificationService;
}
```

等价于：

```java
public OrderService(PaymentService paymentService, NotificationService notificationService) {
    this.paymentService = paymentService;
    this.notificationService = notificationService;
}
```

✅ Spring 会自动注入，**完全不需要 `@Autowired`**！

> 💡 这是现代 Spring Boot 项目的常见写法。

### 对于循环依赖的处理













## synchronized

`synchronized` 是 Java 中用于实现**线程同步**的关键字，它可以修饰 **方法（Method）** 或 **代码块（Block）**，但**不能修饰变量、类或构造器**。

下面详细说明 `synchronized` 的两种使用位置及其区别：

------

### 一、1️⃣ 修饰实例方法（Instance Method）

#### ✅ 语法：

```java
public synchronized void method() {
    // 同步代码
}
```

#### 🔒 锁对象：

- **当前实例对象（this）**
- 多个线程调用**同一个对象**的该方法时，会互斥执行
- 调用**不同对象**的该方法，**不互斥**（因为锁的是各自 this）

#### 📌 示例：

```java
public class Counter {
    private int count = 0;

    public synchronized void increment() {
        count++; // 线程安全
    }
}

// 使用
Counter c1 = new Counter();
Counter c2 = new Counter();

// t1 和 t2 操作 c1 → 互斥
new Thread(() -> c1.increment()).start();
new Thread(() -> c1.increment()).start();

// t3 和 t4 操作 c2 → 互斥
new Thread(() -> c2.increment()).start();
new Thread(() -> c2.increment()).start();

// 但 c1 和 c2 之间不互斥！
```

> ⚠️ 注意：如果方法是 `private`、`protected` 或包私有，也可以加 `synchronized`。

------

### 二、2️⃣ 修饰静态方法（Static Method）

#### ✅ 语法：

```java
public static synchronized void staticMethod() {
    // 同步代码
}
```

#### 🔒 锁对象：

- **当前类的 Class 对象（如 `Counter.class`）**
- 所有线程调用该静态方法时，**全局互斥**

#### 📌 示例：

```java
public class Counter {
    private static int totalCount = 0;

    public static synchronized void addTotal() {
        totalCount++; // 全局线程安全
    }
}

// 所有线程调用 Counter.addTotal() 都会竞争同一把锁
new Thread(Counter::addTotal).start();
new Thread(Counter::addTotal).start();
```

> 💡 本质等价于：
>
> ```java
> public static void addTotal() {
>     synchronized (Counter.class) {
>         totalCount++;
>     }
> }
> ```

------

### 三、3️⃣ 修饰代码块（Synchronized Block）

#### ✅ 语法：

```java
synchronized (lockObject) {
    // 同步代码
}
```

#### 🔒 锁对象：

- **任意非 null 对象**（由你指定）
- 最灵活的方式，可精确控制锁粒度

#### 📌 常见用法：

#### （1）锁当前实例

```java
public void method() {
    synchronized (this) {
        // 等价于 synchronized 实例方法
    }
}
```

#### （2）锁 Class 对象（等价于静态方法同步）

```java
public void method() {
    synchronized (Counter.class) {
        // 全局同步
    }
}
```

#### （3）锁私有对象（推荐！避免外部干扰）

```java
public class SafeTask {
    private final Object lock = new Object(); // 私有锁对象

    public void doWork() {
        synchronized (lock) {
            // 只有本类能拿到这把锁，安全！
        }
    }
}
```

> ✅ **最佳实践**：优先使用私有锁对象，避免使用 `this` 或 `String`/`Integer` 等可能被外部共享的对象作为锁。

------

### ❌ 不能用的地方（常见误区）

| 位置                  | 是否允许           | 说明                                                         |
| --------------------- | ------------------ | ------------------------------------------------------------ |
| **变量**              | ❌                  | `synchronized int x;` → 编译错误                             |
| **构造器**            | ❌                  | `public synchronized MyClass()` → 编译错误（构造器只被一个线程调用，无需同步） |
| **类**                | ❌                  | `synchronized class A {}` → 语法错误                         |
| **接口方法**          | ❌                  | 接口方法不能有实现，无法加 synchronized                      |
| **Lambda 表达式内部** | ⚠️ 可以写，但无意义 | Lambda 本身不是方法声明                                      |

------

### 🔑 核心总结

| 使用方式                            | 锁对象       | 适用场景                       |
| ----------------------------------- | ------------ | ------------------------------ |
| `synchronized void method()`        | `this`       | 保护实例状态                   |
| `static synchronized void method()` | `Class` 对象 | 保护静态/全局状态              |
| `synchronized (obj) { ... }`        | 任意对象     | 精细控制、避免死锁、提高并发度 |

------

### 💡 高级建议

1. **尽量缩小同步范围**：只同步必要代码，减少锁持有时间。

2. **避免锁嵌套**：容易引发死锁。

3. 不要用字符串常量作锁：

   ```java
   synchronized ("lock") { ... } // 危险！字符串常量池共享
   ```
   
4. **考虑使用 `java.util.concurrent` 包**：如 `ReentrantLock`、`AtomicInteger` 等，功能更强大。

> ✅ **记住**：
> **“同步方法是语法糖，底层都是 synchronized 块；锁什么对象，决定谁在排队。”**









## volatile

`volatile` 是 Java 中一个**轻量级的同步机制**关键字，用于修饰**共享变量**，主要解决 **多线程环境下的可见性（Visibility）和有序性（Ordering）问题**，但**不保证原子性（Atomicity）**。

------

### 一、核心作用：三大特性中的两个

Java 内存模型（JMM）定义了线程与主内存之间的交互规则。`volatile` 主要影响以下两点：

| 特性                     | 是否保证 | 说明                                                     |
| ------------------------ | -------- | -------------------------------------------------------- |
| **可见性（Visibility）** | ✅ 保证   | 一个线程修改 `volatile` 变量后，其他线程能立即看到最新值 |
| **有序性（Ordering）**   | ✅ 保证   | 禁止指令重排序（通过内存屏障实现）                       |
| **原子性（Atomicity）**  | ❌ 不保证 | 如 `volatile int count; count++` 仍非原子操作            |

> 🔑 **一句话总结**：
> **`volatile` = 可见性 + 禁止重排序，≠ 原子性**

------

### 二、可见性问题示例（不用 volatile 的后果）

```java
public class VolatileDemo {
    private boolean running = true; // 没加 volatile！

    public void stop() {
        this.running = false;
    }

    public void run() {
        while (running) { // 可能永远循环！
            // do something
        }
        System.out.println("Thread stopped");
    }
}
```

#### ❌ 问题：

- 线程 A 执行 `run()`，读取 `running` 到**工作内存（CPU 缓存）**
- 线程 B 调用 `stop()`，修改主内存中的 `running = false`
- 但线程 A **看不到更新**，继续使用缓存中的 `true` → 死循环！

#### ✅ 解决：

```java
private volatile boolean running = true; // 加 volatile
```

→ 线程 B 修改后，线程 A 会**强制从主内存重新读取**最新值。

------

### 三、禁止指令重排序（有序性）

编译器和 CPU 为了优化性能，可能对指令重排，但在多线程下可能导致逻辑错误。

#### 经典案例：单例模式（DCL）

```java
public class Singleton {
    private static Singleton instance;

    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton(); // 这行可能被重排序！
                }
            }
        }
        return instance;
    }
}
```

#### ⚠️ 问题：

`new Singleton()` 实际分三步：

1. 分配内存
2. 初始化对象
3. 将 `instance` 指向内存地址

**若发生重排序（1 → 3 → 2）**，其他线程可能拿到一个**未初始化完成的对象**！

#### ✅ 解决：加 `volatile`

```java
private static volatile Singleton instance;
```

→ 禁止重排序，确保“初始化完成”后再赋值。

------

### 四、什么场景适合用 `volatile`？

#### ✅ 适用条件（必须同时满足）：

1. **写操作不依赖当前值**（如 `flag = true`，而不是 `count++`）
2. **变量是独立的**（不与其他变量构成不变性条件）
3. **只被一个线程写，多个线程读**（或写操作本身是原子的）

#### 🌰 典型用法：

| 场景               | 示例                                          |
| ------------------ | --------------------------------------------- |
| **状态标志位**     | `volatile boolean shutdownRequested;`         |
| **一次性安全发布** | `volatile Config config = loadConfig();`      |
| **DCL 单例**       | `private static volatile Singleton instance;` |
| **计数器（仅读）** | `volatile long lastModified;`                 |

------

### 五、什么场景不能用 `volatile`？

#### ❌ 错误示例：自增操作

```java
public class Counter {
    private volatile int count = 0;

    public void increment() {
        count++; // 等价于: read → add → write（三步！）
    }
}
```

→ 多线程下仍会丢失更新！

#### ✅ 正确做法：

- 使用 `synchronized`
- 使用 `AtomicInteger`
- 使用 `ReentrantLock`

```java
// 推荐
private AtomicInteger count = new AtomicInteger(0);
public void increment() {
    count.incrementAndGet();
}
```

------

### 六、`volatile` vs `synchronized` 对比

| 特性         | `volatile`      | `synchronized`     |
| ------------ | --------------- | ------------------ |
| **可见性**   | ✅               | ✅                  |
| **原子性**   | ❌               | ✅                  |
| **有序性**   | ✅（禁止重排序） | ✅（隐式包含）      |
| **性能**     | ⚡ 高（无锁）    | ⏳ 较低（有锁开销） |
| **阻塞**     | ❌ 非阻塞        | ✅ 阻塞             |
| **适用范围** | 仅变量          | 方法/代码块        |

> 💡 **选择原则**：  
>
> - 如果只是**状态标记或简单赋值** → 用 `volatile`  
> - 如果涉及**复合操作（如 i++）** → 用 `synchronized` 或原子类

------

### 七、底层原理（JVM 层面）

`volatile` 通过 **内存屏障（Memory Barrier）** 实现：

- **写屏障（Store Barrier）**：写 `volatile` 变量前，刷新所有之前写操作到主内存
- **读屏障（Load Barrier）**：读 `volatile` 变量后，使后续读操作从主内存加载

这保证了：

1. **写后立即可见**
2. **禁止编译器/CPU 重排序跨越屏障**

------

### ✅ 总结：`volatile` 使用口诀

> **“可见有序它来保，原子操作它不行；
> 状态标志用它好，自增自减别靠它。”**

#### 最佳实践：

- ✅ 用作**布尔开关、配置更新通知、一次性发布**
- ❌ 不要用在**计数器、累加器、复合操作**
- 🔒 复杂同步场景 → 优先考虑 `java.util.concurrent` 包（如 `AtomicXXX`, `CountDownLatch`）

理解 `volatile` 能帮你写出更高效、正确的并发代码，但务必清楚它的能力边界！
