---
title: 微服务初接触
date: 2026-2-1
---

### 所谓微服务

#### 与单体项目的区别

| 类型         | 说明                                                         |
| :----------- | :----------------------------------------------------------- |
| **单体项目** | 所有功能模块（如用户、订单、支付等）打包在一个应用中，共享同一个代码库、数据库和部署单元。 |
| **微服务**   | 系统被拆分为多个小型、独立的服务，每个服务负责单一业务能力，可独立开发、部署、扩展，通常有自己的数据库。 |

> ✅ 单体：像一栋大楼，所有房间连在一起
> ✅ 微服务：像一个小区，每栋楼独立但协同工作

| **对比维度**          | **单体架构（Monolith）**                                     | **微服务架构（Microservices）**                              |
| :-------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| **1. 架构结构**       | 所有模块（UI、业务逻辑、数据访问等）打包为一个应用，单一代码库、单一部署单元。 | 系统拆分为多个小型、独立的服务，每个服务专注单一职责，独立代码库、独立部署。 |
| **2. 开发体验**       | ✅ 初期开发简单，调试方便（本地运行即可） ❌ 模块耦合高，后期代码臃肿，新人上手难 | ❌ 初期复杂（需处理通信、注册发现等） ✅ 模块边界清晰，团队可并行开发，技术栈灵活（如 Java + Go + Python） |
| **3. 部署与发布**     | 🔁 整体打包部署（如一个 JAR） ⚠️ 修改任意功能需全量发布，风险高，回滚成本大 | 🚀 每个服务独立部署 ✅ 只更新受影响服务，支持蓝绿/金丝雀发布，回滚粒度细 |
| **4. 可扩展性**       | 📦 只能整体水平扩展（即使仅一个模块负载高） 💰 资源利用率低    | 🎯 按需扩展特定服务（如只扩“订单”或“推荐”服务） 📈 资源利用率高，成本更优 |
| **5. 技术栈灵活性**   | ⛔ 通常强制统一技术栈（如全 Spring Boot） 🔧 升级框架/数据库影响全局 | ✅ 每个服务可选最适合的技术（如用 Rust 做高性能计算，Python 做 AI） 🔄 技术演进更自由 |
| **6. 数据管理**       | 💾 共享单一数据库 ✅ 支持强一致性 ACID 事务 ⚠️ 表结构变更影响所有模块 | 🗃 每个服务私有数据库（Database per Service） 🔄 需用 Saga/TCC/消息队列实现分布式事务 ⏳ 通常最终一致性 |
| **7. 故障隔离性**     | 💥 一个模块崩溃可能导致整个系统宕机 🔍 故障定位相对简单（日志集中） | 🛡 单个服务故障不影响其他服务（需配合熔断/降级） 🔍 故障排查复杂（需链路追踪、日志聚合） |
| **8. 运维与可观测性** | 🧰 运维简单（监控一个应用） 📊 日志、指标集中，工具链轻量      | 🛠 运维复杂（需容器化、K8s、服务网格等） 🔭 依赖 ELK/Loki、Prometheus、Jaeger 等构建可观测性体系 |
| **9. 安全性**         | 🔒 攻击面小（单一入口） ✅ 认证授权集中管理                    | 🌐 攻击面大（多服务暴露） 🔐 需统一身份认证（OAuth2/JWT）、API 网关、服务间 mTLS 等安全机制 |
| **10. 适用场景**      | • 初创项目 / MVP • 小团队（<10人） • 业务简单、变化少 • 无高并发/高可用要求 | • 大型复杂系统（电商、金融、SaaS） • 多团队协作 • 需快速迭代、弹性伸缩 • 有 DevOps/SRE 能力支撑 |

 ** 补充建议：演进路径**

> **不要为了微服务而微服务！**
> 推荐采用 **渐进式演进**：
>
> **单体 → 模块化单体（清晰分层/包结构） → 提取核心服务为微服务 → 全面微服务化**

------

 **一句话总结**

> **单体适合“快跑”，微服务适合“长跑”。**
> 早期追求速度和简单，选单体；
> 后期追求弹性、独立性和团队自治，再考虑微服务。



#### Springcloud

说明文档：[Spring Cloud](https://spring.io/projects/spring-cloud#overview)

> **不要为新而新**（除了AI应用的技术栈）

**Spring Cloud** 是一套基于 **Spring Boot** 的**微服务开发工具集**，旨在帮助开发者快速构建**分布式系统中的常见模式**，例如：

- 服务注册与发现
- 配置中心
- 负载均衡
- 服务调用（声明式 HTTP 客户端）
- API 网关
- 熔断与容错
- 分布式链路追踪
- 消息总线

> ✅ **一句话定义**：
> **Spring Cloud = Spring Boot + 微服务治理能力**

| 功能               | Spring Cloud 抽象接口           | 常见实现（可插拔）                                       |
| :----------------- | :------------------------------ | :------------------------------------------------------- |
| **服务注册与发现** | `DiscoveryClient`               | Eureka（Netflix）、**Nacos**（Alibaba）、Consul          |
| **配置中心**       | `@RefreshScope` + Config Client | Spring Cloud Config、**Nacos**、Apollo                   |
| **负载均衡**       | `LoadBalancerClient`            | **Spring Cloud LoadBalancer**（Ribbon 已停用）           |
| **服务调用**       | `@FeignClient`                  | **OpenFeign**（声明式 REST 客户端）                      |
| **API 网关**       | —                               | **Spring Cloud Gateway**（推荐）、Zuul（旧）             |
| **分布式事务**     | —                               | **Seata**                                                |
| **熔断/限流**      | Circuit Breaker                 | Resilience4j、**Sentinel**（Alibaba）、Hystrix（已停用） |
| **链路追踪**       | —                               | Sleuth + Zipkin / SkyWalking                             |
| **消息总线**       | `@RefreshScope` + Bus           | Spring Cloud Bus（配合 RabbitMQ/Kafka 实现配置动态刷新） |

> 💡 Spring Cloud 强调 **“抽象 + 多种实现”**，你可以自由替换底层技术（如用 Nacos 替代 Eureka）。



#### 依赖管理

SpringCloud自己管理维护了各个版本的组件之间的依赖关系，直接引入父组件的pom即可不必再为依赖管理烦恼，只需要看大版本与基础的SpringBoot（以及SpringCloud Alibaba）之间的依赖关系即可：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
         http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.example</groupId>
    <artifactId>my-spring-cloud-app</artifactId>
    <version>1.0.0</version>
    <packaging>jar</packaging>

    <properties>
        <java.version>17</java.version>
        <spring-boot.version>3.2.0</spring-boot.version>
        <spring-cloud.version>2023.0.0</spring-cloud.version>
    </properties>

    <!-- 关键：通过 dependencyManagement 导入 Spring Boot 和 Spring Cloud 的 BOM -->
    <dependencyManagement>
        <dependencies>
            <!-- Spring Boot BOM：管理所有 spring-boot-starter-* 的版本 -->
            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-dependencies</artifactId>
                <version>${spring-boot.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>

            <!-- Spring Cloud BOM：管理 eureka, feign, gateway, config 等组件的版本 -->
            <dependency>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-dependencies</artifactId>
                <version>${spring-cloud.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>

    <dependencies>
        <!-- 无需写 version！版本由 BOM 自动管理 -->

        <!-- Spring Boot Web Starter -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>

        <!-- Spring Cloud OpenFeign（声明式服务调用） -->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-openfeign</artifactId>
        </dependency>

        <!-- Spring Cloud LoadBalancer（替代 Ribbon） -->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-loadbalancer</artifactId>
        </dependency>

        <!-- 可选：Nacos 服务发现（若使用 Alibaba 生态） -->
        <!--
        <dependency>
            <groupId>com.alibaba.cloud</groupId>
            <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
        </dependency>
        -->

        <!-- 测试依赖 -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <version>${spring-boot.version}</version>
            </plugin>
        </plugins>
    </build>

</project>
```

| 部分                                         | 说明                                                         |
| :------------------------------------------- | :----------------------------------------------------------- |
| `<dependencyManagement>`                     | **只声明版本，不引入依赖**                                   |
| `spring-boot-dependencies`                   | Spring Boot 官方 BOM，管理所有 `spring-boot-starter-*` 的版本 |
| `spring-cloud-dependencies`                  | Spring Cloud 官方 BOM，确保 Feign、Gateway、Config 等组件与 Boot 版本兼容 |
| `<scope>import</scope>` + `<type>pom</type>` | **专门用于导入 BOM**，Maven 会将其 `<dependencyManagement>` 内容合并到当前项目 |
| 子依赖无 `<version>`                         | 自动使用 BOM 中定义的版本，**避免冲突和不兼容**              |

与SpringBoot的版本对应关系：[Spring Cloud](https://spring.io/projects/spring-cloud?spm=5176.28103460.0.0.3d9e6308zyWKJB#overview)

> 如果是用Alibaba：
>
> ```xml
> <dependency>
>     <groupId>com.alibaba.cloud</groupId>
>     <artifactId>spring-cloud-alibaba-dependencies</artifactId>
>     <version>2022.0.0.0</version>
>     <type>pom</type>
>     <scope>import</scope>
> </dependency>
> ```
>
> [版本发布说明-阿里云Spring Cloud Alibaba官网](https://sca.aliyun.com/docs/2023/overview/version-explain/?spm=7145af80.1ef41eac.0.0.1fa12d5b2cuDcH)







### 服务拆分原则

#### 试错创业类项目

先采用单体项目的架构，快速开发明确业务流程以及二次技术工具等选定，随项目发展逐步完成拆分。

#### 已确定的大型项目

确定该项目的需求量很大，存在高强度的高并发场景，那么我们就需要直接开始微服务的搭建了。

#### 拆分要求

**高内聚**：模块内功能完整，关联性强

**低耦合**：模块间功能独立，对其他模块的依赖尽量少

#### 拆分方向

**纵向拆分**：按照业务模块拆分

**横向拆分**：提取公共部分，提高复用

#### 拆分方式

在工程中，我们拆分一个项目时可以将一部分服务拆分出来，然后使用父项目管理所有的子服务完成依赖管理等，这就是maven聚合：

**Maven 聚合**（Aggregation）是 Maven 提供的一种项目管理机制，用于将多个子模块（子项目）组织在一个父项目下，通过一次构建命令（如 `mvn clean install`）就可以依次构建所有子模块。这种机制特别适用于多模块（multi-module）项目。

- **统一构建**：只需在聚合项目的根目录执行 Maven 命令，即可按依赖顺序自动构建所有子模块。
- **简化管理**：避免逐个进入子模块目录手动构建。
- **保持结构清晰**：逻辑上将相关模块归为一个整体工程。









----

### EX：使用构造器注入

**1.  字段是 `private final`** 

**2.  类中存在一个** **包含这些 `final` 字段的构造函数**（且该构造函数是唯一的，或被 `@Autowired` 标记）

而这个构造函数，通常由 **Lombok 的 `@RequiredArgsConstructor` 或 `@AllArgsConstructor` 自动生成**。

```java
@Service
@RequiredArgsConstructor // 自动生成包含所有 final 字段的构造函数
public class UserService {
    private final UserRepository userRepository;
}
```

> **为什么说字段注入不推荐了？**
>
> 虽然能工作，但：
>
> - 字段可变，可能被意外修改
> - 无法保证非空（除非加 `@NonNull`）
> - 不利于单元测试
> - 掩盖真实依赖（但可以用`@Qualifier`来指定实现类）
> - 掩盖循环依赖的问题
> - Spring 官方已**不推荐字段注入**
>
> 而构造器注入可以在项目启动时就报错，实时展现出项目中存在的问题。



### EX：使用Swagger4j调试

默认地址：http://localhost:ip/doc.html#/home

注意yml配置中Controller扫描路径



### EX：依赖管理pom中的参数

`<type>`：指定依赖的**打包类型（packaging type）**。Maven 默认的依赖类型是 `jar`，但有些依赖可能是 `war`、`pom`、`ear`、`test-jar` 等。

| 类型       | 说明                                                         |
| :--------- | :----------------------------------------------------------- |
| `jar`      | 默认值，普通 Java 库                                         |
| `pom`      | 表示该依赖是一个 BOM（Bill of Materials），常用于导入一组版本管理（如 Spring Boot） |
| `war`      | Web 应用打包                                                 |
| `test-jar` | 包含测试代码的 JAR（需配合插件生成）                         |

```xml
<dependencyManagement>
  <dependencies>
    <!-- 导入 Spring Boot 的依赖管理 -->
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-dependencies</artifactId>
      <version>3.2.0</version>
      <type>pom</type>
      <scope>import</scope>
    </dependency>
  </dependencies>
</dependencyManagement>
```



 `scope`：定义依赖在项目生命周期中的**使用范围**（编译、测试、运行等阶段是否生效）。

| Scope      | 说明                                                         |
| :--------- | :----------------------------------------------------------- |
| `compile`  | 默认值，编译、测试、运行都有效                               |
| `test`     | 仅测试时有效（如 JUnit）                                     |
| `runtime`  | 测试和运行时有效，编译时不需要（如 JDBC 驱动）               |
| `provided` | 编译和测试有效，但运行时由 JDK 或容器提供（如 Servlet API）  |
| `system`   | 类似 `provided`，但需显式指定本地路径（不推荐）              |
| `import`   | **仅用于 `dependencyManagement` 中**，用于导入其他 POM 的 `<dependencyManagement>` 内容 |

```xml
<dependencyManagement>
  <dependencies>
    <dependency>
      <groupId>com.example</groupId>
      <artifactId>my-bom</artifactId>
      <version>1.0.0</version>
      <type>pom</type>
      <scope>import</scope>
    </dependency>
  </dependencies>
</dependencyManagement>
```



### EX：为什么一定要将Service拆分到不同实例中

直接本地调用其他Service的相关方法不行吗？

**根本原因：微服务的本质不是“技术”，而是“解耦”**

 **✅ 微服务的真正目标：**

- **团队自治**：订单团队只关心订单模块，无需协调用户团队
- **独立部署**：修复订单 bug 不需要重新部署整个系统
- **技术异构**：用户服务可用 Go，订单服务用 Java
- **弹性伸缩**：大促时只扩容订单服务，不浪费资源
- **故障隔离**：用户服务宕机，不影响支付流程（降级处理）

> ❌ 如果所有 Service 都在一个 JVM 里，这些优势全部消失！

**具体问题分析：为什么“本地调用”不可行？**

 **1.违背微服务边界（Domain Boundary）**

- 微服务应围绕**业务能力**划分（如订单、用户、库存）

- 如果 `OrderService`直接 `new UserService()` 或 `@Autowired UserService`：

  - 两个服务的代码强耦合
  - 修改 `UserService` 可能意外破坏 `OrderService`
  - 无法独立测试、独立发布

> 📌 **微服务间只能通过“契约”（API）交互，不能共享内存或类**

------

 **2.丧失独立部署能力**

假设你有一个单体应用包含：

```java
// 同一个 JAR 包内
class OrderService { ... }
class UserService { ... }
```

- 修复 `UserService` 的一个 bug → 必须重新打包、测试、部署整个应用
- 订单团队想上线新功能 → 被用户团队的测试进度阻塞

✅ **微服务理想状态**：

- 用户服务 v2.1 上线 → 只需部署 `user-service` 实例
- 订单服务继续运行 v1.8，完全不受影响

------

 **3.无法弹性伸缩**

- 大促时订单请求暴增 10 倍，但用户登录量不变
- 如果服务在一起：
  - 你只能整体扩容 10 倍 → **浪费 90% 的用户服务资源**
- 如果服务分离：
  - 只扩容 `order-service` 实例 → **成本最优**

------

 **4.故障会扩散（无隔离性）**

- 在单体中：`UserService` 出现 OOM → 整个 JVM 崩溃 → 订单也无法使用
- 在微服务中：
  - `user-service` 宕机
  - `order-service` 可通过 **熔断降级** 返回兜底数据（如“游客模式”）
  - 核心链路（下单）仍可用

> 🔥 **微服务的核心原则之一：故障隔离（Failure Isolation）**

------

 **5.技术栈被锁定**

- 所有服务必须用同一语言（Java）、同一框架（Spring Boot）、同一 JDK 版本
- 无法引入更适合特定场景的技术：
  - 实时计算 → Flink
  - AI 推荐 → Python + TensorFlow
  - 高并发网关 → Go

----

**✅ 关于 Feign 的误解澄清：**

- **Feign 不是为了“模拟本地调用”，而是为了“简化远程调用”**
- 它底层仍是 HTTP + JSON（或 gRPC），**必然有网络开销**
- 但这种开销是**值得付出的代价**，换来的是架构灵活性

 **⚡ 性能优化手段（弥补网络损耗）：**

| 问题       | 解决方案                       |
| :--------- | :----------------------------- |
| 网络延迟   | 同机房部署、gRPC 替代 HTTP     |
| 序列化开销 | 使用 Protobuf、Kryo            |
| 连接建立   | OkHttp 连接池（复用 TCP）      |
| 高频调用   | 本地缓存（Caffeine）、批量接口 |

> 💡 **经验法则**：
> 90% 的微服务调用延迟 < 10ms（同机房），对用户体验无感。
> 架构收益 >> 性能损耗。
