---
title: 服务管理
date: 2026-2-1
---

## 注册中心

微服务架构中，**注册中心（Service Registry）** 是一个核心组件，用于实现服务的**自动注册与发现**。它的基本原理可以概括为：**服务提供者在启动时向注册中心注册自身信息，服务消费者通过注册中心查询并调用所需服务**。

下面从几个关键方面详细讲解注册中心的原理：

------

### 1. **核心功能**

注册中心主要有以下三大功能：

- **服务注册（Registration）**
  微服务实例启动后，将自己的元数据（如服务名、IP地址、端口、健康状态、版本号等）上报到注册中心。
- **服务发现（Discovery）**
  消费者需要调用某个服务时，向注册中心查询该服务当前可用的实例列表，然后选择一个（或多个）进行调用。
- **健康检查（Health Check）**
  注册中心会定期检测已注册服务的健康状态，剔除不可用的实例，确保服务列表的实时性和可靠性。

------

### 2. **工作流程**

以一次典型的调用为例：

1. **服务提供者 A 启动** → 向注册中心注册自己（如 `order-service: 192.168.1.10:8080`）。
2. **服务消费者 B 启动** → 从注册中心拉取 `order-service` 的可用实例列表。
3. **B 调用 A** → 根据负载均衡策略（如轮询、随机、权重等）选择一个实例发起请求。
4. **A 下线或宕机** → 注册中心通过心跳机制或主动探测发现异常，将其从服务列表中移除。
5. **B 下次调用时** → 不再使用已下线的实例，保证调用成功率。

------

### 3. **实现机制**

#### （1）心跳机制（Heartbeat）

- 服务实例定期（如每5秒）向注册中心发送心跳，表明自己“还活着”。
- 如果注册中心在一定时间内（如15秒）未收到心跳，则认为该实例失效，将其剔除。

#### （2）服务列表缓存

- 为提高性能和降低对注册中心的依赖，客户端通常会**本地缓存服务列表**。
- 注册中心支持**推送变更**（如通过长连接、WebSocket）或客户端**定时拉取更新**。

#### （3）一致性模型

- 有些注册中心（如 Eureka）采用 **AP 模型**（高可用、最终一致），适合云环境。
- 有些（如 ZooKeeper、etcd）采用 **CP 模型**（强一致），适合对一致性要求高的场景。

------

### 4. **常见注册中心对比**

| 注册中心      | 一致性模型   | 健康检查方式       | 特点                                |
| ------------- | ------------ | ------------------ | ----------------------------------- |
| **Eureka**    | AP           | 客户端心跳         | Netflix 开源，Spring Cloud 默认集成 |
| **Consul**    | CP（可配）   | 主动探测 + 心跳    | 支持多数据中心、内置 UI             |
| **ZooKeeper** | CP           | 临时节点 + Session | 强一致，但对网络分区敏感            |
| **Nacos**     | AP/CP 可切换 | 心跳 + 主动探测    | 阿里开源，支持配置中心 + 服务发现   |

------

### 5. **为什么需要注册中心？**

在单体架构中，服务调用是固定的；但在微服务中：

- 服务实例动态扩缩容；
- IP 和端口不固定；
- 需要负载均衡和故障转移。

注册中心解耦了服务提供者和消费者，使系统具备**弹性、可扩展性和自愈能力**。

------



## Nacos

### 服务器搭建与配置

Nacos不仅支持注册中心，同时还配备了配置中心的功能，我们现在来通过docker部署一下：

首先准备nacos的数据源，可以是mysql：

[nacos配置mysql数据库 | Nacos 官网](https://nacos.io/blog/faq/nacos-user-question-history11838/)

获取镜像：

```bash
docker pull nacos/nacos-server
```

> 注意版本！server和client的版本也需要一定对应关系！
>
> 如果下载过慢也可以直接去下载tar包然后`docker load`：
>
> ```bash
> docker load -i nacos.tar
> ```

同时我们还需要完成nacos的配置：

```env
PREFER_HOST_MODE=hostname
MODE=standalone
SPRING_DATASOURCE_PLATFORM=mysql
MYSQL_SERVICE_HOST=192.168.0.200
MYSQL_SERVICE_DB_NAME=nacos
MYSQL_SERVICE_PORT=3306
MYSQL_SERVICE_USER=root
MYSQL_SERVICE_PASSWORD=123
MYSQL_SERVICE_DB_PARAM=characterEncoding=utf8&connectTimeout=1000&socketTimeout=3000&autoReconnect=true&useSSL=false&allowPublicKeyRetrieval=true&serverTimezone=Asia/Shanghai
```

将这个文件挂载到我们生成的容器中去：

```bash
docker run -d \
--name nacos \
--env-file ./nacos/custom.env \
-p 8848:8848 \
-p 9848:9848 \
-p 9849:9849 \
--restart=always \
nacos/nacos-server:v2.1.0-slim
```

完成之后我们就可以访问nacos的可视化页面了：http://192.168.0.200:8848/nacos/#/login



### 客户端搭建与配置

首先引入依赖：

```xml
<!--nacos 服务注册发现-->
<dependency>
    <groupId>com.alibaba.cloud</groupId>
    <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
</dependency>
```

然后完成yml配置：

```yml
spring:
  application:
    name: item-service # 服务名称
  cloud:
    nacos:
      server-addr: 192.168.0.200:8848 # nacos地址
```

现在我们启动项目就可以在nacos中发现该项目了。

> 注意不同版本的配置写法可能会有所不同！

在引入了发现中心之后，接入发现中心的服务不仅可以被其他接入nacos的服务发现并调用，也可以去发现其他接入nacos的服务并调用他们：

```java
private final DiscoveryClient discoveryClient; // lombok @RequiredArgsConstructor构造器注入

...

// 2.1 获取商品服务实例
List<ServiceInstance> instances = discoveryClient.getInstances("item-service");
// 2.2 随机获取一个
ServiceInstance instance = instances.get(RandomUtil.randomInt(0, instances.size()));
// 2.3 通过发Request获取商品信息
String url = "http://" + instance.getHost() + ":" + instance.getPort() + "/item/queryItemByIds";
```

当然这个负载均衡方式和拿ip去手动发Request还是有点疯狂原始人了，我们其实可以使用更加好的方式来完成服务之间的相互调用：`Openfeign`提供了一套和Cloud高度契合的模式来完成对于其他服务的调用。

