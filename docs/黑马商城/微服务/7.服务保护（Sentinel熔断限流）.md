---
title: 服务保护
date: 2026-2-8
---

## 服务雪崩

服务雪崩（Service Avalanche / Cascading Failure）是**微服务架构中最危险的系统性故障之一**：

> **一个服务的局部故障，通过调用链逐级放大，最终导致整个系统瘫痪。**

### **1️⃣服务依赖 + 同步阻塞调用**

- 微服务 A → 调用 B → 调用 C
- 所有调用都是 **同步 HTTP/RPC**（线程阻塞等待）

### **2️⃣资源耗尽（线程/连接池）**

- 当 C 服务变慢或宕机 → B 的请求线程被长时间占用
- B 的线程池迅速耗尽 → B 无法处理新请求（即使 B 自身没问题）
- A 调用 B 也开始超时 → A 的线程池也耗尽
- **故障从 C 传导到 B 再到 A**

### **3️⃣重试风暴（Retry Storm）**

- 客户端发现调用失败 → 自动重试（如 Feign 默认重试）
- 重试请求进一步加剧下游压力 → 故障加速扩散

### 解决方案

| 能力                                      | 作用                         | 类比           |
| :---------------------------------------- | :--------------------------- | :------------- |
| ✅ **流量控制（Flow Control）**            | 限制 QPS/线程数，防过载      | “水龙头限流”   |
| ✅ **熔断降级（Circuit Breaking）**        | 故障自动隔离，快速失败       | “保险丝熔断”   |
| ✅ **系统自适应保护（System Protection）** | 全局负载保护（CPU/LOAD/RT）  | “系统级安全阀” |
| ✅ **热点参数限流（Param Flow Control）**  | 对特定参数值限流（如用户ID） | “精准打击”     |



## Sentinel

Sentinel 是阿里巴巴开源的**面向分布式服务架构的流量治理组件**，专注于 **高可用防护**，核心目标是：

> **在大流量冲击或依赖故障时，保障系统稳定，防止雪崩。**

它不只做限流，而是提供了一套完整的 **“流量防护 + 熔断降级 + 系统自适应保护”** 体系。

说明文档：[basic-api-resource-rule | Sentinel](https://sentinelguard.io/zh-cn/docs/basic-api-resource-rule.html)

### 安装与配置

Sentinel 的使用可以分为两个部分:

- **核心库**（Jar包）：不依赖任何框架/库，能够运行于 Java 8 及以上的版本的运行时环境，同时对 Dubbo / Spring Cloud 等框架也有较好的支持。在项目中**引入依赖**即可实现服务限流、隔离、熔断等功能。
- **控制台**（Dashboard）：Dashboard 主要负责管理推送规则、监控、管理机器信息等。

其中控制台是一个单独的项目，其他微服务只需接入client并连接到Sentinel服务即可接入其所提供的各项功能，那么现在我们首先来完成控制台的搭建：

**控制台搭建**

首先下载运行jar包：[Releases · alibaba/Sentinel](https://github.com/alibaba/Sentinel/releases)

然后使用java运行：

```bash
java -Dserver.port=8090 -Dcsp.sentinel.dashboard.server=localhost:8090 -Dproject.name=sentinel-dashboard -jar sentinel-dashboard.jar
```

参数参考：[启动配置项 · alibaba/Sentinel Wiki](https://github.com/alibaba/Sentinel/wiki/启动配置项)

运行后访问http://localhost:8090页面，就可以看到sentinel的控制台了：

初始情况下账号密码都是sentinel

----

**引入依赖**

然后在自己的微服务项目中引入对应依赖：

```XML
<!--sentinel-->
<dependency>
    <groupId>com.alibaba.cloud</groupId> 
    <artifactId>spring-cloud-starter-alibaba-sentinel</artifactId>
</dependency>
```

> 版本已由父pom管理

----

**添加配置**

修改application.yaml文件，添加下面内容：

```YML
spring:
  cloud: 
    sentinel:
      transport:
        dashboard: localhost:8090
```

> 控制台服务ip端口根据自己的配置来，这里基本所有service服务都需要连接到Sentinel，考虑添加到nacos中，然后再在service服务中的bootstrap配置文件中指定这个配置文件。

> 所谓**簇点链路**，就是单机调用链路，是一次请求进入服务后经过的每一个被`Sentinel`监控的资源。默认情况下，`Sentinel`会监控`SpringMVC`的每一个`Endpoint`（接口）。
>
> 假如我们的SpringMVC接口是按照Restful风格设计，购物车的查询、删除、修改等接口全部都是`/carts`路径（**一般只会用用post以及get，路径url一般是绝对不会重复的，这里以防万一**）：
>
> 默认情况下Sentinel会把路径作为簇点资源的名称，无法区分路径相同但请求方式不同的接口，查询、删除、修改等都被识别为一个簇点资源，这显然是不合适的。
>
> 所以我们可以选择打开Sentinel的请求方式前缀，把`请求方式 + 请求路径`作为簇点资源名：
>
> 首先，在`cart-service`的`application.yml`中添加下面的配置：
>
> ```YAML
> spring:
>   cloud:
>     sentinel:
>       transport:
>         dashboard: localhost:8090
>       http-method-specify: true # 开启请求方式前缀
> ```



### 请求限流

实际上利用Sentinel实现限流并没有什么需要我们去实现的复杂操作，我们只需要保证**所有service服务都连接上了Sentinel的控制台服务**，然后我们就可以**在可视化的控制台界面里点点点填填填**，然后就可以实现流量控制了：

我们点开某一类微服务实例的簇点链路，点击**需要加上限流的路径**右侧的“流控”按钮，然后配置好流控阈值，如使用QPS类型限流，配置单实例QPS阈值为你所需要的阈值，随后就可以实现限流了，我们甚至还可以在高级选项里选择是**非阻塞的直接返回**还是**阻塞式的排队等待**。



### 线程隔离

除了我们刚刚使用的单机QPS限流，我们还可以限制针对**某一路径接口**的**单机同时工作**的**并发线程数量**，通过这种方式来降低单机压力以防止出现资源耗尽：某一接口的请求太多导致资源（线程等）被其占用过多，其他接口执行过慢甚至失败的情况，同时也对防止单机崩溃起到了一定作用。

在原本的单机配置当中，我们可以配置tomcat的线程池参数：

```YML
server:
  port: 8082
  tomcat:
    threads:
      max: 50 # 允许的最大线程数
    accept-count: 50 # 最大排队等待数量
    max-connections: 100 # 允许的最大连接
```

当线程池中线程被某一接口耗尽，其他的接口就无法工作了！

原生的SpringBoot单体项目可能就需要考虑异步自制线程池了，但是加入了Sentinel后，我们只需要再针对某一路径加上单机限流规则：限制该路径单机最大并发线程数即可实现线程隔离了！

> 这样的限制适用于一类服务中某一接口占用资源过多的情况，这时考虑对这个接口做线程隔离



### 请求降级Fallback

我们在先前的业务中**对于限流导致的失败处理**直接就是一个错误响应，通常情况下没有相应解释，这让调用方非常痛苦，我们需要对这个失败做一个优化处理。我们可以考虑在api模块优化一下openfeign的失败调用：

1. 在hm-api模块中给`ItemClient`定义降级处理类，实现`FallbackFactory`：

```java
@Slf4j
public class ItemClientFallback implements FallbackFactory<ItemClient> {
    @Override
    public ItemClient create(Throwable cause) {
        return new ItemClient() {
            @Override
            public List<ItemDTO> queryItemByIds(Collection<Long> ids) {
                log.error("远程调用ItemClient#queryItemByIds方法出现异常，参数：{}", ids, cause);
                // 查询购物车允许失败，查询失败，返回空集合
                return CollUtils.emptyList();
            }

            @Override
            public void deductStock(List<OrderDetailDTO> items) {
                // 库存扣减业务需要触发事务回滚，查询失败，抛出异常
                throw new BizIllegalException(cause);
            }
        };
    }
}
```

2. 在`hm-api`模块中的`com.hmall.api.config.DefaultFeignConfig`类中将`ItemClientFallback`注册为一个`Bean`：

```java
public class DefaultFeignClient {
    
    ......

    @Bean
    public ItemClientFallback itemClientFallback() {
        return new ItemClientFallback();
    }
}
```

3. 在`hm-api`模块中的`ItemClient`接口中使用`ItemClientFallback`：

```java
@FeignClient(name = "item-service" , fallbackFactory = ItemClientFallback.class)
public interface ItemClient {

    @GetMapping("/items")
    List<ItemDTO> queryItemByIds(@RequestParam("ids") Collection<Long> itemIds);

    @PutMapping("/items/stock/deduct")
    void deductStock(@RequestParam("details") List<OrderDetailDTO> details);
}
```



### 服务熔断

对于商品服务这种不太健康的接口，我们应该**停止调用**，**直接走降级逻辑**，避免影响到当前服务。也就是将商品查询接口**熔断**。当商品服务接口恢复正常后，再允许调用。这其实就是**断路器**的工作模式了。

Sentinel中的**断路器**不仅可以统计某个接口的**慢请求比例**，还可以统计**异常请求比例**。当这些比例**超出阈值**时，就会**熔断**该接口，即**拦截**访问该接口的**一切请求**，**降级处理**；当该接口恢复正常时，再放行对于该接口的请求。

断路器的工作状态切换有一个状态机来控制，其包括三个状态：

- **closed**：关闭状态，断路器放行所有请求，并开始统计异常比例、慢请求比例。超过阈值则切换到open状态
- **open**：打开状态，服务调用被**熔断**，访问被熔断服务的请求会被拒绝，快速失败，直接走降级逻辑。Open状态持续一段时间后会进入half-open状态
- **half-open**：半开状态，放行一次请求，根据执行结果来判断接下来的操作。 
  - 请求成功：则切换到closed状态
  - 请求失败：则切换到open状态

想要应用这样的熔断，我们只需要到Sentinel的可视化界面中点击需要设置熔断的路径（或路径前缀，即一类服务），点击右侧熔断配置，其中：

- **请求策略**：慢调用比例/异常比例/异常数（慢调用为过慢，异常为处理异常，以下为慢调用参数）
- **最大RT**：最大调用时长，超过此时长即视为慢调用
- **统计时长**：统计所设置时间的慢调用数量，若超过阈值则熔断
- **比例阈值**：超过所设置阈值比例则熔断
- **熔断时长**：发生熔断则停止相应服务的时长
- **最小请求数**：所设置时间内统计的最小请求数量

