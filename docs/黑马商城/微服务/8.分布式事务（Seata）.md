---
title: 分布式事务
date: 2026-2-10
---

分布式事务之所以“需要”，是因为在**现代分布式系统架构**（如微服务、云原生、多数据库部署）中，**单个业务操作往往涉及多个独立的数据存储或服务节点**。如果这些操作不能作为一个**整体成功或失败**，就会导致**数据不一致**，破坏业务的正确性和可靠性。

它要保证 **“分布式环境下的 ACID”**，尤其是：

- **原子性（Atomicity）**：所有参与方要么全部提交，要么全部回滚；
- **一致性（Consistency）**：系统从一个合法状态转移到另一个合法状态；
- （隔离性和持久性在分布式下较难完全保证，常做妥协）

| 方案                          | 原理                       | 适用场景                 | 特点                       |
| :---------------------------- | :------------------------- | :----------------------- | :------------------------- |
| **2PC（两阶段提交）**         | 协调者统一决策提交/回滚    | 强一致性要求高（如金融） | 性能差、阻塞、单点故障     |
| **TCC（Try-Confirm-Cancel）** | 业务层面实现补偿           | 高并发、可自定义补偿逻辑 | 开发复杂，但灵活高效       |
| **Saga 模式**                 | 一长串本地事务 + 补偿回滚  | 长流程业务（如订单履约） | 最终一致性，适合异步       |
| **消息队列（可靠消息）**      | 通过 MQ 保证操作最终执行   | 异步解耦场景（如发通知） | 最终一致性，简单易用       |
| **Seata（AT模式）**           | 自动记录 undo log 实现回滚 | Spring Cloud 微服务      | 对业务侵入小，但性能有损耗 |

> ✅ 实际系统中，**很少追求强一致性**，更多采用 **“最终一致性” + 补偿机制** 来平衡可用性与一致性（符合 CAP 定理）。



## Seata

Seata（**Simple Extensible Autonomous Transaction Architecture**）是阿里巴巴开源的一款 **高性能、易用的分布式事务解决方案**，现已成为 Apache 软件基金会的顶级项目（孵化中），广泛应用于微服务架构下的数据一致性保障场景。

Seata 采用 **中心协调 + 分布式代理** 架构，包含三个关键组件：

| 角色   | 全称                                  | 作用                                                         |
| :----- | :------------------------------------ | :----------------------------------------------------------- |
| **TC** | Transaction Coordinator（事务协调器） | 全局事务的**管理者**，负责全局事务的 begin/commit/rollback 决策，并协调各分支事务。 |
| **TM** | Transaction Manager（事务管理器）     | 全局事务的**发起者和终结者**，通常位于主业务服务中，通过 `@GlobalTransactional` 注解开启全局事务。 |
| **RM** | Resource Manager（资源管理器）        | 分支事务的**参与者**，嵌入在各个微服务中，负责向 TC 注册分支事务，并上报本地事务状态。 |

Seata 支持的几种主要事务模式：

| 事务模式 | 全称 / 类型                  | 侵入性                              | 一致性               | 性能                          | 隔离性           | 适用场景                         | 核心机制                    |
| -------- | ---------------------------- | ----------------------------------- | -------------------- | ----------------------------- | ---------------- | -------------------------------- | --------------------------- |
| AT       | Auto Transaction（自动事务） | ⭐ 低（仅需注解 + undo_log 表）      | 最终一致（支持回滚） | ⭐⭐⭐ 高（本地提交快）          | 弱（依赖全局锁） | 普通业务（如订单+库存）          | 自动生成 undo log，自动回滚 |
| TCC      | Try-Confirm-Cancel           | ⭐⭐⭐ 高（需手写 try/confirm/cancel） | 强一致               | ⭐⭐⭐⭐ 很高（无数据库回滚开销） | 强（由业务控制） | 高并发、资金类（如支付、转账）   | 业务级资源预留与确认        |
| Saga     | Long-running Transaction     | ⭐⭐ 中（需写补偿方法）               | 最终一致             | ⭐⭐⭐ 高（异步执行）            | 无（可能脏读）   | 长流程、异步任务（如审批、履约） | 正向执行 + 反向补偿         |
| XA       | XA Protocol（标准 2PC）      | ⭐ 低（数据库原生支持）              | 强一致               | ⭐ 低（全程锁定资源）          | 强               | 传统金融系统（兼容老架构）       | 数据库层两阶段提交          |



## 部署TC服务

我们可以简单理解**TC服务**为seata的**单独服务**用于**处理所有的全局事务的server**，TM以及RM为seata的**client**，作为依赖在service模块中部署，当发生调用的时候就会将信息传输到TC这个**server**中。那么作为额外的服务，TC需要我们去**单独部署**：

首先和配置nacos一样，我们需要为他准备一个数据库：

```sql
-- 脚本位置：seata/script/server/db/mysql.sql
CREATE DATABASE seata;
USE seata;
-- 执行 mysql.sql 中的建表语句（global_table, branch_table, lock_table）
```

> 参考：[快速开始-阿里云Spring Cloud Alibaba官网](https://sca.aliyun.com/docs/2023/user-guide/seata/quick-start/)

然后准备好配置文件application.yml：

```yml
server:
  port: 7099

spring:
  application:
    name: seata-server

logging:
  config: classpath:logback-spring.xml
  file:
    path: ${user.home}/logs/seata
  # extend:
  #   logstash-appender:
  #     destination: 127.0.0.1:4560
  #   kafka-appender:
  #     bootstrap-servers: 127.0.0.1:9092
  #     topic: logback_to_logstash

console:
  user:
    username: admin
    password: admin

seata:
  config:
    # support: nacos, consul, apollo, zk, etcd3
    type: file
    # nacos:
    #   server-addr: nacos:8848
    #   group : "DEFAULT_GROUP"
    #   namespace: ""
    #   dataId: "seataServer.properties"
    #   username: "nacos"
    #   password: "nacos"
  registry:
    # support: nacos, eureka, redis, zk, consul, etcd3, sofa
    type: nacos
    nacos:
      application: seata-server
      server-addr: nacos:8848
      group : "DEFAULT_GROUP"
      namespace: ""
      username: "nacos"
      password: "nacos"
#  server:
#    service-port: 8091 #If not configured, the default is '${server.port} + 1000'
  security:
    secretKey: SeataSecretKey0c382ef121d778043159209298fd40bf3850a017
    tokenValidityInMilliseconds: 1800000
    ignore:
      urls: /,/**/*.css,/**/*.js,/**/*.html,/**/*.map,/**/*.svg,/**/*.png,/**/*.ico,/console-fe/public/**,/api/v1/auth/login
  server:
    # service-port: 8091 #If not configured, the default is '${server.port} + 1000'
    max-commit-retry-timeout: -1
    max-rollback-retry-timeout: -1
    rollback-retry-timeout-unlock-enable: false
    enable-check-auth: true
    enable-parallel-request-handle: true
    retry-dead-threshold: 130000
    xaer-nota-retry-timeout: 60000
    enableParallelRequestHandle: true
    recovery:
      committing-retry-period: 1000
      async-committing-retry-period: 1000
      rollbacking-retry-period: 1000
      timeout-retry-period: 1000
    undo:
      log-save-days: 7
      log-delete-period: 86400000
    session:
      branch-async-queue-size: 5000 #branch async remove queue size
      enable-branch-async-remove: false #enable to asynchronous remove branchSession
  store:
    # support: file 、 db 、 redis
    mode: db
    session:
      mode: db
    lock:
      mode: db
    db:
      datasource: druid
      db-type: mysql
      driver-class-name: com.mysql.cj.jdbc.Driver
      url: jdbc:mysql://mysql:3306/seata?rewriteBatchedStatements=true&serverTimezone=UTC
      user: root
      password: 123
      min-conn: 10
      max-conn: 100
      global-table: global_table
      branch-table: branch_table
      lock-table: lock_table
      distributed-lock-table: distributed_lock
      query-limit: 1000
      max-wait: 5000
    # redis:
    #   mode: single
    #   database: 0
    #   min-conn: 10
    #   max-conn: 100
    #   password:
    #   max-total: 100
    #   query-limit: 1000
    #   single:
    #     host: 192.168.150.101
    #     port: 6379
  metrics:
    enabled: false
    registry-type: compact
    exporter-list: prometheus
    exporter-prometheus-port: 9898
  transport:
    rpc-tc-request-timeout: 15000
    enable-tc-server-batch-send-response: false
    shutdown:
      wait: 3
    thread-factory:
      boss-thread-prefix: NettyBoss
      worker-thread-prefix: NettyServerNIOWorker
      boss-thread-size: 1

```

> 注意这里对于nacos以及mysql的ip直接使用名称就行的原因是他们都被部署到了docker中，而且共享一个网桥，所以可以直接使用docker容器名称，如非docker部署需要指明ip端口

然后准备一个seata的docker镜像：[Docker部署 | Apache Seata](https://seata.apache.org/zh-cn/docs/ops/deploy-by-docker/)（或者网络可以直连docker直接运行命令）

```bash
docker run --name seata \
-p 8099:8099 \
-p 7099:7099 \
-e SEATA_IP=192.168.0.200 \
-v ./seata:/seata-server/resources \
--privileged=true \
--network hm-net \
-d \
seataio/seata-server:1.5.2 
```

> 运行失败检查nacos，mysql网桥是否为所设置的那个：
>
> ```bash
> docker network ls
> ```
>
> ```bash
> docker inspect [容器名]
> ```
>
> inspect的最后一项network查看所在网络区间
>
> 注意mysql以及nacos必须在seata同一网桥（hm-net）中，假如不在这个网桥中，就需要手动添加：
>
> ```bash
> docker network connect [网络名] [容器名]
> ```

成功连接我们就可以在nacos中看到连接实例了，访问seata：http://192.168.0.200:7099/



## 微服务调用seata

### 引入依赖

```XML
<!--统一配置管理-->
  <dependency>
      <groupId>com.alibaba.cloud</groupId>
      <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>
  </dependency>
  <!--读取bootstrap文件-->
  <dependency>
      <groupId>org.springframework.cloud</groupId>
      <artifactId>spring-cloud-starter-bootstrap</artifactId>
  </dependency>
  <!--seata-->
  <dependency>
      <groupId>com.alibaba.cloud</groupId>
      <artifactId>spring-cloud-starter-alibaba-seata</artifactId>
  </dependency>
```

> 父项目pom已做好依赖管理



### 修改配置

准备一个yml配置文件：

```yml
seata:
  registry: # TC服务注册中心的配置，微服务根据这些信息去注册中心获取tc服务地址
    type: nacos # 注册中心类型 nacos
    nacos:
      server-addr: 192.168.0.200:8848 # nacos地址
      namespace: "" # namespace，默认为空
      group: DEFAULT_GROUP # 分组，默认是DEFAULT_GROUP
      application: seata-server # seata服务名称
      username: nacos
      password: nacos
  tx-service-group: hmall # 事务组名称
  service:
    vgroup-mapping: # 事务组与tc集群的映射关系
      hmall: "default"
```

这里因为基本所有的service服务都需要连接到seata，所以我们可以考虑将这个yml放到nacos中，service服务直接在bootstrap中引入指定配置文件。

```yml
spring:
  application:
    name: cart-service # 服务名称
  profiles:
    active: dev
  cloud:
    nacos:
      server-addr: 192.168.0.200:8848 # nacos地址
      config:
        file-extension: yaml # 文件后缀名
        shared-configs: # 共享配置
          - dataId: shared-jdbc.yml # 共享mybatis配置
          - dataId: shared-log.yml # 共享日志配置
          - dataId: shared-swagger.yml # 共享日志配置
          - dataId: shared-seata.yml # seata配置
```

并配置好application文件：

```yml
server:
  port: 8082
feign:
  okhttp:
    enabled: true # 开启OKHttp连接池支持
hm:
  swagger:
    title: 购物车服务接口文档
    package: com.hmall.cart.controller
  db:
    database: hm-cart

spring:
  cloud:
    sentinel:
      transport:
        dashboard: localhost:8090
```

然后就可以启动服务连接到seata的TC服务了，接下来我们就可以使用`@GlobalTransactional`来接入分布式事务了。



## XA模式

XA 模式是 Seata 提供的一种**基于数据库原生 XA 协议的分布式事务解决方案**，它实现了经典的 **两阶段提交（2PC, Two-Phase Commit）**，能够提供**强一致性**保证。虽然在现代高并发微服务架构中使用较少（因性能和锁竞争问题），但在**对数据一致性要求极高的传统金融、支付等场景**中仍有重要价值。

实际就是**多个事务共进退**，TM为发起的事务，RM为所涉及到的事务，一回滚则全部回滚。

> ✅ XA 协议的核心：**让多个数据库像一个数据库一样支持 ACID 事务**。

Seata 的 XA 模式**直接利用数据库自身的 XA 能力**，不依赖 undo log 或业务补偿，流程如下：

### 流程概要（2PC）

 **第一阶段：Prepare（准备）**

1. TM（主服务）向 TC 发起全局事务；
2. 各 RM（微服务）执行本地 SQL，并调用数据库的 `XA START` / `XA END` / `XA PREPARE`；
3. 数据库将事务日志写入 redo/undo 日志，**但不提交**，进入“prepared”状态；
4. RM 向 TC 报告 prepare 成功。

 **第二阶段：Commit / Rollback（提交或回滚）**

- **如果所有 RM prepare 成功** → TC 发送 `XA COMMIT` → 各数据库真正提交；
- **任一 RM prepare 失败** → TC 发送 `XA ROLLBACK` → 各数据库回滚。

> ⚠️ 注意：在 Seata XA 模式中，**TM 直接与数据库交互**（通过 JDBC XADataSource），TC 只负责协调决策。



### 对比AT模式

| 特性           | XA 模式                                       | AT 模式                      |
| :------------- | :-------------------------------------------- | :--------------------------- |
| **一致性**     | ✅ 强一致（ACID）                              | 最终一致（可能短暂不一致）   |
| **隔离性**     | ✅ 强（数据库级锁）                            | 弱（需全局锁防脏写）         |
| **性能**       | ❌ 低（全程持有 DB 锁，阻塞时间长）            | ✅ 高（第一阶段就释放本地锁） |
| **侵入性**     | 低（只需配置 XA 数据源）                      | 低（需 undo_log 表）         |
| **数据库支持** | 需数据库支持 XA（MySQL 5.7+、Oracle、DB2 等） | 仅需普通 JDBC + 主键         |
| **适用场景**   | 金融核心系统、强一致性要求                    | 普通电商、互联网业务         |



### 配置与使用

**配置：**

在完成了seata的配置与部署后，我们只需要在yml配置文件中指定模式：

```yml
seata:
  data-source-proxy-mode: XA
```

即可完成对XA模式的指定

> 注意相关服务都需要指定模式为XA，所以还是推荐将配置放到nacos中统一配置

**使用：**

想要使用XA模式也很简单，我们只需要在**全局事务的入口service方法**注明注解`@GlobalTransactional`：

```java
@Override
@GlobalTransactional
public Long createOrder(OrderFormDTO orderFormDTO) {
    ...
}
```

然后保证**所涉及的所有service方法**都有`@Transactional`保证事务记录存在即可完成全局事务的使用。

那么现在当我们在全局事务中的任意一个事务（全局事务发起者TM/分支事务RM）发生了错误，抛出了异常时，所有的事务都会进行回滚。



## AT模式

Seata 的 **AT 模式（Auto Transaction Mode）** 是其最常用、对业务侵入性最低的分布式事务解决方案。它通过**自动拦截和解析 SQL**，在不修改业务代码的前提下，实现**分布式场景下的自动回滚与提交**，让开发者“像使用本地事务一样”处理跨服务数据一致性。

AT 模式将传统 2PC 的**同步阻塞**优化为：

- **第一阶段**：本地事务直接提交（高性能）；
- **第二阶段**：仅在需要回滚时，通过 **undo log** 执行反向 SQL。

> ✅ 目标：**在保证最终一致性的前提下，最大化系统吞吐量**。



### 流程概要

 **1.第一阶段：本地提交 + 生成 undo log**

当执行一条 SQL（如 `UPDATE account SET balance = balance - 100 WHERE id = 1`）时，Seata 的 JDBC 代理会：

 **（1）解析 SQL，生成before image和after image**

- **before image**：执行前的数据快照（`id=1, balance=500`）
- **after image**：执行后的数据快照（`id=1, balance=400`）

 **（2）将 undo log 写入业务数据库的** `undo_log` **表**

```sql
INSERT INTO undo_log (branch_id, xid, context, rollback_info, log_status)
VALUES (
  'branch-123',
  'xid-abc',
  '{"serializer":"jackson"}',
  '{
    "tableName": "account",
    "beforeImage": {"rows": [{"fields": [{"name":"id","value":1}, {"name":"balance","value":500}]}]},
    "afterImage":  {"rows": [{"fields": [{"name":"id","value":1}, {"name":"balance","value":400}]}]}
  }',
  0
);
```

 **（3）本地事务提交（业务数据 + undo_log 原子提交）**

> ✅ 优点：**第一阶段就释放数据库行锁**，避免长时间持有锁导致性能瓶颈。

------

 **2.第二阶段：提交 or 回滚**

 **✅ 全局提交（Commit）**

- TC 通知各 RM **异步删除对应的 undo_log**；
- 无额外数据库操作，**性能极高**。

 **❌ 全局回滚（Rollback）**

- TC 通知 RM 执行回滚；

- RM 读取 `undo_log` 中的 **before image**；

- 构造反向 SQL 并执行：

  ```sql
  UPDATE account SET balance = 500 WHERE id = 1;
  ```

- 验证 **after image 是否匹配当前数据**（防止脏写），若不匹配则回滚失败（需人工介入）。

> 🔒 **全局锁机制**：在第一阶段注册分支事务时，Seata 会向 TC 申请**全局行锁**（如 `account:1`），防止其他全局事务并发修改同一行，避免回滚时数据不一致。



### 使用要求

| 要求                          | 说明                                                         |
| :---------------------------- | :----------------------------------------------------------- |
| **1. 业务表必须有主键**       | Seata 通过主键定位行进行回滚                                 |
| **2. 必须创建 `undo_log` 表** | 每个参与 AT 事务的数据库都要有                               |
| **3. SQL 需满足限制**         | 不支持： - 无 WHERE 的 UPDATE/DELETE - 多表 JOIN 更新 - `INSERT INTO ... SELECT` - 子查询等复杂语句 |
| **4. 使用 Seata 数据源代理**  | Spring Boot 中自动集成，无需手动包装                         |



### 对比XA模式

| 维度             | **XA 模式**                                    | **AT 模式**                            |
| :--------------- | :--------------------------------------------- | :------------------------------------- |
| **一致性级别**   | ✅ **强一致**（事务结束即一致）                 | ⚠️ **最终一致**（回滚时可能短暂不一致） |
| **锁持有时间**   | 🔒 **全程持有 DB 行锁**（直到 commit/rollback） | 🔓 **第一阶段结束后立即释放本地锁**     |
| **提交模型**     | 标准 **同步两阶段提交（2PC）**                 | **一阶段提交 + 二阶段异步回滚**        |
| **性能**         | ❌ 低（高并发下易阻塞、死锁）                   | ✅ 高（本地快速提交，无长时间锁）       |
| **实现依赖**     | 依赖数据库原生 **XA 协议支持**                 | 依赖 Seata **SQL 解析 + undo log**     |
| **数据回滚方式** | 数据库原生 XA ROLLBACK                         | Seata 构造反向 SQL 执行回滚            |
| **隔离性**       | ✅ 强（由数据库保证）                           | ⚠️ 弱（需 Seata 全局锁防脏写）          |
| **典型场景**     | 银行转账、金融核心系统                         | 电商下单、普通微服务                   |



### 配置与使用

首先需要在数据库中准备好一张undolog表：

```sql
-- for AT mode you must to init this sql for you business database. the seata server not need it.
CREATE TABLE IF NOT EXISTS `undo_log`
(
    `branch_id`     BIGINT       NOT NULL COMMENT 'branch transaction id',
    `xid`           VARCHAR(128) NOT NULL COMMENT 'global transaction id',
    `context`       VARCHAR(128) NOT NULL COMMENT 'undo_log context,such as serialization',
    `rollback_info` LONGBLOB     NOT NULL COMMENT 'rollback info',
    `log_status`    INT(11)      NOT NULL COMMENT '0:normal status,1:defense status',
    `log_created`   DATETIME(6)  NOT NULL COMMENT 'create datetime',
    `log_modified`  DATETIME(6)  NOT NULL COMMENT 'modify datetime',
    UNIQUE KEY `ux_undo_log` (`xid`, `branch_id`)
) ENGINE = InnoDB
  AUTO_INCREMENT = 1
  DEFAULT CHARSET = utf8mb4 COMMENT ='AT transaction mode undo table';

```

参考：[快速开始-阿里云Spring Cloud Alibaba官网](https://sca.aliyun.com/docs/2023/user-guide/seata/quick-start/)

> 注意版本

然后我们修改配置文件：

```yml
seata:
  data-source-proxy-mode: AT
```

事实上默认即是AT模式，不填也会启用AT模式



## 选XA还是AT？

| 你的需求                          | 推荐模式             |
| :-------------------------------- | :------------------- |
| “钱不能错一分” + 并发不高         | ✅ **XA 模式**        |
| “用户体验要快” + 可接受短暂不一致 | ✅ **AT 模式**        |
| 系统基于 MySQL/Oracle 且支持 XA   | XA 可选              |
| 系统是互联网高并发业务            | ❌ 避免 XA，选 AT/TCC |

追求性能，不需要强一致性（不需要保证时时刻刻都一致）：选择**AT**

追求一致性，性能要求不高：选择**XA**

XA：全锁住！都对了再提交！错了一个我就全局事务回滚！

AT：自己的事务锁了就行，先提交再说，错了一个我用记录的undolog覆盖实现全局事务回滚。

