---
title: 应用部署
date: 2026-1-31
---

### 后端项目部署

#### package得到jar包

如果我们使用jar包实现后端项目部署，那么我们首先将项目使用idea等完成项目的打包，最终得到文件：

```bash
my-java-app/
├── app.jar          # 已编译好的可执行 JAR
└── Dockerfile
```

#### 编写Dockerfile

然后完成对应项目的`Dockerfile`文件编写：

```dockerfile
# 使用官方轻量级 JRE 镜像（推荐 Temurin）
FROM eclipse-temurin:17-jre-alpine

# 创建工作目录
WORKDIR /app

# 复制 JAR 文件
COPY app.jar app.jar

# 暴露端口（根据应用实际端口调整）
EXPOSE 8080

# 启动命令
ENTRYPOINT ["java", "-jar", "app.jar"]
```

> 🔑 **关键点**：
>
> - `eclipse-temurin:17-jre-alpine`：仅含 JRE，体积约 **～150MB**
> - 避免使用 `openjdk:17`（默认是 JDK，体积 ～500MB+）
> - Alpine 版本更小，但注意 glibc 兼容性问题（一般 Java 应用无影响）

#### build创建自制镜像

然后使用build命令完成镜像的自定义：

```bash
docker build -t 镜像名:标签 构建上下文路径
```

> 默认`Dockerfile`在上下文路径下（注意名称必须为`Dockerfile`，不可更改）不在上下文路径下则需要加`-f`指定文件`Dockerfile.prod`路径

#### run运行自制镜像

然后就完成了镜像的制作了，接着就可以直接`docker run`自制的镜像了：

```bash
docker run -d -p 主机端口:容器端口 镜像名:标签
```

其中指定好网络以及挂载文件。



### 前端项目部署

如果直接用nginx作为前端，那当然可以直接用官方的nginx镜像搞个容器，将文件夹直接挂载到主机，然后在主机改改就行。

#### **📁 项目结构准备**

确保你的 Vue 项目已通过 `npm run build` 生成 `dist/` 目录：

```bash
my-vue-app/
├── src/               # 源码
├── public/            # 静态资源
├── package.json
├── vue.config.js      # （可选）配置
├── dist/              # ← 必须存在！由 npm run build 生成
└── Dockerfile         # ← 待创建
```

> 🔧 如果没有 `dist/`，先本地构建：
>
> ```bash
> npm install
> npm run build   # 生成 dist/ 目录
> ```

------

#### **🐳 Dockerfile（多阶段构建 - 生产级）**

```dockerfile
# ===== 第一阶段：构建静态文件 =====
FROM node:18-alpine AS builder

WORKDIR /app

# 复制依赖配置（利用层缓存）
COPY package*.json ./

# 安装依赖（使用国内源加速）
RUN npm install --registry https://registry.npmmirror.com

# 复制源码
COPY . .

# 构建生产版本（生成 dist/）
RUN npm run build

# ===== 第二阶段：Nginx 托管 =====
FROM nginx:alpine

# 删除默认配置
RUN rm -rf /usr/share/nginx/html/*

# 从 builder 阶段复制静态文件
COPY --from=builder /app/dist /usr/share/nginx/html

# 复制自定义 Nginx 配置（可选）
COPY nginx.conf /etc/nginx/conf.d/default.conf

# 暴露 80 端口
EXPOSE 80

# Nginx 默认启动命令已内置，无需 CMD
```

> 💡 **关键点**：
>
> - 使用 `node:18-alpine` 构建（体积小）
> - 使用 `nginx:alpine` 运行（仅 ～23MB）
> - **最终镜像不含 Node.js、npm、源码**

------

#### **⚙️ 可选：自定义 Nginx 配置（**`nginx.conf`**）**

在项目根目录创建 `nginx.conf`，解决 Vue Router **history 模式 404 问题**：

```nginx
server {
    listen 80;
    server_name localhost;

    location / {
        root /usr/share/nginx/html;
        index index.html index.htm;
        # 关键：所有路由 fallback 到 index.html
        try_files $uri $uri/ /index.html;
    }

    # gzip 压缩（提升加载速度）
    gzip on;
    gzip_vary on;
    gzip_min_length 1024;
    gzip_types text/plain text/css application/json application/javascript text/xml application/xml;
}
```

> ✅ 如果你用的是 **hash 模式**（URL 含 `#`），可省略此文件。

------

#### **🛠️ 构建 & 运行命令**

```bash
# 1. 构建镜像
docker build -t my-vue-app .

# 2. 运行容器（映射 80 端口）
docker run -d -p 80:80 --name vue-web my-vue-app

# 3. 访问应用
open http://localhost
```

> 🔍 验证：
>
> ```bash
> curl http://localhost | head -n 5  # 应返回 HTML 内容
> ```

------

#### **🌐 部署到服务器（带域名）**

假设你有域名 `example.com`，配合 Nginx 反向代理或直接使用：

```bash
# 在服务器上运行（监听 80 端口）
docker run -d -p 80:80 --restart unless-stopped my-vue-app
```

然后将 DNS 解析指向服务器 IP 即可。



> 几个命令执行指令的区别：
>
> | 指令             | 执行时机                         | 作用                           | 是否出现在最终容器中                           | 能否被`docker run`覆盖                                       |
> | :--------------- | :------------------------------- | :----------------------------- | :--------------------------------------------- | :----------------------------------------------------------- |
> | **`RUN`**        | **镜像构建时**（`docker build`） | 安装软件、编译代码、生成文件等 | ❌ 不运行，只留下结果（如安装的包、生成的文件） | ❌ 不能覆盖（已固化在镜像层中）                               |
> | **`CMD`**        | **容器启动时**（`docker run`）   | 提供默认的启动命令和参数       | ✅ 是容器的主进程                               | ✅ **可以被 `docker run` 后的命令完全覆盖**                   |
> | **`ENTRYPOINT`** | **容器启动时**（`docker run`）   | 定义容器的“主程序”             | ✅ 是容器的主进程                               | ⚠️ **不易被覆盖**： • `docker run image arg1 arg2` → 参数会传给 `ENTRYPOINT` • 只有 `--entrypoint` 能替换它 |



### DockerCompose

**Docker Compose** 是 Docker 官方提供的一个**多容器应用编排工具**，它允许你通过一个 **YAML 配置文件（`docker-compose.yml`）** 来定义和运行多个相互关联的容器服务。

> 💡 **核心价值**：
> **“一键启动整个应用栈”** —— 无需手动逐个运行 `docker run` 命令。

| 概念                | 说明                                                         |
| :------------------ | :----------------------------------------------------------- |
| **Service（服务）** | 一个应用组件（如 `web`、`db`），对应一个容器镜像             |
| **Project（项目）** | 由 `docker-compose.yml` 定义的一组服务，默认以目录名作为项目名 |
| **Volume（卷）**    | 持久化数据（如数据库文件）                                   |
| **Network（网络）** | 服务间通信的私有网络（自动创建）                             |

#### yml文件内容

```yml
version: '3.8'          # Compose 文件版本（推荐 3.x）

services:               # 定义所有服务
  web:                  # 服务名（可自定义）
    image: nginx:alpine
    ports:
      - "80:80"
    volumes:
      - ./html:/usr/share/nginx/html
    depends_on:
      - app

  app:
    build: .            # 从当前目录 Dockerfile 构建
    ports:
      - "8080:8080"
    environment:
      - DB_HOST=db
    depends_on:			# 依赖db镜像，会先创建db镜像再搞他
      - db

  db:
    image: mysql:8.0
    environment:
      MYSQL_ROOT_PASSWORD: root123
      MYSQL_DATABASE: myapp
    volumes:
      - db_data:/var/lib/mysql

volumes:                # 定义命名卷
  db_data:

networks:               # （可选）自定义网络
  default:
    driver: bridge
```

| 字段    | 作用                     | 示例                                                         |
| :------ | :----------------------- | :----------------------------------------------------------- |
| `image` | 直接使用镜像仓库中的镜像 | `image: redis:7-alpine`                                      |
| `build` | 从本地 Dockerfile 构建   | `build: ./my-app` 或 `build: { context: ., dockerfile: Dockerfile.prod }` |

> ✅ **建议**：开发用 `build`，生产用 `image`（提前构建好推送到仓库）

> ⚠️ 注意：`depends_on` **只控制启动顺序，不等待服务就绪**！
> 如需等待 DB 就绪，需配合 `healthcheck` 或脚本。
>
> ```yml
> healthcheck:
>   test: ["CMD", "curl", "-f", "http://localhost:8080/health"]
>   interval: 30s
>   timeout: 10s
>   retries: 3
> ```
>
> ✅ 配合 `depends_on` 实现“真正等待服务就绪”



#### 常用命令

| 命令                         | 作用                               |
| :--------------------------- | :--------------------------------- |
| `docker compose up`          | 启动所有服务（前台运行）           |
| `docker compose up -d`       | 后台启动（守护进程模式）           |
| `docker compose down`        | 停止并删除容器、网络（**不删卷**） |
| `docker compose logs -f web` | 查看 `web` 服务日志                |
| `docker compose ps`          | 列出项目中所有容器状态             |
| `docker compose build`       | 重新构建 `build` 类型的服务        |
| `docker compose restart db`  | 重启 `db` 服务                     |



#### 和k8s的比较

| 特性              | Docker Compose          | Kubernetes     |
| :---------------- | :---------------------- | :------------- |
| **定位**          | 单机多容器编排          | 分布式集群编排 |
| **学习曲线**      | 简单（YAML + 几个命令） | 复杂           |
| **适用场景**      | 开发、测试、小型生产    | 中大型生产环境 |
| **高可用/扩缩容** | 不支持                  | 原生支持       |
