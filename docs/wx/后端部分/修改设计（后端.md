---
title: 修改设计
date: 2026-1-21
---

### 拉黑重新做处理

对拉黑以及被拉黑的联系以及群组放至黑名单中，其contact的status为4:拉黑;5:被拉黑，对相应状态作说明

可以通过黑名单窗口修改当前用户对其他人的拉黑状态，取消拉黑将会重置status为0:非好友



### Token添加其他验证验证

用户发送request除了会带上token，还会带上设备信息，token可以和设备信息一起存储到redis里面，每次aspect验证token还可以顺便验证一下设备是否对得上，对不上就非法。

获取设备信息：

```java
ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
HttpServletRequest request = attributes.getRequest();
String token = request.getHeader("token");
String userAgent = request.getHeader("User-Agent");                             // 验证用户登录节点
```

获取到的设备信息：

Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) letschat-front/1.0.1 Chrome/114.0.5735.289 Electron/25.9.8 Safari/537.36

对应说明：

<产品标识> (<平台信息>) <渲染引擎> (<兼容性声明>) <应用名称/版本> <浏览器内核/版本> ...

可得以上字符串解析为:

- **应用**：`letschat-front`（版本 1.0.1）
- **类型**：**Electron 桌面应用**（非浏览器）
- **Electron 版本**：25.9.8
- **内核**：基于 **Chrome 114**（Chromium）
- **系统**：**Windows 10/11 64位**

注意：**User-Agent 与网络环境无关**，所以直接用就完事了（前提是使用web！而非Eletron的主线程之类的！）

更新我们的token类：

```java
@Data
public class TokenUserInfoDto implements Serializable {
    private static final long serialVersionUID = -3244262035649152692L;
    private String token;
    private String userId;
    private String nickName;
    private Boolean isAdmin;
    private String UserAgent;
}
```

在登录操作中加入token的更新：

```java
// 设置userAgent
ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
HttpServletRequest request = attributes.getRequest();
String userAgent = request.getHeader("User-Agent");
tokenUserInfoDto.setUserAgent(userAgent);
```

随后我们就可以在aspect或者拦截器中加入对设备信息的验证了：

```java
private void checkLogin(Boolean checkAdmin) throws BusinessException {
    // 获取当前线程绑定的请求上下文
    ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
    HttpServletRequest request = attributes.getRequest();
    String token = request.getHeader("token");
    String userAgent = request.getHeader("User-Agent");                             // 验证用户登录节点
    if (token == null) {
        logger.error("token为空");
        throw new BusinessException(ResponseCodeEnum.CODE_901);
    }
    if (userAgent == null) {
        logger.error("UserAgent为空");
        throw new BusinessException(ResponseCodeEnum.CODE_901);
    }
    TokenUserInfoDto tokenUserInfoDto = (TokenUserInfoDto) redisUtils.get(Constants.REDIS_KEY_WS_TOKEN + token);
    if (tokenUserInfoDto.getUserAgent()==null || !tokenUserInfoDto.getUserAgent().equals(userAgent)){
        logger.error("UserAgent不一致");
        throw new BusinessException(ResponseCodeEnum.CODE_901);
    }
    ......
}
```

如需进一步解析（比如提取操作系统、版本号等），可使用开源库如：

- [UA工具类-UserAgentUtil | Hutool](https://doc.hutool.cn/pages/UserAgentUtil/#由来)

这样我们可以解析出一个个详细的信息以供使用。

**出现的问题：**

eletron的主线程axios发送的useragent并非经过浏览器渲染的，存在一定问题，需要渲染线程尝试获取一个useragent并同步到主线程上，或者干脆换一种验证方式，不去使用useragent，而是其他组件提供的设备信息等验证消息获取！



### WebRTC实现视频交流

好像还可以顺带实现文件传输，看一下

[实现WebRTC P2P连接 - 知乎](https://zhuanlan.zhihu.com/p/45437087)

[WebRTC TURN协议初识及turnserver实践 - 知乎](https://zhuanlan.zhihu.com/p/71025431)

[国内可访问的STUN服务器 - 知乎](https://zhuanlan.zhihu.com/p/1928418712958010287)

注意需要 HTTPS 或 `localhost` 环境才能调用 `getUserMedia`，去找腾讯云的办个几毛的域名嫖一个免费的ssl



### 分布式存储消息（HBase）

项目本身消息的主要存储途径是用户前端的本地存储，但是还存在一些场景，比如说用户更换设备了，想要获取这几天的消息，这时候就需要请求后端存储的记录了。但是消息数据量极大，如果使用mysql存储，非常占用空间，而且由于使用userid而非messageid作索引查询，速度还非常慢。

所以一般情况下无法使用mysql作为消息的存储数据库，对于这种业务场景，mysql最好只是用作缓存，对于7/30天内的数据存储在mysql中作缓存，而对于时间更久远的消息数据，我们可以放到分布式数据库，比方说HBase（或者tidb）来专门作慢查询。



### 接入AI API

搞个ai对话，只需要用户输入api的信息就可以调用几个简单的模型

> hutool提供的AI：[AI封装-AIUtil | Hutool](https://doc.hutool.cn/pages/AIUtil/#使用)



### 离线消息的推送模式考虑

原本对于离线消息的获取策略是直接到数据库中根据时间戳获取session中的下线后的对话记录，这样的查询效率比较慢，考虑换一种获取离线消息的策略。

可以使用混合读写扩散，对于不同类型的用户，群组指定不同的读写扩散策略：

僵尸用户直接读数据库

活跃的**群组**的消息按照量级大小选择是否存储MessageID至对应sessionID的“发件箱”（zset），用时间戳做score，用户登录后尝试从其中获取自己离线时间戳之后的MessageID再做查询（**读扩散**）

> 群组的消息是**广播**，使用读扩散占用空间小。

活跃的**用户之间**的消息传输考虑是否**确认对方离线状态下**，将传输的MessageID存入对方的”收件箱“，用户登录后从中获取所有MessageID再做查询（**写扩散**）

> 用户之间的消息通信是**单播**，只会从一个用户传输到另一个用户，这种情况下**写扩散**只需要在**一个**用户的收件箱存储MessageID即可，而即便使用**读扩散**也需要在**发送方**的发件箱存储数据，而且读扩散还需要额外设计查询订阅发件箱，还查的慢；
>
> 使用写扩散在这里不仅查的快，资源占用的也少，所以使用写扩散处理单用户之间的通信。

但是实现起来需要一定考量。



### 文件管理OSS

上传的ECS不够磁盘用那可以去用其他的OSS来实现文件管理，或者硬盘够用嫌管理不太好，可以使用minio来实现文件管理。

**发现一个问题**：分布式部署下，消息是可以redission传递的，但是文件怎么办？

针对后端分布式部署的情况，我们最好还是选择OSS来存储文件（或者自备一个minio之类的文件服务器）

直接用后端服务器传完整文件太过消耗带宽了，我们可以先给后端发请求，后端向oss申请一个包含了指定文件，指定操作的token，再将token传给前端，前端通过token用本地ossclient去执行相应操作。

（这里对于哪些文件要通过oss存储，哪些文件要直接存在后端服务器需要进一步探讨）



### 智能机器人RAG

做个简单的RAG，导到模型里做聊天助手



### 人物模仿AI

找个合适的模型，将对话记录导入后简单实现模仿人类

简单的模型调用：



尚可的人物卡对话：

[安装指南 | SillyTavern傻酒馆中文文档](http://sillytavern.wiki/installation/)

[SillyTavern/SillyTavern: LLM Frontend for Power Users.](https://github.com/SillyTavern/SillyTavern)

复杂的模型生成：

[WeClone](https://docs.weclone.love/zh/)

有点意思



### MCP简单实现

顺便看看能不能用截取音频为文字，让人物模型来当牛做马



### 尝试接入ElaticSearch

[ElasticSearch篇——初始、认识、拿下ElasticSearch，一篇文章带你入门ES，涵盖ES概念，对比Solr，ES核心概念以及常见工具head、kibana安装和使用，保姆级教程！！！_es入门-CSDN博客](https://blog.csdn.net/CNpeaceful/article/details/134894253)



### freemarker生成邮箱验证码并推送

[SpringBoot优雅实现邮箱验证码功能：最佳实践与关键细节解析在实现邮箱验证码功能时，表面上只是发送一封带有验证码的 - 掘金](https://juejin.cn/post/7408847526298435624)



### 对长连接集群分布式的思考

如果后续更新，可以考虑拆出ws部分，做成微服务，用RPC调用的方式来实现ws通信。

而这样就可以修改架构为多个后端服务器与一个ws服务器协同处理连接

[1000W长连接，如何建立和维护？千万用户IM 架构设计-阿里云开发者社区](https://developer.aliyun.com/article/1628257)



### Redission再设计

RTopic的广播设计需要所有服务器从自己的内存中查找是否存在被通知用户，压力并非平摊到所有服务器而是部分叠加到所有服务器上，这样的操作还是太吃资源了，我们需要点对点的传播，正好Redission要求的是连接到一个redis或者是redis集群，我们可以考虑在redis里记录用户的登录状态以及登录对应服务器，完成对传播路径的记录。整体传播的思路：

服务器连接Redis->Redis注册node信息（根据ip以及两个port用hash生成id作为key）->将信息刷新到nginx，nodeId与node信息做关联，以便nginx获取ttl测试延迟并传回nodeId->根据自己的nodeId监听RTopic

登录发送连接消息->nginx测试几个服务器并选择一个，将nodeId传回客户端，后续request需要在请求头带上nodeId以选择处理服务器->ws建立长连接->redis心跳注册连接信息key为userId，value为nodeId

发送消息->根据请求头的nodeId选择对应ip的服务器->检查当前ws链接服务器是否有对应用户（有则直接发送ws消息）->无则检查redis（集群）中对应用户的登录状态（未登录消息已存储在数据库，直接结束）->有则获取redis中记录的对应登录节点id->根据id发送消息到对应监听话题RTopic

#### 登录状态以及登录节点的记录

以hash的方式记录，key为用户id，value为登录节点id以及heartbeat心跳，当redis（集群）中不存在该用户id为key的字段时表示该用户未登录

#### 登录节点

给每个后端服务器分配唯一标识（Node ID），并基于该标识实现跨服务节点的点对点消息投递，根据ip+两个端口进行hash获取id，最终用所得结果作为id。在用户进行请求时需要在header带上这个id作为选择服务器，否则检查是否是登录，非登录则违法。

#### 实际实现思路

依旧使用Redission的RTopic实现服务器通信，不同的是，这一次选择只监听自己的频道，对于其他的频道不会进行监听。在服务器完成后端应用启动时会分配一个唯一标识并存储在redis。发送消息时（假如不是同一服务器）会先获取对方所在的服务器节点id，并对此节点id的频道发送消息推送。

对于redis中用户的登录状态的维持，由心跳检查完成，客户端向所连接服务器发送心跳包，当10s检查不到就会检测为断开连接，redis中的这一条存储是会过期的（15s过期）

#### 群组的消息传递

**但是请注意！**这是针对**单个用户**之间通信的方式，如果是**群组**，那有可能很多服务器上都有这么一个channelgroup，即发送一次群组消息可能需要在，所以现在考虑每次生成channelgroup也做redis的list记录nodeIp并同样点对点发，还是干脆直接全部发了



### 鉴权优化

考虑使用JWT




### Nginx

后端可以做集群部署，但做了集群部署没有做gateway网关的话，前端就需要nginx作反向代理

> 检查redis中token的长连接信息，针对发送对象推送到指定后端服务器，使用redission实现服务器间的消息通信
>
> 如果后续实现了ws的独立以及RPC调用，我们也可以直接处理请求，根据token在redis中的长连接信息再使用RPC直接调用对应ws服务器的消息发送

负载均衡：

延迟优化：

综合方案：



### 负载均衡方案

[尚硅谷2025最新SpringCloud教程，springcloud从入门到大牛_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1UJc2ezEFU/?spm_id_from=333.337.search-card.all.click&vd_source=7b42dfb355ea0bc58b40a2c9eeeaab2c)

使用**nginx**+**nacos**+**gateway**



### 异步方案

为了使得消息传递更加迅速，在我们已实现ws服务器作为单独服务分离出原本的单体项目的情况下，我们可以使用异步调用来完成channel的数据传输，而同时，由于对数据库的要求比较小（只是用来缓存数据）我们也可以准备一个**消息队列**，将数据的写入操作塞到写入数据库的消息队列中，这样我们就将**通知**以及**写入数据库**这两个所需时间比较大的操作通过异步的方式分离出来，使得主线程能够更加高效的执行业务。





