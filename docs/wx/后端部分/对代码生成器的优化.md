---
title: 对代码生成器的优化
date: 2025-11-28
---

使用mybatisplus版本：<mybatis-plus.version>3.5.14</mybatis-plus.version>

版本不同可能导致各种各样的问题（如jdk不兼容mybatisplus和他的配件

mybatisplus不够用了，得搞点原生的mapper来做多表查询

将提供的一些牛逼版查询加入以实现多表联查，分页等功能

1. 将mapperxml导入，需要将与mybatisplus冲突的简单sql去除（根据完成的xml，让ai直接完成对ftl模版的编写）
2. 将分页dto导入，载入手动分页（mybatisplus提供的分页也仅支持单表查询）

修改这个主要是实现mybatisplus实现不了的**多表查询**，以及**insertOrUpdate**避免索引异常问题（mybatisplus只处理主键id冲突，且只能指定一个主键，多主键或者有其他unique索引无法处理）。

> **insertOrUpdate**用`ON DUPLICATE KEY UPDATE`的方式来实现避免索引异常可以吗？
>
> 可以，但是这个操作会进行先加**S锁**再加**X锁**的操作，当我们对一行记录进行相同的DUPLICATE操作时，尝试获取X锁需要其他事务释放S锁，而这时两个事务都会等待对方释放S锁，这就会导致死锁。虽然可以超时异常抛出，但是在实际生产环境非常不推荐使用它！
>
> 除非你能**确保**操作的**这一行数据**是**不会出现高并发**的，而我们所写的脚手架是**无法确保这一点**的，所以不可以使用！
>
> 选择其他方案：
>
> | 方案                           | 是否推荐          | 适用场景                     |
> | ------------------------------ | ----------------- | ---------------------------- |
> | `ON DUPLICATE KEY UPDATE`      | ❌（高并发下慎用） | 低并发、可重试、简单场景     |
> | **INSERT + 异常捕获 + UPDATE** | ✅ **推荐**        | 通用脚手架、高并发系统       |
> | `SELECT FOR UPDATE` + 判断     | ✅（特定场景）     | 强一致性、**低并发**关键操作 |
> | ODKU + 重试                    | ⚠️ 可接受          | 具备重试机制、死锁容忍度高   |
>
> **INSERT + 异常捕获 + UPDATE 方案:**
>
> ```java
> try {
> insertRecord();
> } catch (DuplicateKeyException e) {
> updateRecord();
> }
> ```
> 注意更新的条件构造器需要指定好索引的字段，相对来说复杂一些（多字段索引下不能只针对一个字段更新）
>
> ```java
> mapper.update(entity,new UpdateWrapper<Entity>().
>     eq("columnName",value).
>     eq(...))
> ```
>
> **`SELECT FOR UPDATE` + 判断 方案：**
>
> ```sql
> BEGIN;
> SELECT * FROM table WHERE unique_key = 'xxx' FOR UPDATE;
> 
> -- 应用层判断是否存在：
> --   if exists → UPDATE
> --   else      → INSERT
> 
> COMMIT;
> ```
>
> 注意会加**X锁**，高并发下会带来性能损耗！



需要完成的mapper复杂查询：

1. 全部模糊查询：根据输入非空内容对相应表做模糊查询，在service层写太难看了，写到mapper里面去
2. 插入或更新：有些时候会有多个索引（双主键等），需要加入检查来实现insertOrUpdate
3. 联表基础sql：自己表的简单查询即可，方便后续有需求时修改联表查询

对redis的模版做优化

