---
title: 遇到的问题（前端）
date: 2025-11-28
---

### 跨域了怎么办

跨域问题（CORS, Cross-Origin Resource Sharing）是浏览器出于安全考虑实施的同源策略（Same-Origin Policy）所导致的。当一个资源去访问另一个不同源（域名、协议、端口任一不同）的资源时，就会出现跨域问题。

解决跨域问题的方法在**开发环境**和**生产环境**中有所不同，因为两者的部署架构和可控性不同。

------

#### 一、开发环境 (Development Environment)

在开发时，前端（如 Vue, React 项目）通常运行在 `localhost:3000` 或 `localhost:8080`，而后端 API 运行在 `localhost:5000` 或其他端口，这就构成了跨域。

##### 常用解决方案：

1. **使用开发服务器代理 (Proxy)**

   - **原理**：利用前端开发服务器（如 Webpack Dev Server、Vite）的代理功能，将 API 请求转发到后端服务器。浏览器认为请求是发给自己的（同源），而开发服务器再将请求转发给真正的后端。

   - 配置示例 (Vue CLI / Vite)：

     ```javascript
      // vite.config.js (Vite)
     export default {
       server: {
         proxy: {
           '/api': {
             target: 'http://localhost:5000', // 后端地址
             changeOrigin: true, // 修改请求头中的 origin
             rewrite: (path) => path.replace(/^\/api/, '') // 重写路径
           }
         }
       }
     }
     ```
     
     ```javascript
      // vue.config.js (Vue CLI)
     module.exports = {
       devServer: {
         proxy: {
           '/api': {
             target: 'http://localhost:5000',
             changeOrigin: true,
             pathRewrite: {
               '^/api': ''
             }
           }
         }
       }
     }
     ```
     
   - **优点**：简单、安全，只在开发时生效，不暴露后端接口。

   - **缺点**：仅限开发环境。

2. **后端开启 CORS**

   - **原理**：在后端代码中添加 CORS 中间件，允许来自前端开发服务器的请求。

     ##### 方法 1：使用 `@CrossOrigin` 注解（局部）

     适用于单个 Controller 或方法。

     ```java
     @RestController
     @RequestMapping("/api/user")
     @CrossOrigin(origins = "http://localhost:3000") // 允许前端域名
     public class UserController {
     
         @GetMapping("/{id}")
         public User getUser(@PathVariable Long id) {
             return userService.findById(id);
         }
     
         @PostMapping
         public User createUser(@RequestBody User user) {
             return userService.save(user);
         }
     }
     ```
     
     你也可以指定更多选项：
     
     ```java
     @CrossOrigin(
         origins = "http://localhost:3000",
         methods = {RequestMethod.GET, RequestMethod.POST},
         allowCredentials = "true",
         maxAge = 3600
     )
     ```
     
     ------
     
     ##### 方法 2：全局配置 CORS
     
     创建一个配置类，全局允许 CORS。
     
     ```java
     @Configuration
     @EnableWebMvc
     public class CorsConfig implements WebMvcConfigurer {
     
         @Override
         public void addCorsMappings(CorsRegistry registry) {
             registry.addMapping("/api/**") // 匹配的路径
                     .allowedOriginPatterns("http://localhost:3000") // 允许的源
                     .allowedMethods("GET", "POST", "PUT", "DELETE", "OPTIONS")
                     .allowedHeaders("*")
                     .allowCredentials(true) // 允许携带 Cookie
                     .maxAge(3600); // 预检请求缓存时间
         }
     }
     ```
     
     > ⚠️ 注意：
     >
     > - `@EnableWebMvc` 会完全接管 Spring MVC 的默认配置，**谨慎使用**。如果只是加 CORS，建议不用它。
     > - 更好的做法是**不加 `@EnableWebMvc`**，直接实现 `WebMvcConfigurer`，Spring Boot 会保留默认配置并叠加你的设置。
     
     所以更安全的写法是：
     
     ```java
     @Configuration
     public class CorsConfig implements WebMvcConfigurer {
     
         @Override
         public void addCorsMappings(CorsRegistry registry) {
             registry.addMapping("/api/**")
                     .allowedOriginPatterns("http://localhost:3000")
                     .allowedMethods("*")
                     .allowedHeaders("*")
                     .allowCredentials(true)
                     .maxAge(3600);
         }
     }
     ```
     
     ------
     
     ##### 方法 3：使用过滤器（Filter）
     
     ```java
     @Component
     public class CorsFilter implements Filter {
     
         @Override
         public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain)
                 throws IOException, ServletException {
             HttpServletResponse response = (HttpServletResponse) res;
             HttpServletRequest request = (HttpServletRequest) req;
     
             response.setHeader("Access-Control-Allow-Origin", "http://localhost:3000");
             response.setHeader("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS");
             response.setHeader("Access-Control-Max-Age", "3600");
             response.setHeader("Access-Control-Allow-Headers", "*");
             response.setHeader("Access-Control-Allow-Credentials", "true");
     
             if ("OPTIONS".equalsIgnoreCase(request.getMethod())) {
                 response.setStatus(HttpServletResponse.SC_OK);
             } else {
                 chain.doFilter(req, res);
             }
         }
     }
     ```


   - **优点**：快速见效。

   - **缺点**：生产环境不能随意开启，存在安全风险。

------

#### 二、生产环境 (Production Environment)

在生产环境中，通常通过域名部署，解决方案更注重安全性和稳定性。

##### 常用解决方案：

1. **Nginx 反向代理**

   - **原理**：使用 Nginx 作为前端和后端的统一入口。将前端静态资源和后端 API 都代理到同一个域名下，从而避免跨域。

   - 配置示例：

     ```nginx
      server {
         listen 80;
         server_name yourdomain.com;
     
         # 前端静态资源
         location / {
             root /path/to/your/frontend/dist;
             try_files $uri $uri/ /index.html;
         }
     
         # API 接口代理到后端服务
         location /api/ {
             proxy_pass http://localhost:5000/; # 后端服务地址
             proxy_set_header Host $host;
             proxy_set_header X-Real-IP $remote_addr;
             proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
         }
     }
     ```
     
   - **优点**：最推荐的生产环境方案，安全、高效、可扩展。

   - **缺点**：需要额外的服务器配置。

2. **后端精确配置 CORS**

   - **原理**：在生产环境中，后端可以安全地配置 CORS，只允许来自你正式域名的请求。

   - 示例：

     ```java
     @Configuration
     public class ProductionCorsConfig implements WebMvcConfigurer {
     
         @Value("${frontend.origin}") // 可以从 application.yml 读取
         private String frontendOrigin;
     
         @Override
         public void addCorsMappings(CorsRegistry registry) {
             registry.addMapping("/api/**")
                     .allowedOriginPatterns(frontendOrigin) // 如 https://www.yourapp.com
                     .allowedMethods("GET", "POST", "PUT", "DELETE")
                     .allowedHeaders("*")
                     .allowCredentials(true)
                     .maxAge(3600);
         }
     }
     ```

   - **优点**：直接在应用层控制。

   - **缺点**：如果前端和后端完全分离部署，仍需确保 CORS 配置正确，且不如反向代理“彻底”解决跨域。

3. **使用 JSONP (仅限 GET 请求)**

   - **原理**：利用 `<script>` 标签不受同源策略限制的特性，通过动态创建 script 标签来请求数据。
   - **缺点**：只支持 GET 请求，安全性较差，已被现代技术（如 CORS）取代。
   - **结论**：**不推荐**在新项目中使用。

4. **前后端同域部署**

   - **原理**：将前端静态文件和后端服务部署在同一个域名和端口下。例如，后端服务同时提供 API 和静态文件。
   - **示例**：Spring Boot 项目将 `dist` 目录下的文件放在 `src/main/resources/static` 下。
   - **优点**：彻底避免跨域。
   - **缺点**：耦合度高，不利于前后端独立部署和扩展。

------

#### 总结

| 环境         | 推荐方案                   | 备选方案                     |
| ------------ | -------------------------- | ---------------------------- |
| **开发环境** | 前端开发服务器代理 (Proxy) | 后端开启 CORS                |
| **生产环境** | Nginx 反向代理             | 后端精确配置 CORS / 同域部署 |

**最佳实践**：

- 开发时用 **Vite/Webpack 代理**。
- 生产时用 **Nginx 反向代理**，实现前后端同域，既解决了跨域，又提升了性能和安全性。


### 避免以明文形式传输密码等重要信息



### 组件Component和布局layout的区别



### eletron本地sqlite缓存的实现



### `<router-view>`实现区域页面跳转



### sqlite简易sql脚手架的实现

#### 数据库表以及字段的提取以及对象映射（驼峰转换）的实现



#### sql基础语句的拼接以及执行



### 回到底部

`@scroll`可以监听滑轮滚动，给出监听位置方法：

```javascript
// 处理滚动事件，检测是否在底部
const handleScroll = () => {
  const messagePanel = document.getElementById('message-panel1')
  if (!messagePanel) return

  // 计算是否在底部（允许一定误差）
  const threshold = 50 // 距离底部50px以内认为是在底部
  const atBottom = messagePanel.scrollHeight - messagePanel.clientHeight <= messagePanel.scrollTop + threshold
  isAtBottom.value = atBottom
}
```

每次滚动都会判断是否在底部，在就将`isAtBottom`赋为true，反之为false，通过`v-show`判断是否展示

```html
        <div class="message-panel"
             id="message-panel1"
             @scroll="handleScroll">
            ......
            <!-- 回到底部按钮 -->
            <div v-show="!isAtBottom"
                 class="back-to-bottom"
                 @click="gotoBottom">
              <i class="iconfont icon-down"></i>
            </div>
```

### 常见错误：套层

有时候取不到值变成undefined可能是因为获取到的结构外部又套了一层，打开控制面板console一下看看结构。

注意函数的读取方式，当直接使用`data`时，有可能获取到的是一个对象，会有嵌套，`data.data`才是真正的数据。如果需要一开始就解析出内容，而非使用通用对象包装接收，那就使用`{data}`来接收数据。但要注意这种方式，你所填写的接收字段名称必须与发送的一致，否则会undefined。

### 本项目怎么实现的文件图片视频等传输？

当发送时，首先在本地数据库中记录该条记录，设置信息类型为文件；同时消息发送到服务器获取到messageId，并对文件做转码处理（如果有需要），获取封面，将两个文件存储到本地路径（users/{username}/.{项目名称}/fileStorage/{messageId}），并将两个文件上传到服务器。当两个文件上传完成时，后端会发送消息通知已经上传完成，前端修改视频的加载状态。

当接收时，

### 本地文件存储与读取

Eletron可以选择使用包装好的脚手架fs

当app获取一些文件（头像，图片）时，会通过express尝试从本地获取，如没有，则会尝试从服务器获取

### Promise是什么？resolve又是什么？怎么用？



### 视频文件是怎么截取封面的？

#### ffmpeg



### node的express是什么？为什么选择使用它作为本地文件处理器？

本项目主要用于管理本地文件

登录后生成express服务器

### 文件更新逻辑混乱

对于需要修改的文件，如更新后的头像，项目中没有选择使用每次修改更新就进行本地文件修改的方式来实现对本地图片缓存的修改，而是选择了上传完服务器之后，假如需要修改本地文件，再重新从服务器获取新的文件来覆盖本地文件，这种修改模式非常混乱，不利于后续更新维护。

之所以这么设计，其实只是懒。对于头像的更新，代码中给出了方案是在每次使用头像组件时，会检查输入参数forceget是否为true，若为true，那么就会直接从服务器下载并覆盖本地；反之，会现在本地找，找不到去服务器下，下不到就是用默认头像。为了偷懒，就直接在上传完头像后用store将自己的forceget设置为true来再次重新从服务器下载本就有的本地头像图片实现对自己头像的更新覆盖，这种做法的逻辑相对来说更加繁杂，且占用了服务器额外的带宽。

更加清晰的做法是更新头像就直接更新本地的原有头像文件，然后只需要上传到服务器即可，这样更加合适一点。

### 视频，图片预览查看器

[web前端：Viewer.js图片查看器 - 知乎](https://zhuanlan.zhihu.com/p/148311631)

[强大的图片预览组件Viewer.js-阿里云开发者社区](https://developer.aliyun.com/article/1166652)

视频播放器[指南 | DPlayer](https://dplayer.diygod.dev/zh/guide.html)

项目选择使用ipc通知主线程附上参数生成新窗口（根据vue路由获取到renderer里的组件），



#### 问题

##### 视频快进等任何操作直接回到最开始

对于视频，音频等文件，我们只是直接request从后端得到的文件存在问题，需要额外处理（断点续传）

```javascript
	let stat = fs.statSync(localPath);	// 使用 fs.statSync 同步获取文件的统计信息，包括文件大小等属性
	let fileSize = stat.size;
	let range = req.headers.range;	// 从HTTP请求头中获取 range 字段，用于判断是否为范围请求（断点续传）
	if (range) {
		let parts = range.replace(/bytes=/, "").split("-");	// 去除范围请求中的 "bytes=" 前缀，并按 "-" 分割获取起始和结束位置
		let start = parseInt(parts[0], 10);
		let end = parts[1] ? parseInt(parts[1], 10) : start + 99999; 	// 如果有结束位置则解析，否则默认请求从起始位置开始的100000字节
		end = end > fileSize - 1 ? fileSize - 1 : end; 	// 确保结束位置不超过文件大小
		let chunksize = (end - start) + 1;
		let stream = fs.createReadStream(localPath, { start, end });	// 创建文件读取流，只读取指定范围内的内容
		let head = {
			'Content-Range': `bytes ${start}-${end}/${fileSize}`,			// 返回请求的区间
			'Accept-Ranges': 'bytes',																	// 表示服务器支持范围请求
			'Content-Length': chunksize,															// 返回请求的区间大小										
			'Content-Type': 'video/mp4'																// 响应文件类型为视频							
		};
		res.writeHead(206, head);																		// 返回206状态码，表示206状态码表示部分内容返回
		stream.pipe(res);																					  // 将文件内容写入响应
	} else {
		let head = {
			'Content-Length': fileSize,
			'Content-Type': 'video/mp4'
		};
		res.writeHead(200, head);
		fs.createReadStream(localPath).pipe(res);
	}
```

### 拖拽上传

```html
    <div class="input-area"
         @drop="dropHandler"
         @dragover="dragOverHandler">
```

vue本身实现了拖拽上传功能，只需实现对应的方法即可实现此功能

```javascript
const dragOverHandler = (e) => {
  e.preventDefault()
}

const dropHandler = (event) => {
  event.preventDefault()
  const files = event.dataTransfer.files
  if (!checkFileLimit(files)) {
    return
  }
  for (let i = 0; i < files.length; i++) {
    uploadFileDo(files[i])
  }
}
```

### 滚动懒加载

```javascript
// 加载消息记录，滚动懒加载
const loadChatMessage = async () => {
  // 如果没有更多数据，则返回
  if (messageCountInfo.noData) {
    return;
  }
  // 每次滚动加载后变化页码
  messageCountInfo.pageNo++
  // ipc获取数据
  const { dataList, pageTotal, pageNo } = await window.ipcRenderer.invoke('loadChatMessage', {
    sessionId: currentChatSession.value.sessionId,
    pageNo: messageCountInfo.pageNo,
    maxMessageId: messageCountInfo.maxMessageId
  })
  messageList.value = dataList.concat(messageList.value)
  messageList.value.sort((a, b) => {
    return a.messageId - b.messageId;
  });

  console.log('加载消息记录', messageList.value)

  messageCountInfo.pageNo = pageNo
  messageCountInfo.pageTotal = pageTotal
  if (pageNo == 1) {
    messageCountInfo.maxMessageId =
      dataList.length > 0 ? dataList[dataList.length - 1].messageId : null

  }
}
```

通过分页的方式来实现，每次触发pageNum++，这个方法可以被一些监听事件使用，比如当滚动到头部时就会执行此方法以加载数据

#### 怎么避免一开始在顶部导致直接加载两次数据

可以加入一个标志位标记是否需要加载：

```javascript
// 添加一个标志来标识是否是初始加载
const isInitialLoading = ref(false)

// 修改 handleScroll 函数
const handleScroll = async () => {
  const messagePanel = document.getElementById('message-panel1')
  if (!messagePanel) return

  // 计算是否在底部（允许一定误差）
  const threshold = 50 // 距离底部50px以内认为是在底部
  const atBottom = messagePanel.scrollHeight - messagePanel.clientHeight <= messagePanel.scrollTop + threshold
  isAtBottom.value = atBottom

  // 检查是否滚动到顶部以加载更多聊天记录，但要排除初始加载的情况
  if (messagePanel.scrollTop === 0 && !messageCountInfo.noData && 
      messageList.value.length > 0 && !isInitialLoading.value) {
    await loadChatMessage()
  }
}

// 修改 chatSessionClickHandler 函数
const chatSessionClickHandler = async (item) => {
  currentChatSession.value = Object.assign({}, item)
  // TODO 消息记录要清空
  messageList.value = []
  messageCountInfo.pageTotal = 0
  messageCountInfo.pageNo = 0
  messageCountInfo.maxMessageId = null
  messageCountInfo.noData = false;
  
  // 设置初始加载标志
  isInitialLoading.value = true
  
  await setSessionSelect({ contactId: item.contactId, sessionId: item.sessionId })
  await loadChatMessage()
  
  // 初始加载完成后，延迟取消标志，确保不会立即触发滚动加载，setTimeout 是异步函数，不会阻塞后续代码的执行
  setTimeout(() => {
    isInitialLoading.value = false
  }, 100)
  
  gotoBottom()
  handleScroll()
}
```

可以看到我们加了一个`isInitialLoading`来判断此时是否是初始加载，当我们点击一个会话，进入会话后，会短暂的设置这个标志位为true，这段时间，滚轮监听`handleScroll`的`loadChatMessage`将会因为这个标志位为true而无法执行，而`chatSessionClickHandler`的第一次加载是不会判断`isInitialLoading`的。当然，进入`chatSessionClickHandler`的第一次`loadChatMessage`加载是不会被阻塞的：

### 未读消息的管理



修改：contact页面同样监听是否有好友申请，有则刷新页面，添加红点；一些监听逻辑存在问题：如当在contact页面时chat的未读消息无法获取到。一些公共的事件最好还是放到main做监听比较好，否则会导致store无法正常更新或者通知无法正常显示

### eletron托盘自定义



### 应用更新的方式



### 简单搜索关键字

直接使用contains来对输入查询内容作模糊查询，项目选择查询联系人名称以及最后一条消息的内容。

可以通过正则的方式来实现对关键字部分的标记：

```javascript
    if (item.contactName.includes(searchKey.value) || item.lastMessage.includes(searchKey.value)) {
      let newData = Object.assign({}, item)
      // 设置关键字区块高亮
      newData.searchContactName = newData.contactName.replace(
        regex,
        "<span class='highlight'>$1</span>"
      )
      newData.searchLastMessage = newData.lastMessage.replace(
        regex,
        "<span class='highlight'>$1</span>"
      )
      searchList.value.push(newData)
    }
```

当然也可以选择使用elasticsearch等更加强大的工具来实现搜索功能。

### 群的头像点击后存在问题



### 点击后激活状态css样式

可以添加一个.active样式名称并配置相关样式
