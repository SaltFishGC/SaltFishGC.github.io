---
title: session，token，jwt
date: 2025/11/3
tags:
 - 笔记
 - 前端
 - session
 - token
 - jwt
categories:
 - notes
---

它们的核心目标都是解决同一个问题：**如何在无状态的 HTTP 协议下，识别并保持用户的登录状态。**

---

### 1. Session (会话)

**核心思想：服务端存储状态**

当用户成功登录后：

1.  **服务器生成 Session ID**：
    *   服务器创建一个唯一的、随机的字符串作为 `Session ID`。
2.  **服务器存储 Session 数据**：
    *   服务器将这个 `Session ID` 与该用户的相关信息（如用户ID、角色、登录时间等）一起存储在**服务器端**。存储位置可以是内存（如 Redis）、数据库或文件系统。
3.  **返回 Session ID 给客户端**：
    *   服务器通过 `Set-Cookie` 响应头，将 `Session ID` 发送给浏览器。
4.  **客户端保存并发送**：
    *   浏览器自动将这个 `Session ID` 保存为 Cookie，并且在后续每次请求中，都会自动把这个 Cookie（包含 Session ID）发送给服务器。
5.  **服务器验证**：
    *   服务器收到请求后，从 Cookie 中提取 `Session ID`，然后去自己的存储中查找对应的用户数据。如果找到，就认为用户已登录。

**特点：**

*   **优点**：
    *   **安全性较高**：敏感的用户信息存储在服务端，客户端只持有 ID。
    *   **易于管理**：服务器可以随时销毁 Session（如用户注销），实现立即失效。
*   **缺点**：
    *   **服务器压力大**：需要在服务端存储所有活跃的 Session 数据，占用内存/存储空间。
    *   **可扩展性差**：在分布式系统或多台服务器部署时，需要保证 Session 数据在所有服务器间共享（如使用 Redis 集中存储），增加了复杂性。
    *   **依赖 Cookie**：如果客户端禁用 Cookie，则无法正常工作（虽然可以通过 URL 重写传递，但不安全）。

---

### 2. Token (令牌)

**核心思想：客户端存储状态**

这里的 "Token" 是一个广义概念，指代一种由服务器签发、客户端携带的凭证。JWT 是 Token 的一种具体实现。

基本流程：

1.  **用户登录**：用户提供凭证（用户名/密码）。
2.  **服务器验证并签发 Token**：
    *   服务器验证凭证正确后，生成一个 Token 字符串。
    *   这个 Token 可以是简单的随机字符串，也可以是包含加密信息的结构化数据（如 JWT）。
3.  **返回 Token 给客户端**：
    *   服务器将 Token 返回给客户端（通常放在响应体中，而不是 Cookie）。
4.  **客户端存储并发送**：
    *   客户端（如前端应用）将 Token 存储起来（常用 `localStorage` 或 `sessionStorage`）。
    *   在后续请求中，客户端需要手动将 Token 放在请求头（通常是 `Authorization: Bearer <token>`）中发送给服务器。
5.  **服务器验证**：
    *   服务器收到请求后，从请求头中提取 Token。
    *   服务器根据 Token 的类型进行验证：
        *   如果是简单随机 Token，服务器需要查询数据库或缓存（如 Redis）来确认 Token 是否有效以及对应哪个用户。
        *   如果是 JWT，服务器可以直接通过签名验证其完整性和有效性（见下文）。

**特点：**

*   **优点**：
    *   **服务端无状态**：服务器不需要存储 Token 本身（如果是 JWT），减轻了服务器存储压力。
    *   **跨域友好**：不依赖 Cookie，更容易实现跨域认证。
    *   **适合分布式系统**：天然支持多服务器部署，因为验证逻辑可以内置于 Token 中。
*   **缺点**：
    *   **Token 失效困难**：一旦签发，在过期前很难主动使其失效（除非使用黑名单机制，但这又增加了服务端存储）。JWT 尤其明显。
    *   **安全性依赖存储**：如果 Token 存储在 `localStorage`，可能面临 XSS 攻击的风险。
    *   **Token 可能较大**：尤其是 JWT，如果包含较多信息，会增加网络传输开销。

---

### 3. JWT (JSON Web Token)

**核心思想：自包含、可验证的 Token**

JWT 是 Token 的一种开放标准（RFC 7519），它定义了一种紧凑且自包含的方式，用于在各方之间安全地传输信息作为 JSON 对象。

一个 JWT 字符串通常由三部分组成，用点 `.` 分隔：

```
xxxxx.yyyyy.zzzzz
```

1.  **Header (头部)**：
    *   包含令牌的类型（即 JWT）和所使用的签名算法（如 HMAC SHA256 或 RSA）。
    *   例如：`{"alg": "HS256", "typ": "JWT"}`
2.  **Payload (负载)**：
    *   包含声明（claims），即要传输的数据。
    *   声明分为三类：
        *   **注册声明**（Registered claims）：预定义的，如 `iss` (issuer), `exp` (expiration time), `sub` (subject), `aud` (audience) 等。
        *   **公共声明**（Public claims）：可以自定义，但为了避免冲突，应该使用 URI 格式。
        *   **私有声明**（Private claims）：自定义的，用于在双方之间共享信息，如 `userId`, `role` 等。
    *   **注意**：Payload 是 Base64Url 编码的，**不是加密的**！任何人都可以解码查看内容，所以不要放敏感信息（如密码）。
3.  **Signature (签名)**：
    *   用于验证消息在传输过程中没有被更改，并且对于使用私钥签名的令牌，还可以验证 JWT 的发送方是否是它声称的那个人。
    *   签名的生成方式：对 `base64UrlEncode(header) + "." + base64UrlEncode(payload)` 这个字符串，使用 Header 中指定的算法和一个密钥（secret）进行加密。

**验证过程**：

服务器收到 JWT 后：
1.  拆分三部分。
2.  使用相同的密钥和算法，对第一部分和第二部分重新计算签名。
3.  将计算出的签名与 JWT 中的第三部分签名进行比较。
4.  如果一致，说明 Token 未被篡改；再检查 `exp` 等声明是否有效。

**特点：**

*   **优点**：
    *   **自包含**：所有必要信息都在 Token 内，服务器无需查询数据库即可验证用户身份（前提是信任签发方）。
    *   **跨语言/平台**：基于 JSON，易于在不同系统间解析。
    *   **标准化**：有明确的规范，工具库丰富。
*   **缺点**：
    *   **无法主动失效**：这是最大的痛点。一旦签发，只能等待其过期。如果需要更灵活的控制，必须结合其他机制（如短期 JWT + Refresh Token，或维护一个失效列表）。
    *   **信息暴露风险**：Payload 可被解码，不能存放敏感信息。
    *   **性能考虑**：每次请求都需要解析和验证签名，对于高并发场景，计算开销比简单的 Session ID 查找要大。

---

### 总结对比

| 特性         | Session                | Token (通用)         | JWT                          |
| :----------- | :--------------------- | :------------------- | :--------------------------- |
| **存储位置** | 服务端                 | 客户端               | 客户端                       |
| **状态性**   | 有状态                 | 无状态（理想情况）   | 无状态                       |
| **扩展性**   | 差（需共享存储）       | 好                   | 很好                         |
| **安全性**   | 较高（信息在服务端）   | 依赖实现             | 依赖签名和存储，Payload 明文 |
| **失效控制** | 容易（删除服务端记录） | 较难（需额外机制）   | 难（主要靠过期时间）         |
| **传输方式** | Cookie（自动）         | Authorization Header | Authorization Header         |
| **典型场景** | 传统 Web 应用          | API 认证、单点登录   | API 认证、微服务、单点登录   |

**选择建议**：

*   对于传统的、以页面跳转为主的 Web 应用，**Session** 仍然是简单可靠的选择。
*   对于现代的前后端分离应用、API 接口服务、移动应用后端，**Token**（特别是 **JWT**）更为流行，因为它无状态、易于扩展。
*   使用 JWT 时，务必注意设置合理的过期时间，并考虑使用 **Refresh Token** 机制来平衡安全性和用户体验。