import{_ as s,c as n,e,o as a}from"./app-ifxsENr-.js";const l={};function o(p,t){return a(),n("div",null,[...t[0]||(t[0]=[e(`<h2 id="redis的kv键值对设计" tabindex="-1"><a class="header-anchor" href="#redis的kv键值对设计"><span>Redis的kv键值对设计</span></a></h2><p><strong>命名</strong>上没什么好说的，key中前面的尽量大即可，如：<code>example:demo:token:46ASFasf6541as6</code>用层层递进的命名做成key，最后使用tokenid作为唯一标识，内部记录token对应的用户信息。</p><p><strong>长度</strong>尽量不要超过<strong>44字节</strong>，Redis中key使用<strong>String</strong>类型，底层编码包括int，<strong>embstr</strong>，raw三种，<strong>embstr在小于44字节时使用</strong>，使用<strong>连续</strong>的内存空间，需求的<strong>内存更少</strong>（超过了变成raw）（6.0是44，以前的默认更小为39）</p><p><strong>BigKey</strong>尽量避免，如String键值对大小超过5MB；zset，hash等超过1000个元素等。单键值对过大会导致<strong>网络阻塞</strong>（单次带宽不够），<strong>数据倾斜</strong>（内存中其他资源使用率过低，最好拆分），<strong>Redis阻塞</strong>（元素较多的set等一旦涉及排序等操作比较耗时），<strong>CPU压力大</strong>（数据序列化和反序列化资源要求大，提取插入Redis需要）</p><blockquote><p>我们可以通过以下方式<strong>查询</strong>BigKey：</p><p>redis -cli --bigkeys：直接遍历分析所有key，返回统计结果以及每种数据类型（String,list）的top1 BigKey</p><p>scan：自行编程实现（注意不要直接*全部提取）</p><p>第三方工具：redis-rdb-tools分析rdb文件，但是不是实时的</p><p>假如直接del一个bigkey，那也会导致一段时间的阻塞，那么这时候我们就需要去避免使用主线程来完成这样的操作，可以使用<strong>unlink</strong>使用额外的线程来完成一个BigKey的删除</p></blockquote><p>对于json类型的缓存，我们一般使用<strong>hash</strong>来存储，但是hash的field不可以太多！小的时候会使用ziplist来连续存储，所以占用空间还算比较小，大了就和hashmap一样了，真的需要的时候尽量拆分！</p><h2 id="批处理-大数据量导入导出" tabindex="-1"><a class="header-anchor" href="#批处理-大数据量导入导出"><span>批处理（大数据量导入导出）</span></a></h2><p>在我们之前的业务处理中，一般会避免对key的批量遍历，或者说从设计上就避免出现将数据拆分到多个键值对中，且一般也不会去批量获取键值对。但当我们真的需要这么一个功能时，我们很容易发现，在后端与redis之间，<strong>获取一次就需要返回一次</strong>，这样的开销是我们不希望看到的，那么有没有这样的命令能够让我们直接批量读取数据，批量一口气返回，避免这样不必要的开销呢？</p><p>我们可以使用mset来实现这样的批量插入工作，但是只能处理String类型，list不可以，且均不支持多key，那么该怎么做？</p><p>这时候，我们就需要管道了：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token class-name">Pipeline</span> p <span class="token operator">=</span> redis<span class="token punctuation">.</span><span class="token function">pipelined</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">p<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">&quot;k1&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;v1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">p<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">&quot;k2&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;v2&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">p<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">&quot;k3&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;v3&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">p<span class="token punctuation">.</span><span class="token function">sync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 一次性发送所有命令并获取结果</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><table><thead><tr><th style="text-align:left;">特性</th><th style="text-align:left;">说明</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>非原子性</strong></td><td style="text-align:left;">Pipeline 中的命令<strong>不会被原子执行</strong>（不像 <code>MULTI/EXEC</code> 事务）</td></tr><tr><td style="text-align:left;"><strong>顺序执行</strong></td><td style="text-align:left;">命令按添加顺序在 Redis 服务端依次执行</td></tr><tr><td style="text-align:left;"><strong>批量响应</strong></td><td style="text-align:left;">所有命令执行完后，一次性返回所有结果</td></tr><tr><td style="text-align:left;"><strong>节省网络开销</strong></td><td style="text-align:left;">减少 TCP 包数量和 RTT 次数</td></tr></tbody></table><p><strong>适合用 Pipeline 的场景：</strong></p><ul><li>批量导入/导出数据</li><li>初始化缓存</li><li>高频次小命令聚合</li><li>网络延迟较高的环境（如跨机房）</li></ul><blockquote><p>分片集群环境下，key会被hash并根据结果slot负载均衡键值对存储到各个节点，这里我们是只发一个请求的，那么所有的操作都会打到一个节点，这时候就有可能会丢失数据，这该怎么办？</p><p>HashTag强制将这些key给到一个节点？这可能会导致<strong>数据倾斜</strong>的问题，不考虑。</p><p>那么其实redisTemplate（lettuce）本身就为我们准备了一系列multi命令来实现对map数据的批量导入：</p><p>multiSet（批量插入）：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token annotation punctuation">@Autowired</span></span>
<span class="line"><span class="token keyword">private</span> <span class="token class-name">RedisTemplate</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> redisTemplate<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">batchSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;user:1:name&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Alice&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;user:1:age&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;25&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;user:2:name&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Bob&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;user:2:age&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;30&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token comment">// 批量设置，等价于 MSET 命令</span></span>
<span class="line">    redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">multiSet</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>multiGet（批量获取）：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token annotation punctuation">@Autowired</span></span>
<span class="line"><span class="token keyword">private</span> <span class="token class-name">RedisTemplate</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> redisTemplate<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">batchGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> keys <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">&quot;user:1:name&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;user:1:age&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;user:2:name&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token comment">// 批量获取，返回 List&lt;V&gt;</span></span>
<span class="line">    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> values <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">multiGet</span><span class="token punctuation">(</span>keys<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> keys<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>keys<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot; =&gt; &quot;</span> <span class="token operator">+</span> values<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></blockquote><h2 id="服务端优化" tabindex="-1"><a class="header-anchor" href="#服务端优化"><span>服务端优化</span></a></h2><p><strong>持久化</strong>做混合持久化，能开AOF就用AOF，RDB定期持久化。</p><p>同时设置合理的AOF的rewrite阈值，避免频繁bgrewrite（AOF文件过大会对日志做优化，同数据取最终修改结果）</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line">auto-aof-rewrite-percentage <span class="token number">100</span> <span class="token comment"># 比上次文件增长超过100%发生重写</span></span>
<span class="line">auto-aof-rewrite-min-size 64mb <span class="token comment"># AOF文件最小多大才会触发重写</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>禁止rewrite期间aof，配置no-appendfsync-on-rewrite = yes（追求性能就禁止，可能会导致aof日志并非最新数据）</p><blockquote><p>谨慎关闭持久化，不是因为持久化真的怎么怎么重要，而是无法预测可能存在的困境（避免背锅），不是特别追求性能而且还资源吃紧，能不关就不关。</p></blockquote><p><strong>部署方面</strong>单节点内存不要过大，可能会使得同步压力过大（一般推荐4~8G，存疑，根据实际情况来）。</p><p>尽量避免与其他服务（数据库，MQ）部署在一起。</p><p><strong>慢查询</strong>：尽管 Redis 大部分操作是 O(1) 或 O(log N)，但以下情况会导致命令执行时间过长：</p><table><thead><tr><th style="text-align:left;">原因</th><th style="text-align:left;">示例</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>大数据结构操作</strong></td><td style="text-align:left;">对一个包含 100 万个元素的 <code>List</code> 执行 <code>LRANGE 0 -1</code></td></tr><tr><td style="text-align:left;"><strong>高复杂度命令</strong></td><td style="text-align:left;"><code>KEYS *</code>（全库扫描）、<code>SMEMBERS big_set</code>、<code>HGETALL huge_hash</code></td></tr><tr><td style="text-align:left;"><strong>阻塞命令</strong></td><td style="text-align:left;"><code>BLPOP</code>、<code>BRPOP</code>（虽不消耗 CPU，但会阻塞连接）</td></tr><tr><td style="text-align:left;"><strong>Lua 脚本过长</strong></td><td style="text-align:left;">在 Lua 中循环处理大量数据</td></tr><tr><td style="text-align:left;"><strong>持久化/内存回收干扰</strong></td><td style="text-align:left;">虽然不属于命令本身，但可能影响观测</td></tr></tbody></table><blockquote><p>⚠️ Redis 是<strong>单线程处理命令</strong>（6.0+ 有部分多线程 I/O，但命令执行仍是单线程），<strong>一个慢命令会阻塞后续所有请求！</strong></p></blockquote><p>可以通过配置一定程度上借助redis本身的慢查询日志记录这些操作并在后续优化：</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line"><span class="token comment"># 执行时间超过多少微秒（μs）记录为慢查询（默认 10000 = 10ms，根据实际场景修改）</span></span>
<span class="line">slowlog-log-slower-than <span class="token number">10000</span></span>
<span class="line"></span>
<span class="line"><span class="token comment"># 最多保存多少条慢查询记录（先进先出，默认 128，根据实际场景修改，建议延长为1000）</span></span>
<span class="line">slowlog-max-len <span class="token number">128</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出日志：</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line"><span class="token comment"># 获取最近 10 条慢查询</span></span>
<span class="line">SLOWLOG GET <span class="token number">10</span></span>
<span class="line"></span>
<span class="line"><span class="token comment"># 获取慢查询总数</span></span>
<span class="line">SLOWLOG LEN</span>
<span class="line"></span>
<span class="line"><span class="token comment"># 清空慢查询日志</span></span>
<span class="line">SLOWLOG RESET</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="内存占用情况检查" tabindex="-1"><a class="header-anchor" href="#内存占用情况检查"><span>内存占用情况检查</span></a></h2><p>连接到redis后可以使用info命令查询使用情况，比方说使用info memory检查内存使用情况</p><table><thead><tr><th style="text-align:left;">类别（Section）</th><th style="text-align:left;">主要内容说明</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>Server</strong></td><td style="text-align:left;">Redis 服务器版本、运行模式、端口、PID、启动时间等基本信息</td></tr><tr><td style="text-align:left;"><strong>Clients</strong></td><td style="text-align:left;">当前客户端连接数、阻塞客户端数、最大连接限制等</td></tr><tr><td style="text-align:left;"><strong>Memory</strong></td><td style="text-align:left;">内存使用情况（重点！见下方详细表）</td></tr><tr><td style="text-align:left;"><strong>Persistence</strong></td><td style="text-align:left;">RDB/AOF 持久化状态、最近保存时间、AOF 重写状态等</td></tr><tr><td style="text-align:left;"><strong>Stats</strong></td><td style="text-align:left;">命令统计、命中率、网络流量、拒绝连接数、过期 key 数等</td></tr><tr><td style="text-align:left;"><strong>Replication</strong></td><td style="text-align:left;">主从复制状态、从节点信息、偏移量等</td></tr><tr><td style="text-align:left;"><strong>CPU</strong></td><td style="text-align:left;">Redis 主进程和后台进程的 CPU 使用率</td></tr><tr><td style="text-align:left;"><strong>Modules</strong></td><td style="text-align:left;">加载的模块信息（如 RediSearch、RedisJSON 等）</td></tr><tr><td style="text-align:left;"><strong>Keyspace</strong></td><td style="text-align:left;">各数据库中 key 的数量、带过期时间的 key 数量</td></tr></tbody></table><blockquote><p>💡 可通过 <code>INFO &lt;section&gt;</code> 查看指定部分，如：</p><ul><li><code>INFO memory</code></li><li><code>INFO clients</code></li><li><code>INFO stats</code></li></ul></blockquote><p>最常使用的内存：</p><table><thead><tr><th style="text-align:left;">字段</th><th style="text-align:left;">说明</th><th style="text-align:left;">单位</th><th style="text-align:left;">关注建议</th></tr></thead><tbody><tr><td style="text-align:left;"><code>used_memory</code></td><td style="text-align:left;">Redis <strong>分配器</strong>（如 jemalloc）分配的内存总量</td><td style="text-align:left;">bytes</td><td style="text-align:left;">核心指标，反映 Redis 实际使用的内存量</td></tr><tr><td style="text-align:left;"><code>used_memory_human</code></td><td style="text-align:left;"><code>used_memory</code> 的可读格式（如 10.5M）</td><td style="text-align:left;">—</td><td style="text-align:left;">便于人工查看</td></tr><tr><td style="text-align:left;"><code>used_memory_rss</code></td><td style="text-align:left;">Redis 进程 <strong>操作系统层面</strong> 占用的物理内存（Resident Set Size）</td><td style="text-align:left;">bytes</td><td style="text-align:left;">若远大于 <code>used_memory</code>，可能存在内存碎片</td></tr><tr><td style="text-align:left;"><code>used_memory_rss_human</code></td><td style="text-align:left;"><code>used_memory_rss</code> 的可读格式</td><td style="text-align:left;">—</td><td style="text-align:left;">—</td></tr><tr><td style="text-align:left;"><code>used_memory_peak</code></td><td style="text-align:left;">Redis 历史峰值内存使用量</td><td style="text-align:left;">bytes</td><td style="text-align:left;">判断是否接近内存上限</td></tr><tr><td style="text-align:left;"><code>used_memory_peak_human</code></td><td style="text-align:left;">峰值内存的可读格式</td><td style="text-align:left;">—</td><td style="text-align:left;">—</td></tr><tr><td style="text-align:left;"><code>used_memory_peak_perc</code></td><td style="text-align:left;">当前内存 / 峰值内存 的百分比</td><td style="text-align:left;">%</td><td style="text-align:left;">如 <code>85.23%</code>，反映内存使用趋势</td></tr><tr><td style="text-align:left;"><code>used_memory_overhead</code></td><td style="text-align:left;">Redis <strong>内部开销</strong>（key 结构、客户端缓冲区、主从复制缓存等）</td><td style="text-align:left;">bytes</td><td style="text-align:left;">= 总内存 - 数据实际存储内存</td></tr><tr><td style="text-align:left;"><code>used_memory_startup</code></td><td style="text-align:left;">Redis 启动时的基础内存消耗（空实例）</td><td style="text-align:left;">bytes</td><td style="text-align:left;">可估算纯数据占用：<code>used_memory - used_memory_startup</code></td></tr><tr><td style="text-align:left;"><code>used_memory_dataset</code></td><td style="text-align:left;"><strong>实际数据集</strong>占用的内存（≈ <code>used_memory - used_memory_overhead</code>）</td><td style="text-align:left;">bytes</td><td style="text-align:left;">关注数据真实大小</td></tr><tr><td style="text-align:left;"><code>used_memory_dataset_perc</code></td><td style="text-align:left;">数据集内存占（总内存 - 启动内存）的百分比</td><td style="text-align:left;">%</td><td style="text-align:left;">越高说明内存利用率越好</td></tr><tr><td style="text-align:left;"><code>allocator_allocated</code></td><td style="text-align:left;">底层内存分配器（如 jemalloc）已分配的内存</td><td style="text-align:left;">bytes</td><td style="text-align:left;">通常 ≈ <code>used_memory</code></td></tr><tr><td style="text-align:left;"><code>allocator_active</code></td><td style="text-align:left;">分配器当前活跃的内存页</td><td style="text-align:left;">bytes</td><td style="text-align:left;">—</td></tr><tr><td style="text-align:left;"><code>allocator_resident</code></td><td style="text-align:left;">分配器驻留物理内存</td><td style="text-align:left;">bytes</td><td style="text-align:left;">—</td></tr><tr><td style="text-align:left;"><code>total_system_memory</code></td><td style="text-align:left;">系统总物理内存</td><td style="text-align:left;">bytes</td><td style="text-align:left;">判断 Redis 是否过度占用系统资源</td></tr><tr><td style="text-align:left;"><code>total_system_memory_human</code></td><td style="text-align:left;">系统总内存可读格式</td><td style="text-align:left;">—</td><td style="text-align:left;">—</td></tr><tr><td style="text-align:left;"><code>used_memory_lua</code></td><td style="text-align:left;">Lua 脚本引擎占用的内存</td><td style="text-align:left;">bytes</td><td style="text-align:left;">默认 32KB，若过高需检查脚本</td></tr><tr><td style="text-align:left;"><code>used_memory_scripts</code></td><td style="text-align:left;">缓存的 Lua 脚本本身占用内存</td><td style="text-align:left;">bytes</td><td style="text-align:left;">—</td></tr><tr><td style="text-align:left;"><code>number_of_cached_scripts</code></td><td style="text-align:left;">缓存的 Lua 脚本数量</td><td style="text-align:left;">—</td><td style="text-align:left;">—</td></tr><tr><td style="text-align:left;"><code>maxmemory</code></td><td style="text-align:left;">配置的 <code>maxmemory</code> 限制（0 表示无限制）</td><td style="text-align:left;">bytes</td><td style="text-align:left;">决定是否触发淘汰策略</td></tr><tr><td style="text-align:left;"><code>maxmemory_human</code></td><td style="text-align:left;"><code>maxmemory</code> 可读格式</td><td style="text-align:left;">—</td><td style="text-align:left;">—</td></tr><tr><td style="text-align:left;"><code>maxmemory_policy</code></td><td style="text-align:left;">内存达到上限时的淘汰策略（如 <code>noeviction</code>, <code>allkeys-lru</code>）</td><td style="text-align:left;">—</td><td style="text-align:left;"><strong>关键配置！</strong></td></tr><tr><td style="text-align:left;"><code>mem_fragmentation_ratio</code></td><td style="text-align:left;"><strong>内存碎片率</strong> = <code>used_memory_rss / used_memory</code></td><td style="text-align:left;">无单位</td><td style="text-align:left;"><strong>理想值：1～1.5</strong> • &gt;1.5：碎片严重 • &lt;1：可能使用了 swap（危险！）</td></tr><tr><td style="text-align:left;"><code>mem_not_counted_for_evict</code></td><td style="text-align:left;">不参与淘汰计算的内存（如 AOF 缓冲区）</td><td style="text-align:left;">bytes</td><td style="text-align:left;">—</td></tr><tr><td style="text-align:left;"><code>mem_replication_backlog</code></td><td style="text-align:left;">复制积压缓冲区（replication backlog）大小</td><td style="text-align:left;">bytes</td><td style="text-align:left;">主从断连后能否增量同步的关键</td></tr><tr><td style="text-align:left;"><code>mem_clients_slaves</code></td><td style="text-align:left;">所有从节点客户端缓冲区占用内存</td><td style="text-align:left;">bytes</td><td style="text-align:left;">从节点多时可能较大</td></tr><tr><td style="text-align:left;"><code>mem_clients_normal</code></td><td style="text-align:left;">普通客户端缓冲区占用内存</td><td style="text-align:left;">bytes</td><td style="text-align:left;">客户端发送大请求或消费慢会导致堆积</td></tr><tr><td style="text-align:left;"><code>mem_aof_buffer</code></td><td style="text-align:left;">AOF 缓冲区大小</td><td style="text-align:left;">bytes</td><td style="text-align:left;">AOF 开启时存在</td></tr><tr><td style="text-align:left;"><code>mem_allocator</code></td><td style="text-align:left;">使用的内存分配器（如 <code>jemalloc-5.1.0</code>）</td><td style="text-align:left;">—</td><td style="text-align:left;">jemalloc 是默认且推荐的</td></tr><tr><td style="text-align:left;"><code>active_defrag_running</code></td><td style="text-align:left;">是否正在执行主动碎片整理（1=是）</td><td style="text-align:left;">bool</td><td style="text-align:left;">Redis 4.0+ 支持</td></tr><tr><td style="text-align:left;"><code>lazyfree_pending_objects</code></td><td style="text-align:left;">等待异步释放的对象数量（如 <code>UNLINK</code>）</td><td style="text-align:left;">count</td><td style="text-align:left;">&gt;0 表示有后台释放任务</td></tr></tbody></table><h2 id="分片集群还是主从集群" tabindex="-1"><a class="header-anchor" href="#分片集群还是主从集群"><span>分片集群还是主从集群</span></a></h2><p>分片集群支持不同的主节点（和他的从节点）负责存储不同的数据，提高的缓存数据的存储能力（主从集群都存一份同样的），在资源充足的前提下，能力确实是比主从集群的空间利用效率高的，但是除了吃资源，还有一些缺点：</p><p>一旦有插槽slot不可用，集群就停止服务了。</p><p>同步开销大，心跳包确认健康开销大（规模上来了，主节点之间量比哨兵大）。</p><blockquote><p>主从能干，尽量就不要使用分片</p></blockquote>`,41)])])}const d=s(l,[["render",o]]),c=JSON.parse('{"path":"/docs/heimadianping/gaojipian/3.zuijiashijian.html","title":"最佳实践","lang":"en-US","frontmatter":{"title":"最佳实践","date":"2026-1-27"},"headers":[{"level":2,"title":"Redis的kv键值对设计","slug":"redis的kv键值对设计","link":"#redis的kv键值对设计","children":[]},{"level":2,"title":"批处理（大数据量导入导出）","slug":"批处理-大数据量导入导出","link":"#批处理-大数据量导入导出","children":[]},{"level":2,"title":"服务端优化","slug":"服务端优化","link":"#服务端优化","children":[]},{"level":2,"title":"内存占用情况检查","slug":"内存占用情况检查","link":"#内存占用情况检查","children":[]},{"level":2,"title":"分片集群还是主从集群","slug":"分片集群还是主从集群","link":"#分片集群还是主从集群","children":[]}],"git":{"createdTime":1771171838000,"updatedTime":1771171838000,"contributors":[{"name":"SaltFishGC","email":"130335482+SaltFishGC@users.noreply.github.com","commits":1}]},"filePathRelative":"docs/黑马点评/高级篇/3.最佳实践.md"}');export{d as comp,c as data};
