import{_ as l,c as o,e as p,a as n,b as a,d as t,r as i,o as c}from"./app-DI6YVXtA.js";const r={},d={href:"https://mybatis.org/mybatis-3/zh_CN/sqlmap-xml.html",target:"_blank",rel:"noopener noreferrer"},u={href:"https://blog.csdn.net/qq_42402854/article/details/102588984",target:"_blank",rel:"noopener noreferrer"},k={href:"https://blog.csdn.net/Ying_ph/article/details/133199468",target:"_blank",rel:"noopener noreferrer"},h={href:"https://developer.aliyun.com/article/1620394",target:"_blank",rel:"noopener noreferrer"};function v(g,s){const e=i("ExternalLinkIcon");return c(),o("div",null,[s[6]||(s[6]=p(`<h3 id="什么是枚举" tabindex="-1"><a class="header-anchor" href="#什么是枚举"><span>什么是枚举？</span></a></h3><p><strong>枚举（Enumeration，简称 Enum）</strong> 是一种特殊的类，用于定义一组<strong>固定的、有限的常量集合</strong>。它让程序中的常量管理更安全、更清晰、更易维护。</p><h4 id="🌰-举个生活中的例子" tabindex="-1"><a class="header-anchor" href="#🌰-举个生活中的例子"><span>🌰 举个生活中的例子：</span></a></h4><p>比如“一周的星期”只有 7 天：星期一、星期二……星期日。<br> 我们可以用数字 <code>1~7</code> 表示，但这样容易出错（比如传了 <code>8</code>），也不直观。</p><p>使用枚举，就可以这样定义：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">DayOfWeek</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token constant">MONDAY</span><span class="token punctuation">,</span> <span class="token constant">TUESDAY</span><span class="token punctuation">,</span> <span class="token constant">WEDNESDAY</span><span class="token punctuation">,</span> <span class="token constant">THURSDAY</span><span class="token punctuation">,</span> <span class="token constant">FRIDAY</span><span class="token punctuation">,</span> <span class="token constant">SATURDAY</span><span class="token punctuation">,</span> <span class="token constant">SUNDAY</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后这样使用：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token class-name">DayOfWeek</span> today <span class="token operator">=</span> <span class="token class-name">DayOfWeek</span><span class="token punctuation">.</span><span class="token constant">MONDAY</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这样，<code>today</code> 的值只能是 <code>MONDAY</code> 到 <code>SUNDAY</code> 中的一个，<strong>不可能是其他值</strong>，非常安全。</p><hr><h4 id="✅-枚举的优点" tabindex="-1"><a class="header-anchor" href="#✅-枚举的优点"><span>✅ 枚举的优点</span></a></h4><table><thead><tr><th>优点</th><th>说明</th></tr></thead><tbody><tr><td><strong>类型安全</strong></td><td>只能取枚举中定义的值，不能随意赋值</td></tr><tr><td><strong>可读性强</strong></td><td>代码更清晰，一看就知道是什么意思</td></tr><tr><td><strong>避免魔法值</strong></td><td>避免使用 <code>0</code>, <code>1</code>, <code>&quot;male&quot;</code>, <code>&quot;female&quot;</code> 这样的“魔法字符串/数字”</td></tr><tr><td><strong>可扩展</strong></td><td>枚举可以有构造方法、字段、方法，甚至实现接口</td></tr></tbody></table><hr><h4 id="🧩-java-中枚举的基本语法" tabindex="-1"><a class="header-anchor" href="#🧩-java-中枚举的基本语法"><span>🧩 Java 中枚举的基本语法</span></a></h4><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">Status</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// 枚举常量（通常大写）</span></span>
<span class="line">    <span class="token constant">PENDING</span><span class="token punctuation">,</span>   <span class="token comment">// 待处理</span></span>
<span class="line">    <span class="token constant">SUCCESS</span><span class="token punctuation">,</span>   <span class="token comment">// 成功</span></span>
<span class="line">    <span class="token constant">FAILED</span>     <span class="token comment">// 失败</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token class-name">Status</span> status <span class="token operator">=</span> <span class="token class-name">Status</span><span class="token punctuation">.</span><span class="token constant">SUCCESS</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">if</span> <span class="token punctuation">(</span>status <span class="token operator">==</span> <span class="token class-name">Status</span><span class="token punctuation">.</span><span class="token constant">SUCCESS</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;操作成功！&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h4 id="🔧-枚举的高级用法-带属性和方法" tabindex="-1"><a class="header-anchor" href="#🔧-枚举的高级用法-带属性和方法"><span>🔧 枚举的高级用法（带属性和方法）</span></a></h4><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">Gender</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token function">MALE</span><span class="token punctuation">(</span><span class="token string">&quot;m&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;男&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span></span>
<span class="line">    <span class="token function">FEMALE</span><span class="token punctuation">(</span><span class="token string">&quot;f&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;女&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">private</span> <span class="token class-name">String</span> code<span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token class-name">String</span> desc<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token comment">// 构造方法</span></span>
<span class="line">    <span class="token class-name">Gender</span><span class="token punctuation">(</span><span class="token class-name">String</span> code<span class="token punctuation">,</span> <span class="token class-name">String</span> desc<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">this</span><span class="token punctuation">.</span>code <span class="token operator">=</span> code<span class="token punctuation">;</span></span>
<span class="line">        <span class="token keyword">this</span><span class="token punctuation">.</span>desc <span class="token operator">=</span> desc<span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token comment">// getter 方法</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> code<span class="token punctuation">;</span> <span class="token punctuation">}</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getDesc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> desc<span class="token punctuation">;</span> <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token comment">// 根据 code 查找枚举</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Gender</span> <span class="token function">fromCode</span><span class="token punctuation">(</span><span class="token class-name">String</span> code<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Gender</span> g <span class="token operator">:</span> <span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">            <span class="token keyword">if</span> <span class="token punctuation">(</span>g<span class="token punctuation">.</span>code<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>code<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">                <span class="token keyword">return</span> g<span class="token punctuation">;</span></span>
<span class="line">            <span class="token punctuation">}</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line">        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">&quot;未知的性别代码: &quot;</span> <span class="token operator">+</span> code<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token class-name">Gender</span> gender <span class="token operator">=</span> <span class="token class-name">Gender</span><span class="token punctuation">.</span><span class="token function">fromCode</span><span class="token punctuation">(</span><span class="token string">&quot;m&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>gender<span class="token punctuation">.</span><span class="token function">getDesc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出：男</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><hr><h4 id="📌-常见使用场景" tabindex="-1"><a class="header-anchor" href="#📌-常见使用场景"><span>📌 常见使用场景</span></a></h4><ol><li><strong>状态码</strong>：如订单状态（待支付、已支付、已发货）</li><li><strong>类型标识</strong>：如用户类型（普通用户、VIP、管理员）</li><li><strong>配置项</strong>：如消息类型（系统消息、通知、私信）</li><li><strong>开关选项</strong>：如是否启用（ENABLED, DISABLED）</li></ol><hr><h4 id="⚠️-注意事项" tabindex="-1"><a class="header-anchor" href="#⚠️-注意事项"><span>⚠️ 注意事项</span></a></h4><ul><li>枚举类不能被继承（隐式 <code>final</code>）</li><li>枚举常量必须写在最前面</li><li><code>values()</code> 方法返回所有枚举值数组</li><li><code>valueOf(&quot;XXX&quot;)</code> 可以根据名字获取枚举（区分大小写）</li></ul><blockquote><p><strong>枚举 = 一组命名的常量 + 类的特性</strong></p></blockquote><hr><h3 id="如何避免生成用户id时的重复问题" tabindex="-1"><a class="header-anchor" href="#如何避免生成用户id时的重复问题"><span>如何避免生成用户ID时的重复问题</span></a></h3><p>**指向：**userinfo register业务</p><p>体量小直接随机就行，但体量大了怎么办？</p><h3 id="如何实现登录挤掉其他正在使用该账户的人" tabindex="-1"><a class="header-anchor" href="#如何实现登录挤掉其他正在使用该账户的人"><span>如何实现登录挤掉其他正在使用该账户的人？</span></a></h3><p>**指向：**userinfo login业务</p><p>被卡死难道还要打电话求救管理员？</p><ol><li>输入安全密钥冻结账号</li></ol><h3 id="跨域了怎么办-实际情况下怎么处理最妥当" tabindex="-1"><a class="header-anchor" href="#跨域了怎么办-实际情况下怎么处理最妥当"><span>跨域了怎么办？实际情况下怎么处理最妥当？</span></a></h3><h3 id="怎么检查表头比较好-拦截器还是aop-怎么实现" tabindex="-1"><a class="header-anchor" href="#怎么检查表头比较好-拦截器还是aop-怎么实现"><span>怎么检查表头比较好？拦截器还是AOP？怎么实现？</span></a></h3><p>AOP我们可以使用Around一种自定义注解的方式来实现对指定方法的拦截检查，这种方式适合灵活复杂的场景，当然也可以统一使用通配符来匹配，比如：<code>@Around(&quot;execution(* com.example.service.*.*(..))&quot;)</code></p><h3 id="拦截器和aop一块使用的情况下会冲突吗-执行顺序是什么" tabindex="-1"><a class="header-anchor" href="#拦截器和aop一块使用的情况下会冲突吗-执行顺序是什么"><span>拦截器和AOP一块使用的情况下会冲突吗？执行顺序是什么？</span></a></h3><h3 id="事务失效" tabindex="-1"><a class="header-anchor" href="#事务失效"><span>事务失效</span></a></h3><p>在使用 AOP（面向切面编程）和事务管理时，有几个关键的注意事项需要特别关注。这些注意事项主要涉及 Spring 的事务管理机制、AOP 代理的工作原理以及它们之间的交互。最重要的一点就是避免自调用（<strong>自调用会导致绕过AOP的代理，使用原始对象this.method()，而此时原始对象的事务是基于一个代理实现的，而我们现在使用的方式this指针会使得那个代理无法被触发从而导致事务回滚失效</strong>）举个例子：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token annotation punctuation">@Service</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyService</span> <span class="token punctuation">{</span></span>
<span class="line"></span>
<span class="line">     <span class="token annotation punctuation">@Transactional</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">methodB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        userRepository<span class="token punctuation">.</span><span class="token function">save</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token string">&quot;Alice&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">&quot;出错！&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">methodA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token function">methodB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里我们看到B方法被A方法在一个Bean对象内自调用，此时this指针指向<strong>原始方法</strong>而非事务注解实现的<strong>代理</strong>，导致事务注解失效，在完成save之后，<strong>sql会直接提交</strong>，即便后续抛出了异常，也不会回滚！！！</p><p>但注意！如果你在外部直接调用了B方法而非A方法，事务仍旧生效，这一点请不要搞错。</p><p>再来看这个：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token annotation punctuation">@Service</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyService</span> <span class="token punctuation">{</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">methodB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        userRepository<span class="token punctuation">.</span><span class="token function">save</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token string">&quot;Alice&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">&quot;出错！&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token annotation punctuation">@Transactional</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">methodA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        orderRepository<span class="token punctuation">.</span><span class="token function">save</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Order</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token function">methodB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调用无事务注解的方法</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这时调用方法A，方法B的内容也会加入事务，发生了异常后是可以回滚的！</p><p>当然如果你直接调用了方法A那肯定是回滚不了了。</p><p>还有就是两个方法都有事务注解，那么答案也很明显，被调用的事务注解失效，外层的方法事务依旧生效，发生异常也还是可以回滚的。</p><p>所以我们需要避免的情况只有一种，那就是一个未被事务注解的方法自调用了一个事务注解的方法导致该方法事务注解失效无法回滚，且最终回溯到最外层均没有事务注解，这时就完全不会发生异常回滚了。其他情况只要保证不去调用一个连事务注解都没有的方法，就不会发生意外了。几种事务失效的情况：</p><p><strong>内部方法调用导致事务失效</strong></p><p><strong>非<code>public</code>方法上的事务注解</strong></p><p><strong>异常处理不当导致事务未回滚（如aspect吞掉了异常</strong></p><p><strong>事务传播行为（Propagation）配置错误</strong></p><p><strong>事务超时（<code>timeout</code>）属性的误用与限制</strong></p><p>下面我们将详细探讨一些基础知识：</p><h4 id="_1-理解-spring-事务管理的基础" tabindex="-1"><a class="header-anchor" href="#_1-理解-spring-事务管理的基础"><span>1. <strong>理解 Spring 事务管理的基础</strong></span></a></h4><p>Spring 提供了声明式事务管理，通常通过 <code>@Transactional</code> 注解来实现。这个注解可以应用到类级别或方法级别，用于定义事务边界。当一个方法被标记为 <code>@Transactional</code>，Spring 将会在该方法执行前开始一个新的事务（如果还没有事务存在的话），并在方法成功完成后提交事务；如果方法抛出异常，则会回滚事务。</p><h4 id="_2-自调用问题-self-invocation-issue" tabindex="-1"><a class="header-anchor" href="#_2-自调用问题-self-invocation-issue"><span>2. <strong>自调用问题（Self-invocation Issue）</strong></span></a></h4><p>这是 AOP 和事务管理中一个常见的陷阱。当你在一个 Bean 内部直接调用另一个带有 <code>@Transactional</code> 注解的方法时，事务不会生效。这是因为 Spring AOP 是基于代理的，内部调用并不会经过代理对象，所以事务管理也不会被触发。</p><p><strong>解决方案：</strong></p><ul><li>尽量避免在同一个 Bean 中进行自我调用，换到另一个Bean中调用。</li><li>如果必须这样做，可以通过 <code>AopContext.currentProxy()</code> 获取当前代理对象，并通过它来调用目标方法。</li></ul><h4 id="_3-事务传播行为-propagation-behavior" tabindex="-1"><a class="header-anchor" href="#_3-事务传播行为-propagation-behavior"><span>3. <strong>事务传播行为（Propagation Behavior）</strong></span></a></h4><p>Spring 支持多种事务传播行为，如 <code>REQUIRED</code>, <code>REQUIRES_NEW</code>, <code>SUPPORTS</code>, <code>NOT_SUPPORTED</code>, <code>MANDATORY</code>, <code>NEVER</code>, <code>NESTED</code>。选择正确的传播行为对于确保事务正确处理至关重要。</p><p>例如：</p><ul><li><code>REQUIRED</code>（默认）：如果当前存在事务，则加入该事务；如果没有事务，则创建新事务。</li><li><code>REQUIRES_NEW</code>：总是创建新的事务，并挂起当前事务（如果有）。</li></ul><h4 id="_4-异常处理与事务回滚" tabindex="-1"><a class="header-anchor" href="#_4-异常处理与事务回滚"><span>4. <strong>异常处理与事务回滚</strong></span></a></h4><p>默认情况下，只有未检查异常（即运行时异常及其子类）会导致事务回滚。如果你想让事务在检查异常（如 <code>SQLException</code>）发生时也回滚，需要显式指定：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>rollbackFor <span class="token operator">=</span> <span class="token class-name">Exception</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">someMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// 方法逻辑</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此外，还可以使用 <code>noRollbackFor</code> 属性来指定哪些异常不应导致回滚。</p><h3 id="threadlocal是什么-怎么用" tabindex="-1"><a class="header-anchor" href="#threadlocal是什么-怎么用"><span>ThreadLocal是什么？怎么用？</span></a></h3><p><code>ThreadLocal</code> 本身是 Java 标准库（<code>java.lang.ThreadLocal</code>）中的一个类，它并不是 Spring Boot 特有的。但是，在 Spring Boot 应用中，由于其多线程处理请求的特性（每个 HTTP 请求通常由一个独立的线程处理），<code>ThreadLocal</code> 成为了一个非常有用且常用的工具，用于在同一线程内跨方法、跨组件传递数据，同时保证数据的线程隔离性。</p><hr><h4 id="一、什么是-threadlocal" tabindex="-1"><a class="header-anchor" href="#一、什么是-threadlocal"><span>一、什么是 ThreadLocal？</span></a></h4><p><strong>核心概念：</strong><code>ThreadLocal</code> 为每个使用它的线程提供一个独立的变量副本。这意味着每个线程都可以独立地改变自己的副本，而不会影响其他线程所对应的副本。</p><p>你可以把它想象成一个“线程级别的局部变量”，但它实际上是一个映射（Map），其中：</p><ul><li><strong>Key</strong>：当前线程（<code>Thread</code> 对象）</li><li><strong>Value</strong>：该线程绑定的变量值</li></ul><p><strong>简单来说：</strong></p><blockquote><p><code>ThreadLocal</code> 让你在同一个线程中，可以在任何地方获取到你之前设置的数据，就像这个数据是“全局”的，但只对当前线程可见。</p></blockquote><hr><h4 id="二、为什么在-spring-boot-中使用-threadlocal" tabindex="-1"><a class="header-anchor" href="#二、为什么在-spring-boot-中使用-threadlocal"><span>二、为什么在 Spring Boot 中使用 ThreadLocal？</span></a></h4><p>Spring Boot 应用通常是基于 Servlet 容器（如 Tomcat）运行的，容器会使用线程池来处理并发请求。每个 HTTP 请求由一个线程处理，处理完毕后线程会被放回池中等待下一个任务。</p><p>在这种场景下，<code>ThreadLocal</code> 的优势就体现出来了：</p><ol><li><p><strong>线程安全的数据传递</strong>：</p><ul><li>在一次请求处理过程中，可能需要经过多个 Service、DAO 层。</li><li>如果你想在整个请求链路中传递一些上下文信息（如用户 ID、请求 ID、认证信息等），通过参数层层传递非常麻烦。</li><li>使用 <code>ThreadLocal</code>，你可以在请求开始时（如在拦截器或过滤器中）设置这些信息，后续所有方法都可以直接从 <code>ThreadLocal</code> 中获取，无需传参。</li></ul></li><li><p><strong>避免重复创建对象</strong>：</p><ul><li>某些对象（如数据库连接、SimpleDateFormat）创建开销较大，且不是线程安全的。</li><li>可以将它们存储在 <code>ThreadLocal</code> 中，每个线程拥有自己的实例，既节省资源又保证线程安全。</li></ul></li><li><p><strong>实现上下文管理</strong>：</p><ul><li>Spring 自身也大量使用 <code>ThreadLocal</code> 来管理事务、安全上下文（如 <code>SecurityContextHolder</code>）等。</li></ul></li></ol><hr><h4 id="三、如何使用-threadlocal" tabindex="-1"><a class="header-anchor" href="#三、如何使用-threadlocal"><span>三、如何使用 ThreadLocal？</span></a></h4><h5 id="基本用法" tabindex="-1"><a class="header-anchor" href="#基本用法"><span>基本用法</span></a></h5><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token comment">// 1. 创建一个 ThreadLocal 实例（通常作为静态变量）</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserContext</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> userIdHolder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    </span>
<span class="line">    <span class="token comment">// 设置当前线程的用户ID</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">setUserId</span><span class="token punctuation">(</span><span class="token class-name">String</span> userId<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        userIdHolder<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>userId<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">    </span>
<span class="line">    <span class="token comment">// 获取当前线程的用户ID</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">getUserId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">return</span> userIdHolder<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">    </span>
<span class="line">    <span class="token comment">// 清除当前线程的用户ID（非常重要！）</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        userIdHolder<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="在-spring-boot-中的实际应用示例" tabindex="-1"><a class="header-anchor" href="#在-spring-boot-中的实际应用示例"><span>在 Spring Boot 中的实际应用示例</span></a></h5><h6 id="场景-记录每次请求的唯一-id-和用户信息" tabindex="-1"><a class="header-anchor" href="#场景-记录每次请求的唯一-id-和用户信息"><span>场景：记录每次请求的唯一 ID 和用户信息</span></a></h6><ol><li><strong>定义 ThreadLocal 工具类</strong></li></ol><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token annotation punctuation">@Component</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RequestContext</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// 存储请求ID</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> requestIdHolder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token comment">// 存储用户ID</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> userIdHolder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setRequestId</span><span class="token punctuation">(</span><span class="token class-name">String</span> requestId<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        requestIdHolder<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>requestId<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getRequestId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">return</span> requestIdHolder<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setUserId</span><span class="token punctuation">(</span><span class="token class-name">String</span> userId<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        userIdHolder<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>userId<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getUserId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">return</span> userIdHolder<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        requestIdHolder<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        userIdHolder<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li><strong>创建拦截器或过滤器，在请求开始时设置，结束时清除</strong></li></ol><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token annotation punctuation">@Component</span></span>
<span class="line"><span class="token annotation punctuation">@Order</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// 确保优先级</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RequestContextInterceptor</span> <span class="token keyword">implements</span> <span class="token class-name">HandlerInterceptor</span> <span class="token punctuation">{</span></span>
<span class="line"></span>
<span class="line">    <span class="token annotation punctuation">@Autowired</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token class-name">RequestContext</span> requestContext<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token annotation punctuation">@Override</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">preHandle</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> response<span class="token punctuation">,</span> <span class="token class-name">Object</span> handler<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token comment">// 生成请求ID</span></span>
<span class="line">        <span class="token class-name">String</span> requestId <span class="token operator">=</span> <span class="token constant">UUID</span><span class="token punctuation">.</span><span class="token function">randomUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token comment">// 假设从 Header 或 Token 中解析用户ID</span></span>
<span class="line">        <span class="token class-name">String</span> userId <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getHeader</span><span class="token punctuation">(</span><span class="token string">&quot;X-User-Id&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </span>
<span class="line">        <span class="token keyword">if</span> <span class="token punctuation">(</span>userId <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> userId <span class="token operator">=</span> <span class="token string">&quot;anonymous&quot;</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">        <span class="token comment">// 设置到 ThreadLocal</span></span>
<span class="line">        requestContext<span class="token punctuation">.</span><span class="token function">setRequestId</span><span class="token punctuation">(</span>requestId<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        requestContext<span class="token punctuation">.</span><span class="token function">setUserId</span><span class="token punctuation">(</span>userId<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Request started: ID=&quot;</span> <span class="token operator">+</span> requestId <span class="token operator">+</span> <span class="token string">&quot;, User=&quot;</span> <span class="token operator">+</span> userId<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token annotation punctuation">@Override</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">afterCompletion</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> response<span class="token punctuation">,</span> <span class="token class-name">Object</span> handler<span class="token punctuation">,</span> <span class="token class-name">Exception</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token comment">// 关键：必须清除！防止内存泄漏和脏数据</span></span>
<span class="line">        requestContext<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Request completed, ThreadLocal cleared.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3"><li><strong>注册拦截器</strong></li></ol><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token annotation punctuation">@Configuration</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WebConfig</span> <span class="token keyword">implements</span> <span class="token class-name">WebMvcConfigurer</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token annotation punctuation">@Autowired</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token class-name">RequestContextInterceptor</span> requestContextInterceptor<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token annotation punctuation">@Override</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addInterceptors</span><span class="token punctuation">(</span><span class="token class-name">InterceptorRegistry</span> registry<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        registry<span class="token punctuation">.</span><span class="token function">addInterceptor</span><span class="token punctuation">(</span>requestContextInterceptor<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="4"><li><strong>在任意 Service 中使用</strong></li></ol><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token annotation punctuation">@Service</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserService</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token annotation punctuation">@Autowired</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token class-name">RequestContext</span> requestContext<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token class-name">String</span> currentRequestId <span class="token operator">=</span> requestContext<span class="token punctuation">.</span><span class="token function">getRequestId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token class-name">String</span> currentUserId <span class="token operator">=</span> requestContext<span class="token punctuation">.</span><span class="token function">getUserId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        </span>
<span class="line">        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Processing for user: &quot;</span> <span class="token operator">+</span> currentUserId <span class="token operator">+</span> <span class="token string">&quot; [RequestID: &quot;</span> <span class="token operator">+</span> currentRequestId <span class="token operator">+</span> <span class="token string">&quot;]&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token comment">// 后续逻辑...</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h4 id="四、重要注意事项与最佳实践" tabindex="-1"><a class="header-anchor" href="#四、重要注意事项与最佳实践"><span>四、重要注意事项与最佳实践</span></a></h4><ol><li><p><strong>必须手动清除（remove）</strong>：</p><ul><li>这是<strong>最重要的一点</strong>！</li><li>由于 Web 容器使用线程池，线程会被复用。如果不调用 <code>remove()</code>，上一个请求设置的 <code>ThreadLocal</code> 值可能会被下一个请求错误地读取，导致<strong>脏数据</strong>问题。</li><li>更严重的是，如果 <code>ThreadLocal</code> 中持有大对象或存在强引用，会导致<strong>内存泄漏</strong>。因为 <code>ThreadLocalMap</code> 的 Entry 是 <code>WeakReference&lt;ThreadLocal&gt;</code>，但 Value 是强引用。如果 <code>ThreadLocal</code> 实例不再被引用，Key 会被回收，但 Value 不会，形成“弱键强值”的泄漏。</li><li><strong>解决方案</strong>：务必在请求结束时（如 <code>afterCompletion</code> 或 <code>finally</code> 块）调用 <code>remove()</code>。</li></ul></li><li><p><strong>避免过度使用</strong>：</p><ul><li>虽然方便，但滥用 <code>ThreadLocal</code> 会使代码变得“隐式”和难以测试。</li><li>数据传递不透明，增加了理解成本。</li><li>尽量只用于上下文信息（如用户、请求ID、事务状态等）。</li></ul></li><li><p><strong>考虑使用 InheritableThreadLocal</strong>：</p><ul><li>如果主线程创建了子线程（如使用 <code>@Async</code> 注解的异步方法），普通 <code>ThreadLocal</code> 的值不会自动传递给子线程。</li><li>此时可以使用 <code>InheritableThreadLocal</code>，它会在子线程创建时自动复制父线程的 <code>ThreadLocal</code> 值。</li></ul></li><li><p><strong>Spring 提供的替代方案</strong>：</p><ul><li>对于某些场景，Spring 提供了更优雅的解决方案，比如： <ul><li><strong><code>@RequestScope</code> Bean</strong>：每次请求都会创建一个新的 Bean 实例，天然线程安全。</li><li><strong>MDC (Mapped Diagnostic Context)</strong>：配合日志框架（如 Logback），用于日志追踪，比手动 <code>ThreadLocal</code> 更标准。</li></ul></li></ul></li></ol><hr><h4 id="五、总结" tabindex="-1"><a class="header-anchor" href="#五、总结"><span>五、总结</span></a></h4><p>在 Spring Boot 中，<code>ThreadLocal</code> 是一个强大的工具，主要用于：</p><ul><li><strong>请求上下文数据的传递</strong>（用户信息、请求ID）</li><li><strong>线程安全的对象管理</strong>（非线程安全工具类的实例）</li><li><strong>实现特定的线程隔离逻辑</strong></li></ul><p><strong>关键原则：</strong></p><ul><li><strong>用完即清</strong>：必须在适当的时候调用 <code>remove()</code>，防止内存泄漏和脏数据。</li><li><strong>谨慎使用</strong>：不要滥用，保持代码的清晰和可维护性。</li><li><strong>考虑替代方案</strong>：评估是否可以用 <code>@RequestScope</code> 或 MDC 等更合适的方式。</li></ul><p>正确使用 <code>ThreadLocal</code>，可以让你的 Spring Boot 应用更加高效和简洁。</p><h3 id="aop无论什么都抛出undeclaredthrowableexception-无法声明受检抛出异常是怎么回事" tabindex="-1"><a class="header-anchor" href="#aop无论什么都抛出undeclaredthrowableexception-无法声明受检抛出异常是怎么回事"><span>AOP无论什么都抛出UndeclaredThrowableException，无法声明受检抛出异常是怎么回事</span></a></h3><p>https://www.cnblogs.com/maerpao/p/17975000 通过反射判断是否属于切点执行方法的声明的Exception，如果不是且不属于<strong>RuntimeException</strong>，那么将会使用UndeclaredThrowableException包装原始的Exception。 只要声明的异常不是运行时异常，那么切点方法执行过程中抛出的异常，都会被包装成UndeclaredThrowableException。此时我们有三种选择：</p><ol><li>放了他，直接让SpringBoot兜底（还真行），但是这样非常不好，好的项目应该尽量去捕获所有异常。</li><li>修改切点方法声明的异常，将异常改为运行时异常，但这也不符合业务要求，一些业务异常并非运行时异常。</li><li>解包UndeclaredThrowableException（原始异常被包装到属性cause中），将原始异常抛出，获取到了我们自定义的异常信息。</li></ol><p>事实上SpringBoot的方案一提供的种解决方案就是将UndeclaredThrowableException解包，将原始异常抛出。那么现在我们只需要在全局异常捕获中处理UndeclaredThrowableException即可：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token comment">// 解包 UndeclaredThrowableException，AOP等动态代理无法获取原始异常</span></span>
<span class="line"><span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token keyword">instanceof</span> <span class="token class-name">UndeclaredThrowableException</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token class-name">Throwable</span> cause <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">getCause</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    e <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span><span class="token punctuation">)</span> cause<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其实在SpringBoot中使用的就是这个解包方法，直接将cause使用getCause强制提取出来。</p><h3 id="validated干什么的" tabindex="-1"><a class="header-anchor" href="#validated干什么的"><span>Validated干什么的</span></a></h3><p><code>@Validated</code> 是 Spring 框架中的一个注解，主要用途如下：</p><h4 id="主要功能" tabindex="-1"><a class="header-anchor" href="#主要功能"><span>主要功能</span></a></h4><ol><li><p><strong>启用验证功能</strong></p><ul><li>用于类或方法级别，启用 Spring 的验证机制</li><li>配合 JSR-303/JSR-380 验证注解（如 <code>@NotNull</code>, <code>@Size</code>, <code>@Min</code> 等）使用</li></ul></li><li><p><strong>分组验证</strong></p><ul><li>支持验证分组，可以针对不同场景应用不同的验证规则</li><li>通过 <code>groups</code> 属性指定验证组</li></ul></li></ol><h4 id="使用场景" tabindex="-1"><a class="header-anchor" href="#使用场景"><span>使用场景</span></a></h4><ul><li><strong>Controller 参数验证</strong>：验证 HTTP 请求参数</li><li><strong>Service 层验证</strong>：在业务逻辑层验证数据</li><li><strong>方法参数验证</strong>：验证方法调用时的参数合法性</li></ul><h4 id="与-valid-的区别" tabindex="-1"><a class="header-anchor" href="#与-valid-的区别"><span>与 @Valid 的区别</span></a></h4><ul><li><code>@Validated</code>：Spring 提供的注解，支持分组验证</li><li><code>@Valid</code>：JSR-303 标准注解，不支持分组但具有更广泛的兼容性</li></ul><p>通常在 Spring Boot 项目中，<code>@Validated</code> 注解会用在 Controller 类上，配合验证注解来确保传入数据的有效性，如使用<code>@NotNull</code>等保证参数正确。</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">&quot;/addOrRemoveGroupUser&quot;</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token annotation punctuation">@GlobalInterceptor</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token class-name">ResponseVO</span> <span class="token function">addOrRemoveGroupUser</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">,</span></span>
<span class="line">                                       <span class="token annotation punctuation">@NotEmpty</span> <span class="token class-name">String</span> groupId<span class="token punctuation">,</span></span>
<span class="line">                                       <span class="token annotation punctuation">@NotEmpty</span> <span class="token class-name">String</span> selectContacts<span class="token punctuation">,</span></span>
<span class="line">                                       <span class="token annotation punctuation">@NotNull</span> <span class="token class-name">Integer</span> opType<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line"></span>
<span class="line">    <span class="token class-name">TokenUserInfoDto</span> tokenUserInfoDto <span class="token operator">=</span> <span class="token function">getTokenUserInfo</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    groupInfoService<span class="token punctuation">.</span><span class="token function">addOrUpdateBatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">return</span> <span class="token function">getSuccessResponseVO</span><span class="token punctuation">(</span>groupInfoVo<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="乐观锁是什么-为什么需要他-怎么用" tabindex="-1"><a class="header-anchor" href="#乐观锁是什么-为什么需要他-怎么用"><span>乐观锁是什么？为什么需要他？怎么用？</span></a></h3><h3 id="mysql数据库的隔离怎么实现的-事务隔离-mvcc-锁都是什么" tabindex="-1"><a class="header-anchor" href="#mysql数据库的隔离怎么实现的-事务隔离-mvcc-锁都是什么"><span>mysql数据库的隔离怎么实现的？事务隔离，MVCC，锁都是什么？</span></a></h3><p>几种常见读取异常场景</p><p>对应的事务隔离等级</p><p>mvcc在可重复读的情况下，事务在每次生成时会获取一个<strong>活跃事务快照表（当前时间点尚未提交的事务）</strong>，根据这个表，该事务会对数据版本的可见性进行判断，并对读取的数据的undolog进行回溯，每次只会去读取“<strong>在此事务开始前（事务id小于当前事务id）</strong>”且“<strong>不存在于活跃事务快照表中（即保证事务启动时就已经提交）（除了自己）</strong>”的版本，这就保证了一个事务内对一行数据的读取不会出现异常不同的情况（自己修改的版本是可见的）</p><p>锁的应用场景</p><p>X锁以及S锁</p><h3 id="mybatis基础" tabindex="-1"><a class="header-anchor" href="#mybatis基础"><span>mybatis基础</span></a></h3><p>mybatisplus是好用，但是多表联查等复杂业务的时候就不够用了，学一下基础的mybatis终究还是逃不过的</p>`,135)),n("p",null,[n("a",d,[s[0]||(s[0]=a("MyBatis 3 | XML 映射器 – mybatis",-1)),t(e)])]),n("p",null,[n("a",u,[s[1]||(s[1]=a("MyBatis 注解和Provider注解(动态构建SQL)使用_sql sql = new sql();-CSDN博客",-1)),t(e)]),s[2]||(s[2]=a("（不推荐，维护麻烦",-1))]),s[7]||(s[7]=p(`<p>当然也可以用<code>@Select</code>注解等方式来实现</p><p>同时，mybatisplus和mybatis的基础mapperXml是可以共用的（但不要在xml里面去实现一些mybatisplus已经实现的基础sql，可能会导致冲突</p><h3 id="为什么使用websocket实现信息通信" tabindex="-1"><a class="header-anchor" href="#为什么使用websocket实现信息通信"><span>为什么使用WebSocket实现信息通信？</span></a></h3><p>这是一个非常关键的问题：<strong>WebSocket 实现的通信 vs 直接用数据库轮询实现通信</strong>，两者在架构、性能和用户体验上有巨大差异。</p><p>可以思考一下，消息的刷新节点都是什么时候？</p><ol><li>刚登陆，进入客户端，从数据库获取</li><li>向对方发送消息，信息经过后端存入数据库，但是只是基于数据库无法实现服务器向对方客户端的通知（专职于服务客户端发送的request，而无法实现向客户端发送信息）</li><li>对方发送消息，信息存入数据库，同样我方无法及时接收消息</li></ol><p>如果需要获取信息，可以看出来，只能通过客户端不断发送request给后端，让后端以<strong>轮询</strong>的方式查询是否有信息需要接收，对于聊天软件来说，这种程度的消息延时是不可接受的。</p><p>下面我们从多个维度进行详细对比：</p><hr><h4 id="✅-1-通信模式本质不同" tabindex="-1"><a class="header-anchor" href="#✅-1-通信模式本质不同"><span>✅ 1. <strong>通信模式本质不同</strong></span></a></h4><table><thead><tr><th>方式</th><th>通信模式</th><th>特点</th></tr></thead><tbody><tr><td><strong>WebSocket</strong></td><td><strong>双向实时通信</strong></td><td>客户端和服务端建立长连接，任意一方可随时推送消息</td></tr><tr><td><strong>数据库轮询</strong></td><td><strong>单向模拟通信</strong></td><td>客户端定时查数据库，看有没有新消息（“拉”模式）</td></tr></tbody></table><blockquote><p>🔹 WebSocket：像打电话 —— 双方可随时说话。<br> 🔹 数据库轮询：像查邮箱 —— 你每隔5分钟看一次有没有新邮件。</p></blockquote><hr><h4 id="✅-2-实时性对比" tabindex="-1"><a class="header-anchor" href="#✅-2-实时性对比"><span>✅ 2. <strong>实时性对比</strong></span></a></h4><table><thead><tr><th>指标</th><th>WebSocket</th><th>数据库轮询</th></tr></thead><tbody><tr><td>延迟</td><td>⭐ 极低（毫秒级）</td><td>⚠️ 高（取决于轮询间隔，如 5s）</td></tr><tr><td>是否能“主动推送”</td><td>✅ 是（服务端可直接发消息）</td><td>❌ 否（只能等客户端来查）</td></tr></tbody></table><blockquote><p>举例：用户A发消息给B，B是否立刻看到？</p></blockquote><ul><li>WebSocket：✅ 立刻收到推送，实时显示。</li><li>轮询：❌ 要等下一次查询（可能延迟几秒）。</li></ul><hr><h4 id="✅-3-性能与资源消耗" tabindex="-1"><a class="header-anchor" href="#✅-3-性能与资源消耗"><span>✅ 3. <strong>性能与资源消耗</strong></span></a></h4><table><thead><tr><th>指标</th><th>WebSocket</th><th>数据库轮询</th></tr></thead><tbody><tr><td>并发连接压力</td><td>中等（保持长连接）</td><td>低（但频繁短连接）</td></tr><tr><td>数据库压力</td><td>❌ 低（只在业务需要时读写）</td><td>⚠️ 高（大量 SELECT 查询）</td></tr><tr><td>网络开销</td><td>✅ 少量心跳包</td><td>❌ 频繁 HTTP 请求 + 数据库查询</td></tr></tbody></table><blockquote><p>举个例子：</p></blockquote><ul><li>1000 个用户每 2 秒轮询一次 → 每分钟 30,000 次数据库查询！</li><li>WebSocket：1000 个连接，只有消息来时才触发一次写操作。</li></ul><hr><h4 id="✅-4-扩展性与维护性" tabindex="-1"><a class="header-anchor" href="#✅-4-扩展性与维护性"><span>✅ 4. <strong>扩展性与维护性</strong></span></a></h4><table><thead><tr><th>指标</th><th>WebSocket</th><th>数据库轮询</th></tr></thead><tbody><tr><td>支持群聊、广播</td><td>✅ 容易实现（<code>ChannelGroup</code>）</td><td>❌ 复杂（需查所有用户状态）</td></tr><tr><td>用户在线状态管理</td><td>✅ 天然支持（连接即在线）</td><td>❌ 需额外字段标记</td></tr><tr><td>消息确认、重发机制</td><td>✅ 可自定义协议实现</td><td>❌ 难以保证一致性</td></tr></tbody></table><hr><h4 id="✅-5-适用场景对比" tabindex="-1"><a class="header-anchor" href="#✅-5-适用场景对比"><span>✅ 5. <strong>适用场景对比</strong></span></a></h4><table><thead><tr><th>场景</th><th>推荐方式</th><th>原因</th></tr></thead><tbody><tr><td>聊天室、IM、客服系统</td><td>✅ WebSocket</td><td>必须实时，不能有延迟</td></tr><tr><td>实时通知（如订单状态）</td><td>✅ WebSocket</td><td>用户期望“立刻知道”</td></tr><tr><td>在线协作（文档编辑）</td><td>✅ WebSocket</td><td>多人协同，高频更新</td></tr><tr><td>后台任务状态查询</td><td>⚠️ 可用轮询</td><td>更新频率低，简单实现即可</td></tr><tr><td>新闻资讯更新</td><td>⚠️ 轮询 + 缓存</td><td>非强实时，成本敏感</td></tr></tbody></table><hr><h4 id="✅-6-举个真实例子-聊天功能" tabindex="-1"><a class="header-anchor" href="#✅-6-举个真实例子-聊天功能"><span>✅ 6. <strong>举个真实例子：聊天功能</strong></span></a></h4><h5 id="❌-用数据库轮询实现" tabindex="-1"><a class="header-anchor" href="#❌-用数据库轮询实现"><span>❌ 用数据库轮询实现：</span></a></h5><ul><li>客户端每 2 秒执行：<div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql" data-title="sql"><pre><code><span class="line"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> messages <span class="token keyword">WHERE</span> to_user <span class="token operator">=</span> ? <span class="token operator">AND</span> create_time <span class="token operator">&gt;</span> ?</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li><li>问题： <ul><li>浪费资源（90% 查询无新消息）</li><li>延迟高（最多等 2 秒）</li><li>数据库压力大</li></ul></li></ul><h5 id="✅-用-websocket-实现" tabindex="-1"><a class="header-anchor" href="#✅-用-websocket-实现"><span>✅ 用 WebSocket 实现：</span></a></h5><ul><li>用户上线 → 建立连接，加入 <code>ChannelGroup</code></li><li>用户A发消息 → 服务端直接调用：<div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line">channelGroup<span class="token punctuation">.</span><span class="token function">writeAndFlush</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">TextWebSocketFrame</span><span class="token punctuation">(</span><span class="token string">&quot;新消息...&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li><li>用户B <strong>立刻</strong> 收到，无需查询数据库</li></ul><hr><h4 id="✅-总结-websocket-的核心优势" tabindex="-1"><a class="header-anchor" href="#✅-总结-websocket-的核心优势"><span>✅ 总结：WebSocket 的核心优势</span></a></h4><table><thead><tr><th>优势</th><th>说明</th></tr></thead><tbody><tr><td>🚀 <strong>实时性高</strong></td><td>消息秒达，无延迟</td></tr><tr><td>💡 <strong>节省资源</strong></td><td>减少无效数据库查询和 HTTP 请求</td></tr><tr><td>📡 <strong>支持主动推送</strong></td><td>服务端可随时通知客户端</td></tr><tr><td>🧩 <strong>适合复杂交互</strong></td><td>支持聊天、心跳、状态同步等</td></tr><tr><td>📈 <strong>可扩展性强</strong></td><td>易实现广播、群组、在线状态等</td></tr></tbody></table><hr><h4 id="❗️-注意-websocket-不是万能的" tabindex="-1"><a class="header-anchor" href="#❗️-注意-websocket-不是万能的"><span>❗️ 注意：WebSocket 不是万能的</span></a></h4><table><thead><tr><th>缺点</th><th>说明</th></tr></thead><tbody><tr><td>连接管理复杂</td><td>需处理断线重连、心跳、集群等问题</td></tr><tr><td>占用内存</td><td>每个连接占用一定内存（不适合超大规模）</td></tr><tr><td>不支持所有环境</td><td>某些老旧浏览器或网络代理可能不支持</td></tr></tbody></table><hr><h4 id="✅-结论" tabindex="-1"><a class="header-anchor" href="#✅-结论"><span>✅ 结论</span></a></h4><blockquote><p><strong>如果你要做的是“实时通信”类功能（如聊天、通知、协作），一定要用 WebSocket。</strong><br><strong>如果只是偶尔查个状态，且对实时性要求不高，可以用数据库轮询 + 缓存。</strong></p></blockquote><hr><h3 id="多机部署-集群环境-下-如何实现用户跨服务器通信" tabindex="-1"><a class="header-anchor" href="#多机部署-集群环境-下-如何实现用户跨服务器通信"><span>多机部署（集群环境）下，如何实现用户跨服务器通信？</span></a></h3><p>在我们学习了mysql，redis之后，接下来要学的中间件就是消息队列MQ了。都知道mq可以用来调取</p><h3 id="springboot和netty对与线程的管理" tabindex="-1"><a class="header-anchor" href="#springboot和netty对与线程的管理"><span>SpringBoot和netty对与线程的管理</span></a></h3><table><thead><tr><th><strong>Spring Boot 处理 request 是一个线程吗？</strong></th><th>✅ 是，<strong>默认一个请求由一个线程同步处理</strong>，直到返回响应。线程会被阻塞。</th></tr></thead><tbody><tr><td><strong>Netty 每个用户连接都创建一个线程吗？</strong></td><td>❌ <strong>不是！</strong> Netty 使用少量线程（EventLoop）通过事件驱动处理成千上万连接，<strong>一个线程服务多个连接</strong>。</td></tr></tbody></table><hr><h4 id="✅-一、spring-boot-是怎么管理线程的" tabindex="-1"><a class="header-anchor" href="#✅-一、spring-boot-是怎么管理线程的"><span>✅ 一、Spring Boot 是怎么管理线程的？</span></a></h4><blockquote><p><strong>处理一个 request 会用一个线程吗？返回 response 也是同一个线程吗？</strong></p></blockquote><h5 id="_1-默认情况-是的-一个请求由一个线程处理-同步阻塞" tabindex="-1"><a class="header-anchor" href="#_1-默认情况-是的-一个请求由一个线程处理-同步阻塞"><span>1. 默认情况：<strong>是的，一个请求由一个线程处理（同步阻塞）</strong></span></a></h5><p>Spring Boot（基于 Tomcat、Jetty 或 Undertow）默认使用 <strong>线程池 + 阻塞 I/O</strong> 模型。</p><h6 id="📌-工作流程" tabindex="-1"><a class="header-anchor" href="#📌-工作流程"><span>📌 工作流程：</span></a></h6><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">客户端请求 → Web 服务器（如 Tomcat）→ 从线程池中分配一个线程 → 处理整个请求（Controller → Service → DB）→ 返回响应 → 线程归还线程池</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li>✅ <strong>同一个线程</strong> 负责： <ul><li>接收请求</li><li>执行业务逻辑</li><li>返回响应</li></ul></li><li>❌ 这个线程在处理期间<strong>被阻塞</strong>，不能干别的事（比如等数据库查询、调外部 API）</li></ul><h6 id="🌰-举例" tabindex="-1"><a class="header-anchor" href="#🌰-举例"><span>🌰 举例：</span></a></h6><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">&quot;/user&quot;</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token class-name">User</span> <span class="token function">getUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 模拟耗时操作</span></span>
<span class="line">    <span class="token keyword">return</span> userService<span class="token punctuation">.</span><span class="token function">findById</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>这个请求会<strong>占用一个线程整整 3 秒</strong>，期间该线程不能处理其他请求。</li></ul><hr><h5 id="_2-问题-如果并发高-线程不够怎么办" tabindex="-1"><a class="header-anchor" href="#_2-问题-如果并发高-线程不够怎么办"><span>2. 问题：如果并发高，线程不够怎么办？</span></a></h5><ul><li>Tomcat 默认线程池大小是 <strong>200</strong></li><li>如果有 300 个并发请求，第 201~300 个请求会被<strong>排队或拒绝</strong></li></ul><p>👉 这就是传统 Web 框架的瓶颈：<strong>线程是稀缺资源</strong></p><hr><h5 id="_3-spring-boot-如何支持异步-——-async-和-webflux" tabindex="-1"><a class="header-anchor" href="#_3-spring-boot-如何支持异步-——-async-和-webflux"><span>3. Spring Boot 如何支持异步？—— <code>@Async</code> 和 WebFlux</span></a></h5><h6 id="✅-方式一-async-异步方法" tabindex="-1"><a class="header-anchor" href="#✅-方式一-async-异步方法"><span>✅ 方式一：<code>@Async</code>（异步方法）</span></a></h6><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token annotation punctuation">@Async</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> <span class="token function">asyncFindUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// 在独立线程中执行</span></span>
<span class="line">    <span class="token keyword">return</span> <span class="token class-name">CompletableFuture</span><span class="token punctuation">.</span><span class="token function">completedFuture</span><span class="token punctuation">(</span>userService<span class="token punctuation">.</span><span class="token function">findById</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>请求进来后，主线程不阻塞，提交任务到线程池，立即返回 <code>CompletableFuture</code></li><li>适合“后台任务”，但不是真正的非阻塞 I/O</li></ul><h6 id="✅-方式二-spring-webflux-响应式编程" tabindex="-1"><a class="header-anchor" href="#✅-方式二-spring-webflux-响应式编程"><span>✅ 方式二：<strong>Spring WebFlux（响应式编程）</strong></span></a></h6><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">&quot;/user&quot;</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token class-name">Mono</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> <span class="token function">getUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">return</span> userService<span class="token punctuation">.</span><span class="token function">findUserById</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 返回 Mono，异步非阻塞</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>基于 <strong>Netty</strong> 或 <strong>Servlet 3.1+ 非阻塞 I/O</strong></li><li>一个线程可以处理<strong>成千上万个请求</strong>（通过事件驱动）</li></ul><hr><h4 id="✅-二、netty-是怎么管理线程的" tabindex="-1"><a class="header-anchor" href="#✅-二、netty-是怎么管理线程的"><span>✅ 二、Netty 是怎么管理线程的？</span></a></h4><blockquote><p><strong>每个用户连接都会创建一个线程吗？</strong></p></blockquote><h5 id="❌-不是-netty-使用-事件循环-eventloop-模型-极少线程处理大量连接" tabindex="-1"><a class="header-anchor" href="#❌-不是-netty-使用-事件循环-eventloop-模型-极少线程处理大量连接"><span>❌ 不是！Netty 使用 <strong>事件循环（EventLoop）模型</strong>，<strong>极少线程处理大量连接</strong></span></a></h5><h6 id="_1-核心概念-eventloopgroup" tabindex="-1"><a class="header-anchor" href="#_1-核心概念-eventloopgroup"><span>1. 核心概念：<code>EventLoopGroup</code></span></a></h6><p>Netty 有两个线程组：</p><table><thead><tr><th>线程组</th><th>作用</th><th>线程数</th></tr></thead><tbody><tr><td><code>bossGroup</code></td><td>接受新连接（accept）</td><td>通常 1 个线程</td></tr><tr><td><code>workerGroup</code></td><td>处理已建立连接的读写（I/O）</td><td>通常是 CPU 核数 × 2（如 8 个）</td></tr></tbody></table><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token class-name">EventLoopGroup</span> boss <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NioEventLoopGroup</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">EventLoopGroup</span> worker <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NioEventLoopGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 默认线程数 = 2 * CPU核心数</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><hr><h6 id="_2-每个连接-channel-绑定到一个固定的-eventloop" tabindex="-1"><a class="header-anchor" href="#_2-每个连接-channel-绑定到一个固定的-eventloop"><span>2. 每个连接（Channel）绑定到一个固定的 <code>EventLoop</code></span></a></h6><ul><li>当一个客户端连接上来，Netty 会从 <code>workerGroup</code> 中<strong>选择一个 EventLoop</strong>，并<strong>永久绑定</strong></li><li>这个连接的<strong>所有 I/O 操作</strong>（读、写、关闭）都由<strong>同一个线程</strong>处理</li><li>但一个 <code>EventLoop</code> 线程可以处理<strong>成千上万个连接</strong></li></ul><blockquote><p>🔹 类比：一个客服（线程）可以服务多个客户（连接），通过“事件轮询”处理每个客户的请求</p></blockquote><hr><h6 id="_3-事件驱动-非阻塞-i-o" tabindex="-1"><a class="header-anchor" href="#_3-事件驱动-非阻塞-i-o"><span>3. 事件驱动 + 非阻塞 I/O</span></a></h6><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">EventLoop 线程：</span>
<span class="line">  while (true) {</span>
<span class="line">    1. 检查哪些 Channel 有事件（如可读、可写）</span>
<span class="line">    2. 处理这些事件（调用你的 ChannelHandler）</span>
<span class="line">  }</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>没有 I/O 时，线程不阻塞，去处理其他就绪的 Channel</li><li>有数据可读时，触发 <code>channelRead()</code> 方法</li><li>所以：<strong>1 个线程 = 数千连接</strong></li></ul><hr><h5 id="_4-示例-10-000-个-websocket-连接" tabindex="-1"><a class="header-anchor" href="#_4-示例-10-000-个-websocket-连接"><span>4. 示例：10,000 个 WebSocket 连接</span></a></h5><table><thead><tr><th>模型</th><th>所需线程数</th><th>内存占用</th><th>并发能力</th></tr></thead><tbody><tr><td>Spring Boot + Tomcat</td><td>~10,000（每个连接一个线程）</td><td>极高（OOM）</td><td>差</td></tr><tr><td>Netty</td><td>8 个 <code>EventLoop</code> 线程</td><td>很低</td><td>极强</td></tr></tbody></table><p>👉 Netty 可以用 <strong>8 个线程</strong> 轻松支持 <strong>10 万+ 长连接</strong></p><hr><h4 id="✅-三、对比总结-spring-boot-vs-netty" tabindex="-1"><a class="header-anchor" href="#✅-三、对比总结-spring-boot-vs-netty"><span>✅ 三、对比总结：Spring Boot vs Netty</span></a></h4><table><thead><tr><th>特性</th><th>Spring Boot（Tomcat）</th><th>Netty</th></tr></thead><tbody><tr><td>线程模型</td><td><strong>线程池 + 阻塞 I/O</strong></td><td><strong>事件循环 + 非阻塞 I/O</strong></td></tr><tr><td>每个请求/连接是否占用线程</td><td>✅ 是（直到完成）</td><td>❌ 否（事件驱动）</td></tr><tr><td>并发能力</td><td>中等（受限于线程数）</td><td>极高（C10K 问题解决方案）</td></tr><tr><td>适合场景</td><td>普通 Web API、后台服务</td><td>高并发、长连接、实时通信（WebSocket、IM）</td></tr><tr><td>编程模型</td><td>同步为主</td><td>异步、回调、Promise（Future）</td></tr><tr><td>默认线程数</td><td>Tomcat 默认 200</td><td>Netty 默认 8（2×CPU核数）</td></tr></tbody></table><hr><h4 id="✅-四、spring-boot-netty-可以" tabindex="-1"><a class="header-anchor" href="#✅-四、spring-boot-netty-可以"><span>✅ 四、Spring Boot + Netty？可以！</span></a></h4><p>Spring Boot 也可以集成 Netty：</p><ul><li><strong>Spring WebFlux</strong> 默认使用 <strong>Netty</strong> 作为服务器（Reactive 模式）</li><li>WebSocket 服务可以用 Netty 实现</li><li>gRPC、TCP 服务常用 Netty 构建</li></ul><div class="language-yaml line-numbers-mode" data-highlighter="prismjs" data-ext="yml" data-title="yml"><pre><code><span class="line"><span class="token comment"># 使用 Netty 作为 WebFlux 服务器</span></span>
<span class="line"><span class="token key atrule">dependencies</span><span class="token punctuation">:</span></span>
<span class="line">  <span class="token punctuation">-</span> spring<span class="token punctuation">-</span>boot<span class="token punctuation">-</span>starter<span class="token punctuation">-</span>webflux</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此时就是：<strong>Spring Boot 的便利 + Netty 的高性能</strong></p><p>📌 <strong>一句话总结</strong>：</p><blockquote><ul><li><strong>Spring Boot（Tomcat）</strong>：一个请求 → 一个线程（阻塞）</li><li><strong>Netty</strong>：一个线程 → 处理上万个连接（非阻塞 + 事件驱动）</li></ul></blockquote><h3 id="session数据库缓存结构-怎么实现缓存用户消息的" tabindex="-1"><a class="header-anchor" href="#session数据库缓存结构-怎么实现缓存用户消息的"><span>Session数据库缓存结构？怎么实现缓存用户消息的？</span></a></h3><h3 id="为什么需要会话session记录表" tabindex="-1"><a class="header-anchor" href="#为什么需要会话session记录表"><span>为什么需要会话Session记录表？</span></a></h3><h3 id="redis-的-hash-是怎么实现的" tabindex="-1"><a class="header-anchor" href="#redis-的-hash-是怎么实现的"><span><strong>Redis 的 Hash 是怎么实现的？</strong></span></a></h3><p>Redis 的 <code>Hash</code> 数据类型在底层并不是简单地使用一个“HashMap”来实现，而是根据数据的大小和结构，<strong>动态选择两种不同的编码方式（底层实现）</strong>，以达到<strong>内存效率和性能的平衡</strong>。</p><hr><h4 id="✅-一、redis-hash-的两种底层实现" tabindex="-1"><a class="header-anchor" href="#✅-一、redis-hash-的两种底层实现"><span>✅ 一、Redis Hash 的两种底层实现</span></a></h4><table><thead><tr><th>编码方式</th><th>说明</th><th>适用场景</th></tr></thead><tbody><tr><td><code>ziplist</code>（压缩列表）</td><td>内存紧凑，节省空间</td><td>小数据量时</td></tr><tr><td><code>hashtable</code>（哈希表）</td><td>查找快，支持大数据</td><td>数据量大或键值较长时</td></tr></tbody></table><p>Redis 会根据配置自动在这两种编码之间转换。</p><hr><h4 id="✅-二、1-ziplist-压缩列表-内存友好" tabindex="-1"><a class="header-anchor" href="#✅-二、1-ziplist-压缩列表-内存友好"><span>✅ 二、1. <code>ziplist</code>：压缩列表（内存友好）</span></a></h4><h5 id="📌-什么是-ziplist" tabindex="-1"><a class="header-anchor" href="#📌-什么是-ziplist"><span>📌 什么是 ziplist？</span></a></h5><ul><li><code>ziplist</code> 是 Redis 自定义的一种<strong>紧凑的、连续内存存储结构</strong>。</li><li>它不是真正的“哈希表”，而是一个<strong>双向链表的线性结构</strong>，按顺序存储 <code>field</code> 和 <code>value</code>。</li></ul><h5 id="🧱-存储结构-逻辑上" tabindex="-1"><a class="header-anchor" href="#🧱-存储结构-逻辑上"><span>🧱 存储结构（逻辑上）：</span></a></h5><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">[field1][value1][field2][value2][field3][value3]</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li>所有元素按 <code>field</code> → <code>value</code> 成对排列</li><li>存储在一块连续的内存中</li></ul><h5 id="✅-优点" tabindex="-1"><a class="header-anchor" href="#✅-优点"><span>✅ 优点：</span></a></h5><ul><li><strong>内存占用极小</strong>：没有指针开销，适合小数据</li><li><strong>缓存友好</strong>：CPU 缓存命中率高</li></ul><h5 id="❌-缺点" tabindex="-1"><a class="header-anchor" href="#❌-缺点"><span>❌ 缺点：</span></a></h5><ul><li><strong>查找是 O(n)</strong>：需要遍历整个列表</li><li><strong>插入/删除慢</strong>：涉及内存移动</li><li><strong>不适合大数据</strong></li></ul><h5 id="🔧-触发条件-默认" tabindex="-1"><a class="header-anchor" href="#🔧-触发条件-默认"><span>🔧 触发条件（默认）：</span></a></h5><p>当满足以下条件时，Redis 使用 <code>ziplist</code> 编码：</p><div class="language-conf line-numbers-mode" data-highlighter="prismjs" data-ext="conf" data-title="conf"><pre><code><span class="line">hash-max-ziplist-entries 512</span>
<span class="line">hash-max-ziplist-value 64</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>字段数量 ≤ 512</li><li>每个 <code>field</code> 和 <code>value</code> 的长度 ≤ 64 字节</li></ul><blockquote><p>⚠️ 超出任一条件，Redis 会自动将 <code>ziplist</code> 升级为 <code>hashtable</code></p></blockquote><hr><h4 id="✅-三、2-hashtable-真正的哈希表-性能优先" tabindex="-1"><a class="header-anchor" href="#✅-三、2-hashtable-真正的哈希表-性能优先"><span>✅ 三、2. <code>hashtable</code>：真正的哈希表（性能优先）</span></a></h4><h5 id="📌-什么是-hashtable" tabindex="-1"><a class="header-anchor" href="#📌-什么是-hashtable"><span>📌 什么是 <code>hashtable</code>？</span></a></h5><ul><li>使用 <strong>字典（dict）</strong> 实现，类似于 Java 的 <code>HashMap</code></li><li>内部结构：数组 + 链表（或红黑树，但 Redis 没用红黑树）</li><li>支持 O(1) 平均时间复杂度的查找、插入、删除</li></ul><h5 id="🧱-存储结构" tabindex="-1"><a class="header-anchor" href="#🧱-存储结构"><span>🧱 存储结构：</span></a></h5><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">dict</span> <span class="token punctuation">{</span></span>
<span class="line">    dictEntry <span class="token operator">*</span>table<span class="token punctuation">;</span>        <span class="token comment">// 哈希表数组</span></span>
<span class="line">    <span class="token keyword">int</span> size<span class="token punctuation">;</span>                <span class="token comment">// 表大小</span></span>
<span class="line">    <span class="token keyword">int</span> used<span class="token punctuation">;</span>                <span class="token comment">// 已用条目数</span></span>
<span class="line">    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></span>
<span class="line"><span class="token punctuation">}</span> dict<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">dictEntry</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">void</span> <span class="token operator">*</span>key<span class="token punctuation">;</span>               <span class="token comment">// field</span></span>
<span class="line">    <span class="token keyword">void</span> <span class="token operator">*</span>val<span class="token punctuation">;</span>               <span class="token comment">// value</span></span>
<span class="line">    <span class="token keyword">struct</span> <span class="token class-name">dictEntry</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>  <span class="token comment">// 解决哈希冲突（链地址法）</span></span>
<span class="line"><span class="token punctuation">}</span> dictEntry<span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="✅-优点-1" tabindex="-1"><a class="header-anchor" href="#✅-优点-1"><span>✅ 优点：</span></a></h5><ul><li><strong>查找、插入、删除 O(1)</strong>（平均）</li><li>支持任意大小的数据</li><li>扩展性强</li></ul><h5 id="❌-缺点-1" tabindex="-1"><a class="header-anchor" href="#❌-缺点-1"><span>❌ 缺点：</span></a></h5><ul><li><strong>内存开销大</strong>：每个 <code>dictEntry</code> 有指针开销</li><li><strong>可能触发 rehash</strong>（渐进式 rehash）</li></ul><hr><h4 id="✅-四、redis-hash-的操作时间复杂度" tabindex="-1"><a class="header-anchor" href="#✅-四、redis-hash-的操作时间复杂度"><span>✅ 四、Redis Hash 的操作时间复杂度</span></a></h4><table><thead><tr><th>命令</th><th>时间复杂度</th><th>说明</th></tr></thead><tbody><tr><td><code>HSET key field value</code></td><td>O(1)</td><td>小数据是 O(n)（ziplist），大数据是 O(1)（hashtable）</td></tr><tr><td><code>HGET key field</code></td><td>O(1)</td><td>同上</td></tr><tr><td><code>HDEL key field</code></td><td>O(N)</td><td>N 是删除的字段数</td></tr><tr><td><code>HGETALL key</code></td><td>O(n)</td><td>n 是 hash 中的字段总数</td></tr><tr><td><code>HEXISTS key field</code></td><td>O(1)</td><td></td></tr><tr><td><code>HLEN key</code></td><td>O(1)</td><td></td></tr></tbody></table><blockquote><p>⚠️ 注意：虽然 <code>HSET</code>/<code>HGET</code> 标称 O(1)，但在 <code>ziplist</code> 下是 O(n)，所以只适合小数据。</p></blockquote><hr><h4 id="✅-五、编码转换示例" tabindex="-1"><a class="header-anchor" href="#✅-五、编码转换示例"><span>✅ 五、编码转换示例</span></a></h4><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line"><span class="token comment"># 1. 创建一个小 hash（使用 ziplist）</span></span>
<span class="line">HSET user:1001 name <span class="token string">&quot;Alice&quot;</span></span>
<span class="line">HSET user:1001 age <span class="token string">&quot;25&quot;</span></span>
<span class="line"></span>
<span class="line"><span class="token comment"># 查看编码</span></span>
<span class="line">OBJECT ENCODING user:1001</span>
<span class="line"><span class="token comment"># 输出: &quot;ziplist&quot;</span></span>
<span class="line"></span>
<span class="line"><span class="token comment"># 2. 添加大量字段，触发升级</span></span>
<span class="line"><span class="token comment"># （假设超过 hash-max-ziplist-entries=512）</span></span>
<span class="line"><span class="token comment"># 添加第 513 个字段...</span></span>
<span class="line"></span>
<span class="line"><span class="token comment"># 再次查看</span></span>
<span class="line">OBJECT ENCODING user:1001</span>
<span class="line"><span class="token comment"># 输出: &quot;hashtable&quot;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>🔁 一旦从 <code>ziplist</code> 升级到 <code>hashtable</code>，<strong>就不会再降级回去</strong>。</p></blockquote><hr><h4 id="✅-六、为什么-redis-要这样设计" tabindex="-1"><a class="header-anchor" href="#✅-六、为什么-redis-要这样设计"><span>✅ 六、为什么 Redis 要这样设计？</span></a></h4><table><thead><tr><th>目标</th><th>实现方式</th></tr></thead><tbody><tr><td><strong>小数据省内存</strong></td><td>用 <code>ziplist</code>，避免指针开销</td></tr><tr><td><strong>大数据高性能</strong></td><td>用 <code>hashtable</code>，保证 O(1) 操作</td></tr><tr><td><strong>自动适应</strong></td><td>根据数据量动态切换编码</td></tr></tbody></table><blockquote><p>🎯 典型应用场景：</p><ul><li>用户信息缓存：<code>HSET user:1001 name &quot;Tom&quot; age &quot;20&quot;</code></li><li>商品属性：<code>HSET product:100 price &quot;99.9&quot; stock &quot;100&quot;</code></li></ul></blockquote><hr><h4 id="✅-七、如何查看和优化" tabindex="-1"><a class="header-anchor" href="#✅-七、如何查看和优化"><span>✅ 七、如何查看和优化？</span></a></h4><h5 id="_1-查看当前-hash-的编码" tabindex="-1"><a class="header-anchor" href="#_1-查看当前-hash-的编码"><span>1. 查看当前 hash 的编码：</span></a></h5><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line">OBJECT ENCODING <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h5 id="_2-调整配置-redis-conf" tabindex="-1"><a class="header-anchor" href="#_2-调整配置-redis-conf"><span>2. 调整配置（<code>redis.conf</code>）：</span></a></h5><div class="language-conf line-numbers-mode" data-highlighter="prismjs" data-ext="conf" data-title="conf"><pre><code><span class="line">hash-max-ziplist-entries 512   # 最大字段数</span>
<span class="line">hash-max-ziplist-value 64      # 每个 field/value 最大字节</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>⚠️ 建议不要盲目调大，否则 <code>ziplist</code> 会失去内存优势。</p></blockquote><hr><h4 id="✅-总结" tabindex="-1"><a class="header-anchor" href="#✅-总结"><span>✅ 总结</span></a></h4><table><thead><tr><th>特性</th><th><code>ziplist</code></th><th><code>hashtable</code></th></tr></thead><tbody><tr><td>存储方式</td><td>连续内存</td><td>数组 + 链表</td></tr><tr><td>查找性能</td><td>O(n)</td><td>O(1)</td></tr><tr><td>内存占用</td><td>小</td><td>大</td></tr><tr><td>适用场景</td><td>小 hash（&lt; 512 字段）</td><td>大 hash</td></tr><tr><td>是否可逆</td><td>升级后不可降级</td><td>—</td></tr></tbody></table><h3 id="多个数据库的集群部署该如何设计以解决数据库之间消息通信的问题-redis呢" tabindex="-1"><a class="header-anchor" href="#多个数据库的集群部署该如何设计以解决数据库之间消息通信的问题-redis呢"><span>多个数据库的集群部署该如何设计以解决数据库之间消息通信的问题？redis呢？</span></a></h3><p>这是一个非常关键且实际的问题，涉及到 <strong>数据库高可用、扩展性与分布式架构设计以及redis消息一致性</strong>。</p><hr><h4 id="✅-一、一般情况下-我们会部署多个-mysql-吗" tabindex="-1"><a class="header-anchor" href="#✅-一、一般情况下-我们会部署多个-mysql-吗"><span>✅ 一、一般情况下，我们会部署多个 MySQL 吗？</span></a></h4><h5 id="答案是-会的-但不是-随意-部署多个-而是根据业务需求进行合理的架构设计。" tabindex="-1"><a class="header-anchor" href="#答案是-会的-但不是-随意-部署多个-而是根据业务需求进行合理的架构设计。"><span><strong>答案是：会的！但不是“随意”部署多个，而是根据业务需求进行合理的架构设计。</strong></span></a></h5><h5 id="📌-常见场景下会使用多个-mysql-实例" tabindex="-1"><a class="header-anchor" href="#📌-常见场景下会使用多个-mysql-实例"><span>📌 常见场景下会使用多个 MySQL 实例：</span></a></h5><table><thead><tr><th>场景</th><th>是否需要多实例</th><th>说明</th></tr></thead><tbody><tr><td>单机小项目（如个人博客）</td><td>❌ 不需要</td><td>一个主库就够了</td></tr><tr><td>中大型应用（如电商、社交）</td><td>✅ 需要</td><td>为了解决性能、高可用、容灾等问题</td></tr></tbody></table><hr><h4 id="✅-二、为什么需要部署多个-mysql" tabindex="-1"><a class="header-anchor" href="#✅-二、为什么需要部署多个-mysql"><span>✅ 二、为什么需要部署多个 MySQL？</span></a></h4><h5 id="_1-读写分离-read-write-splitting" tabindex="-1"><a class="header-anchor" href="#_1-读写分离-read-write-splitting"><span>1. <strong>读写分离（Read-Write Splitting）</strong></span></a></h5><ul><li>写操作走 <strong>主库（Master）</strong></li><li>读操作走 <strong>从库（Slave）</strong></li><li>减轻主库压力，提升查询性能</li></ul><blockquote><p>🔁 原理：通过 <strong>MySQL 主从复制（Replication）</strong> 自动同步数据</p></blockquote><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">+--------+     +------------+</span>
<span class="line">| Master | --&gt; | Slave (RO) |</span>
<span class="line">+--------+     +------------+</span>
<span class="line">               +------------+</span>
<span class="line">               | Slave (RO) |</span>
<span class="line">               +------------+</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="_2-高可用-high-availability" tabindex="-1"><a class="header-anchor" href="#_2-高可用-high-availability"><span>2. <strong>高可用（High Availability）</strong></span></a></h5><ul><li>主库宕机 → 自动切换到备用库（如使用 MHA、Orchestrator）</li><li>避免单点故障</li></ul><h5 id="_3-分库分表-sharding" tabindex="-1"><a class="header-anchor" href="#_3-分库分表-sharding"><span>3. <strong>分库分表（Sharding）</strong></span></a></h5><ul><li>数据量太大（亿级表）→ 拆分到多个 MySQL 实例</li><li>如：按用户 ID 分片，<code>user_0</code>, <code>user_1</code> 放在不同实例上</li></ul><h5 id="_4-多地部署-异地容灾" tabindex="-1"><a class="header-anchor" href="#_4-多地部署-异地容灾"><span>4. <strong>多地部署（异地容灾）</strong></span></a></h5><ul><li>北京主数据中心 + 上海备份中心</li><li>防止机房级故障</li></ul><hr><h4 id="✅-三、多个数据库之间的-通信-是怎么解决的" tabindex="-1"><a class="header-anchor" href="#✅-三、多个数据库之间的-通信-是怎么解决的"><span>✅ 三、多个数据库之间的“通信”是怎么解决的？</span></a></h4><p>你问的“通信”，其实更准确说是 <strong>数据同步和一致性保障机制</strong>。</p><p>MySQL 本身不主动“通信”，而是通过以下几种方式实现数据同步：</p><hr><h5 id="方式-1️⃣-主从复制-master-slave-replication-←-最常用" tabindex="-1"><a class="header-anchor" href="#方式-1️⃣-主从复制-master-slave-replication-←-最常用"><span>方式 1️⃣：<strong>主从复制（Master-Slave Replication）</strong> ← 最常用</span></a></h5><h6 id="✅-工作原理" tabindex="-1"><a class="header-anchor" href="#✅-工作原理"><span>✅ 工作原理：</span></a></h6><ol><li>主库记录所有写操作到 <strong>binlog</strong>（二进制日志）</li><li>从库启动一个 I/O 线程，连接主库并拉取 binlog</li><li>从库将日志写入本地 <strong>relay log</strong></li><li>从库的 SQL 线程执行 relay log 中的语句，完成数据同步</li></ol><h6 id="✅-特点" tabindex="-1"><a class="header-anchor" href="#✅-特点"><span>✅ 特点：</span></a></h6><ul><li>异步复制（默认）：有延迟（毫秒~秒级）</li><li>半同步复制（Semi-sync）：至少一个从库确认收到日志才提交，更安全</li><li>可用于读写分离、备份、数据分析等</li></ul><h6 id="✅-配置示例-简化" tabindex="-1"><a class="header-anchor" href="#✅-配置示例-简化"><span>✅ 配置示例（简化）：</span></a></h6><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql" data-title="sql"><pre><code><span class="line"><span class="token comment">-- 主库开启 binlog</span></span>
<span class="line">log<span class="token operator">-</span>bin <span class="token operator">=</span> mysql<span class="token operator">-</span>bin</span>
<span class="line">server<span class="token operator">-</span>id <span class="token operator">=</span> <span class="token number">1</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">-- 从库配置</span></span>
<span class="line">server<span class="token operator">-</span>id <span class="token operator">=</span> <span class="token number">2</span></span>
<span class="line">relay<span class="token operator">-</span>log <span class="token operator">=</span> mysql<span class="token operator">-</span>relay<span class="token operator">-</span>bin</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h5 id="方式-2️⃣-双主-多主复制-multi-master" tabindex="-1"><a class="header-anchor" href="#方式-2️⃣-双主-多主复制-multi-master"><span>方式 2️⃣：<strong>双主/多主复制（Multi-Master）</strong></span></a></h5><ul><li>两个 MySQL 都可以写，互相复制对方的数据</li><li>适用于多数据中心写入</li></ul><p>⚠️ <strong>风险</strong>：容易冲突（如同一行同时被两个主库修改）</p><p>🔧 解决方案：</p><ul><li>使用 <strong>GTID</strong>（全局事务 ID）</li><li>设置 <strong>auto_increment_increment / offset</strong> 避免自增冲突</li></ul><hr><h5 id="方式-3️⃣-中间件或代理层协调-如-mycat、shardingsphere、proxysql" tabindex="-1"><a class="header-anchor" href="#方式-3️⃣-中间件或代理层协调-如-mycat、shardingsphere、proxysql"><span>方式 3️⃣：<strong>中间件或代理层协调（如 MyCat、ShardingSphere、ProxySQL）</strong></span></a></h5><ul><li>应用不直接连数据库</li><li>所有 SQL 走中间件，由它决定路由到哪个 MySQL 实例</li></ul><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">App → ProxySQL / ShardingSphere → [MySQL Instance 1, MySQL Instance 2, ...]</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>✅ 优点：</p><ul><li>对应用透明</li><li>支持分库分表、读写分离、故障转移</li></ul><hr><h5 id="方式-4️⃣-共享存储-or-集群方案-高级" tabindex="-1"><a class="header-anchor" href="#方式-4️⃣-共享存储-or-集群方案-高级"><span>方式 4️⃣：<strong>共享存储 or 集群方案（高级）</strong></span></a></h5><table><thead><tr><th>方案</th><th>说明</th></tr></thead><tbody><tr><td><strong>MySQL Group Replication</strong></td><td>官方提供的多节点强一致复制，基于 Paxos 协议</td></tr><tr><td><strong>InnoDB Cluster</strong></td><td>基于 Group Replication + MySQL Shell + Router，自动管理主从切换</td></tr><tr><td><strong>Galera Cluster</strong></td><td>第三方集群方案，支持多主同步复制</td></tr><tr><td><strong>MGR（MySQL Group Replication）</strong></td><td>推荐用于金融级高可用场景</td></tr></tbody></table><blockquote><p>这些方案内部通过 <strong>组通信协议（Group Communication Protocol）</strong> 实现节点间通信和状态同步。</p></blockquote><hr><h4 id="✅-四、如何保证数据一致性" tabindex="-1"><a class="header-anchor" href="#✅-四、如何保证数据一致性"><span>✅ 四、如何保证数据一致性？</span></a></h4><table><thead><tr><th>机制</th><th>说明</th></tr></thead><tbody><tr><td><strong>异步复制</strong></td><td>默认，最快，但可能丢数据</td></tr><tr><td><strong>半同步复制</strong></td><td>至少一个从库收到日志，平衡性能与安全</td></tr><tr><td><strong>全同步复制</strong></td><td>所有从库都确认才提交，性能差</td></tr><tr><td><strong>GTID</strong></td><td>全局事务 ID，避免复制错位</td></tr><tr><td><strong>心跳检测 + 故障转移</strong></td><td>如 MHA、Orchestrator 自动切换主库</td></tr></tbody></table><hr><h4 id="✅-五、实际部署建议" tabindex="-1"><a class="header-anchor" href="#✅-五、实际部署建议"><span>✅ 五、实际部署建议</span></a></h4><table><thead><tr><th>架构</th><th>适用场景</th></tr></thead><tbody><tr><td><strong>主从复制 + 读写分离</strong></td><td>90% 的中大型项目首选</td></tr><tr><td><strong>MHA + VIP 切换</strong></td><td>要求高可用但不想太复杂</td></tr><tr><td><strong>InnoDB Cluster</strong></td><td>官方推荐，适合云环境</td></tr><tr><td><strong>ShardingSphere 分库分表</strong></td><td>超大数据量（TB级以上）</td></tr></tbody></table><hr><p>接下来我们来系统地讲解 Redis 集群的部署方式、节点间通信机制以及数据分布策略。</p><hr><h4 id="✅-一、redis-集群的目标" tabindex="-1"><a class="header-anchor" href="#✅-一、redis-集群的目标"><span>✅ 一、Redis 集群的目标</span></a></h4><p>Redis 是单线程内存数据库，为了：</p><ul><li><strong>突破单机内存限制</strong></li><li><strong>提高并发性能</strong></li><li><strong>实现高可用（主从切换）</strong></li></ul><p>就需要部署多个 Redis 节点组成集群。</p><blockquote><p>🎯 目标：让多个 Redis 实例协同工作，对外表现为一个“逻辑上统一”的缓存服务。</p></blockquote><hr><h4 id="✅-二、redis-官方集群方案-redis-cluster" tabindex="-1"><a class="header-anchor" href="#✅-二、redis-官方集群方案-redis-cluster"><span>✅ 二、Redis 官方集群方案：<strong>Redis Cluster</strong></span></a></h4><p>这是目前最主流、官方推荐的集群方案（无需第三方中间件）。</p><h5 id="🔗-架构图示意" tabindex="-1"><a class="header-anchor" href="#🔗-架构图示意"><span>🔗 架构图示意：</span></a></h5><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">+----------------+     +----------------+     +----------------+</span>
<span class="line">|   Redis Node   |&lt;---&gt;|   Redis Node   |&lt;---&gt;|   Redis Node   |</span>
<span class="line">| (Master/Slave) |     | (Master/Slave) |     | (Master/Slave) |</span>
<span class="line">+----------------+     +----------------+     +----------------+</span>
<span class="line">       ↑                       ↑                      ↑</span>
<span class="line">    Gossip协议           Gossip协议             Gossip协议</span>
<span class="line">       ↓                       ↓                      ↓</span>
<span class="line">+----------------------------------------------------------+</span>
<span class="line">|                   Cluster Bus（专用端口）                 |</span>
<span class="line">+----------------------------------------------------------+</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>每个节点都通过 <strong>Cluster Bus</strong> 与其他节点通信。</p><hr><h4 id="✅-三、redis-集群的关键技术点" tabindex="-1"><a class="header-anchor" href="#✅-三、redis-集群的关键技术点"><span>✅ 三、Redis 集群的关键技术点</span></a></h4><h5 id="_1️⃣-数据分片-哈希槽-hash-slot-机制" tabindex="-1"><a class="header-anchor" href="#_1️⃣-数据分片-哈希槽-hash-slot-机制"><span>1️⃣ 数据分片：<strong>哈希槽（Hash Slot）机制</strong></span></a></h5><ul><li>Redis Cluster 将整个键空间划分为 <strong>16384 个哈希槽（hash slots）</strong></li><li>每个 key 通过 <code>CRC16(key) % 16384</code> 计算出对应的 slot</li><li>每个 Master 节点负责一部分 slot</li></ul><blockquote><p>💡 示例：</p><ul><li><code>user:1001</code> → slot 5000 → 由 Node A 管理</li><li><code>order:2002</code> → slot 12000 → 由 Node B 管理</li></ul></blockquote><p>✅ 好处：</p><ul><li>可扩展：增加节点时，只需迁移部分 slot</li><li>负载均衡：数据均匀分布</li></ul><hr><h5 id="_2️⃣-节点通信-gossip-协议" tabindex="-1"><a class="header-anchor" href="#_2️⃣-节点通信-gossip-协议"><span>2️⃣ 节点通信：<strong>Gossip 协议</strong></span></a></h5><h6 id="❓-什么是-gossip" tabindex="-1"><a class="header-anchor" href="#❓-什么是-gossip"><span>❓ 什么是 Gossip？</span></a></h6><p>一种去中心化的分布式通信协议，类似“流言传播”。</p><h6 id="✅-工作方式" tabindex="-1"><a class="header-anchor" href="#✅-工作方式"><span>✅ 工作方式：</span></a></h6><ul><li>每个 Redis 节点每隔一段时间（默认 1 秒）随机选择几个其他节点发送 <code>PING</code> 消息</li><li>接收方回复 <code>PONG</code></li><li>交换信息包括： <ul><li>节点状态（上线/下线）</li><li>所负责的 slot 范围</li><li>主从关系</li><li>故障信息</li></ul></li></ul><h6 id="✅-使用的端口" tabindex="-1"><a class="header-anchor" href="#✅-使用的端口"><span>✅ 使用的端口：</span></a></h6><ul><li><strong>客户端端口</strong>：如 <code>6379</code></li><li><strong>集群总线端口</strong>：<code>客户端端口 + 10000</code>，如 <code>16379</code></li></ul><blockquote><p>⚠️ 必须开放这两个端口之间的网络互通！</p></blockquote><hr><h5 id="_3️⃣-数据访问流程" tabindex="-1"><a class="header-anchor" href="#_3️⃣-数据访问流程"><span>3️⃣ 数据访问流程</span></a></h5><p>当客户端请求一个 key：</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">GET user:1001</span>
<span class="line">         ↓</span>
<span class="line">计算 CRC16(&quot;user:1001&quot;) % 16384 = 5000</span>
<span class="line">         ↓</span>
<span class="line">查询 cluster nodes 映射表 → slot 5000 属于 Node A</span>
<span class="line">         ↓</span>
<span class="line">请求被路由到 Node A 处理</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果客户端发错了节点，Redis 会返回：</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line">MOVED <span class="token number">5000</span> <span class="token number">192.168</span>.1.10:6379</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>告诉客户端：“这个 key 应该去这个地址找”。</p><p>✅ 支持 MOVED 重定向的客户端才能使用 Redis Cluster（如 Jedis、Lettuce）</p><hr><h5 id="_4️⃣-高可用-主从复制-故障转移" tabindex="-1"><a class="header-anchor" href="#_4️⃣-高可用-主从复制-故障转移"><span>4️⃣ 高可用：<strong>主从复制 + 故障转移</strong></span></a></h5><ul><li>每个 Master 可以配置一个或多个 Slave</li><li>Slave 实时同步 Master 数据（异步复制）</li><li>当 Master 宕机： <ul><li>其他节点通过 Gossip 发现它失联</li><li>达成共识后，由它的 Slave 发起选举</li><li>选票过半 → 升级为新 Master（自动故障转移）</li></ul></li></ul><blockquote><p>使用 <strong>Raft 算法的简化版</strong> 实现领导者选举</p></blockquote><hr><h5 id="_5️⃣-配置一致性-配置纪元-configuration-epoch" tabindex="-1"><a class="header-anchor" href="#_5️⃣-配置一致性-配置纪元-configuration-epoch"><span>5️⃣ 配置一致性：<strong>配置纪元（Configuration Epoch）</strong></span></a></h5><ul><li>每次发生故障转移时，生成一个新的 epoch 编号</li><li>用于解决脑裂场景下的冲突（谁才是真正的 Master）</li></ul><hr><h4 id="✅-四、其他-redis-集群方案对比" tabindex="-1"><a class="header-anchor" href="#✅-四、其他-redis-集群方案对比"><span>✅ 四、其他 Redis 集群方案对比</span></a></h4><table><thead><tr><th>方案</th><th>说明</th><th>是否需要额外组件</th></tr></thead><tbody><tr><td><strong>Redis Cluster（官方）</strong></td><td>去中心化，Gossip + Slot，支持自动故障转移</td><td>❌ 否</td></tr><tr><td><strong>Codis</strong></td><td>代理式集群，基于 ZooKeeper 管理路由</td><td>✅ 是（ZooKeeper + Proxy）</td></tr><tr><td><strong>Twemproxy（Nutcracker）</strong></td><td>早期分片代理，不支持动态扩缩容</td><td>✅ 是</td></tr><tr><td><strong>Redis Sentinel（哨兵）</strong></td><td>主从监控 + 故障转移，但不支持分片</td><td>✅ 是（Sentinel 进程）</td></tr></tbody></table><blockquote><p>✅ 推荐：生产环境优先使用 <strong>Redis Cluster</strong></p></blockquote><hr><h4 id="✅-五、redis-集群部署建议" tabindex="-1"><a class="header-anchor" href="#✅-五、redis-集群部署建议"><span>✅ 五、Redis 集群部署建议</span></a></h4><h5 id="🧩-最小推荐架构-6节点" tabindex="-1"><a class="header-anchor" href="#🧩-最小推荐架构-6节点"><span>🧩 最小推荐架构（6节点）：</span></a></h5><ul><li>3 个 Master（各负责约 5461 个 slot）</li><li>3 个 Slave（分别作为 Master 的备份）</li></ul><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">Master A (slot 0-5460) ← Slave A</span>
<span class="line">Master B (slot 5461-10921) ← Slave B</span>
<span class="line">Master C (slot 10922-16383) ← Slave C</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="🛠️-部署要点" tabindex="-1"><a class="header-anchor" href="#🛠️-部署要点"><span>🛠️ 部署要点：</span></a></h5><ol><li>所有节点必须能互相通信（开放 <code>6379</code> 和 <code>16379</code>）</li><li>使用支持 Cluster 的客户端</li><li>合理设置 <code>cluster-node-timeout</code>（默认 15s）</li><li>避免 bigkey 导致阻塞</li><li>开启 AOF 持久化（<code>appendonly yes</code>）</li></ol><hr><h4 id="✅-六、总结-redis-集群如何解决数据通信" tabindex="-1"><a class="header-anchor" href="#✅-六、总结-redis-集群如何解决数据通信"><span>✅ 六、总结：Redis 集群如何解决数据通信？</span></a></h4><table><thead><tr><th>问题</th><th>解决方案</th></tr></thead><tbody><tr><td><strong>数据怎么分布？</strong></td><td>使用 <strong>16384 个哈希槽</strong>，按 key 分配到不同节点</td></tr><tr><td><strong>节点如何通信？</strong></td><td>通过 <strong>Gossip 协议</strong> 在 <strong>Cluster Bus</strong> 上交换状态</td></tr><tr><td><strong>客户端怎么找到 key？</strong></td><td>返回 <code>MOVED</code> 或 <code>ASK</code> 重定向</td></tr><tr><td><strong>主节点挂了怎么办？</strong></td><td>Slave 触发故障转移，通过 Raft 类共识选举</td></tr><tr><td><strong>数据一致性？</strong></td><td>异步复制为主，可通过 <code>min-replicas-to-write</code> 控制写安全</td></tr></tbody></table><hr><h5 id="🎯-最佳实践建议" tabindex="-1"><a class="header-anchor" href="#🎯-最佳实践建议"><span>🎯 最佳实践建议：</span></a></h5><blockquote><ul><li>生产环境使用 <strong>Redis Cluster + 哨兵（可选监控）</strong></li><li>避免跨机房部署 Cluster（延迟高，易误判宕机）</li><li>使用 Pipeline 和批量操作提升性能</li><li>监控节点心跳、slot 分布、复制延迟</li></ul></blockquote><hr><h3 id="redission怎么用" tabindex="-1"><a class="header-anchor" href="#redission怎么用"><span>Redission怎么用？</span></a></h3><h3 id="对于p30后端返回message格式的思考" tabindex="-1"><a class="header-anchor" href="#对于p30后端返回message格式的思考"><span>对于P30后端返回message格式的思考</span></a></h3><p>返回响应体中有一项contactId，代表了联系人id，也就是接收人的id。</p><p>但在前端项目中，似乎是直接将接收到的json中的contactid转为了当前消息联系人的id，而以我们的视角来看，接收人id就是他自己，这一部分设计存在问题，但是出于不想修改客户端，我们直接在后端将发送的消息的contactid改为了发送者id。</p><p>这一设计存在很大的问题，后端最好还是将逻辑清晰的数据作为响应体发送给前端，前端对接收到的信息作额外处理，将每条消息的联系人id从响应体中的发送人id这一项中取出。</p><p>若不作此修改，前后端的耦合程度较大，后续维护理解起来也会比较麻烦，算是项目中比较大的设计错误之一。</p><h3 id="java的stream流式传输文件" tabindex="-1"><a class="header-anchor" href="#java的stream流式传输文件"><span>Java的stream流式传输文件</span></a></h3>`,281)),n("p",null,[s[4]||(s[4]=a("注意返回类型改为void，否则spring会尝试给响应结果找一个合适的响应对象，找不到就会抛出异常HttpMessageNotWritableException：",-1)),n("a",k,[s[3]||(s[3]=a("下载/导出问题（统一返回）：No converter for xxx with preset Content-Type ‘application/octet-stream；charset=UTF-8-CSDN博客",-1)),t(e)])]),s[8]||(s[8]=n("h3",{id:"b-树",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#b-树"},[n("span",null,"B+树")])],-1)),s[9]||(s[9]=n("h3",{id:"io多路复用与多线程",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#io多路复用与多线程"},[n("span",null,"IO多路复用与多线程")])],-1)),n("p",null,[n("a",h,[s[5]||(s[5]=a("【网络】高并发场景处理：线程池和IO多路复用-阿里云开发者社区",-1)),t(e)])]),s[10]||(s[10]=p(`<h3 id="multipart文件" tabindex="-1"><a class="header-anchor" href="#multipart文件"><span>Multipart文件</span></a></h3><h3 id="orm框架" tabindex="-1"><a class="header-anchor" href="#orm框架"><span>ORM框架</span></a></h3><p>MyBatis 和 Hibernate 都是 Java 领域流行的持久层框架，用于简化数据库操作，但它们的设计理念和工作方式有根本性的区别。</p><h4 id="核心区别" tabindex="-1"><a class="header-anchor" href="#核心区别"><span>核心区别</span></a></h4><p>最核心的区别在于：</p><ul><li><strong>MyBatis 是一个“半自动化”的 SQL 映射框架。</strong></li><li><strong>Hibernate 是一个全自动的 ORM（对象关系映射）框架。</strong></li></ul><p>这个根本区别导致了它们在 SQL 处理、开发方式、灵活性和学习曲线上的不同。</p><hr><h4 id="为什么说-hibernate-不需要写-sql" tabindex="-1"><a class="header-anchor" href="#为什么说-hibernate-不需要写-sql"><span>为什么说 Hibernate 不需要写 SQL？</span></a></h4><p>说 Hibernate “不需要写 SQL” 是一个<strong>相对和简化</strong>的说法。更准确地说，Hibernate 允许开发者<strong>完全不手写原生的 SQL 语句</strong>，而是通过操作 Java 对象（POJO）和使用 HQL (Hibernate Query Language) 或 Criteria API 来实现数据库操作。</p><h5 id="它是如何实现的" tabindex="-1"><a class="header-anchor" href="#它是如何实现的"><span>它是如何实现的？</span></a></h5><ol><li><p><strong>对象关系映射 (ORM)：</strong></p><ul><li>你首先定义一个 Java 类（实体类，Entity），比如 <code>User</code>。</li><li>通过注解（如 <code>@Entity</code>, <code>@Table</code>, <code>@Id</code>, <code>@Column</code>）或 XML 配置文件，你告诉 Hibernate 这个 <code>User</code> 类对应数据库中的 <code>user</code> 表，<code>User</code> 类的 <code>id</code> 属性对应 <code>user</code> 表的 <code>id</code> 列，<code>name</code> 属性对应 <code>name</code> 列，等等。</li><li>Hibernate 在启动时会读取这些元数据（Metadata），建立起 Java 对象与数据库表之间的映射关系。</li></ul></li><li><p><strong>自动生成 SQL：</strong></p><ul><li><p>当你调用 Hibernate 的 API 进行操作时，例如：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token class-name">User</span> user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">user<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">&quot;张三&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">session<span class="token punctuation">.</span><span class="token function">save</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 保存</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>Hibernate 会根据</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">User</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>类的映射元数据，</p><p>在内部自动生成</p><p>对应的 SQL 语句：</p><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql" data-title="sql"><pre><code><span class="line"><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token keyword">user</span> <span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">&#39;张三&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li><li><p>同样地，<code>session.get(User.class, 1)</code> 会生成 <code>SELECT * FROM user WHERE id = 1;</code>。</p></li></ul></li><li><p><strong>查询语言 (HQL &amp; Criteria API)：</strong></p><ul><li><p>HQL (Hibernate Query Language):</p><p>这是一种面向对象的查询语言。你查询的是</p><p>对象和属性</p><p>，而不是数据库的表和列。</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token comment">// 查询所有 name 为 &quot;张三&quot; 的 User 对象</span></span>
<span class="line"><span class="token class-name">Query</span> query <span class="token operator">=</span> session<span class="token punctuation">.</span><span class="token function">createQuery</span><span class="token punctuation">(</span><span class="token string">&quot;FROM User WHERE name = :name&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">query<span class="token punctuation">.</span><span class="token function">setParameter</span><span class="token punctuation">(</span><span class="token string">&quot;name&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;张三&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> users <span class="token operator">=</span> query<span class="token punctuation">.</span><span class="token function">list</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Hibernate 会将这条 HQL 翻译成等效的 SQL 语句去执行。</p></li><li><p>Criteria API:</p><p>这是一种类型安全的、以编程方式构建查询的 API。</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token class-name">CriteriaBuilder</span> cb <span class="token operator">=</span> session<span class="token punctuation">.</span><span class="token function">getCriteriaBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">CriteriaQuery</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> cq <span class="token operator">=</span> cb<span class="token punctuation">.</span><span class="token function">createQuery</span><span class="token punctuation">(</span><span class="token class-name">User</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">Root</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> root <span class="token operator">=</span> cq<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token class-name">User</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">cq<span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">where</span><span class="token punctuation">(</span>cb<span class="token punctuation">.</span><span class="token function">equal</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">&quot;name&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">&quot;张三&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> users <span class="token operator">=</span> session<span class="token punctuation">.</span><span class="token function">createQuery</span><span class="token punctuation">(</span>cq<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getResultList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这同样会被 Hibernate 翻译成 SQL。</p></li></ul></li></ol><p><strong>总结“不需要 SQL”：</strong> 开发者只需要关注 Java 对象和业务逻辑，通过调用 Hibernate 提供的 API 或编写 HQL，Hibernate 框架会负责将这些操作“翻译”成数据库能理解的原生 SQL 并执行。开发者无需关心底层 SQL 的具体语法。</p><hr><h4 id="mybatis-如何工作" tabindex="-1"><a class="header-anchor" href="#mybatis-如何工作"><span>MyBatis 如何工作？</span></a></h4><p>MyBatis 则采取了不同的策略：</p><ol><li><strong>SQL 显式化：</strong> MyBatis 要求开发者<strong>自己编写 SQL 语句</strong>。这些 SQL 通常写在 XML 映射文件中，或者使用注解直接写在 Mapper 接口上。</li><li><strong>结果映射：</strong> 你编写好 SQL 后，需要定义一个 <code>&lt;resultMap&gt;</code> 或使用自动映射，来告诉 MyBatis 如何将 SQL 执行后返回的 <code>ResultSet</code>（结果集）中的列，映射到 Java 对象的属性上。</li><li>执行过程： <ul><li>你调用一个 Mapper 接口的方法（如 <code>userMapper.selectById(1)</code>）。</li><li>MyBatis 框架找到这个方法对应的 SQL 语句（比如 <code>SELECT * FROM user WHERE id = #{id}</code>）。</li><li>MyBatis 将参数（1）填充到 SQL 中，执行查询。</li><li>MyBatis 将查询结果（<code>ResultSet</code>）根据你定义的映射规则，封装成你指定的 Java 对象（如 <code>User</code> 对象）并返回。</li></ul></li></ol><p><strong>关键点：</strong> MyBatis 的核心是<strong>SQL 映射</strong>，它不生成 SQL，而是帮你执行你写好的 SQL，并处理参数和结果集的转换。</p><hr><h4 id="对比总结" tabindex="-1"><a class="header-anchor" href="#对比总结"><span>对比总结</span></a></h4><table><thead><tr><th>特性</th><th>Hibernate</th><th>MyBatis</th></tr></thead><tbody><tr><td><strong>核心理念</strong></td><td>全自动 ORM，操作对象</td><td>半自动 SQL 映射，操作 SQL</td></tr><tr><td><strong>SQL 编写</strong></td><td><strong>不需要</strong>手写原生 SQL (使用 HQL/Criteria)</td><td><strong>必须</strong>手写原生 SQL</td></tr><tr><td><strong>SQL 控制力</strong></td><td>弱。SQL 由框架生成，难以进行复杂的、特定于数据库的优化。</td><td><strong>强</strong>。开发者完全掌控 SQL，可以进行任何优化（如使用特定数据库函数、复杂连接、存储过程）。</td></tr><tr><td><strong>学习曲线</strong></td><td>较陡峭。需要理解 ORM 概念、缓存、延迟加载、Session 生命周期、HQL 等。</td><td>相对平缓。对熟悉 SQL 的开发者来说，更容易上手。</td></tr><tr><td><strong>数据库移植性</strong></td><td><strong>高</strong>。HQL 是数据库无关的，更换数据库通常只需修改方言配置。</td><td><strong>低</strong>。SQL 通常是特定于数据库的，更换数据库可能需要重写 SQL。</td></tr><tr><td><strong>开发效率</strong></td><td>对于简单 CRUD 极高，自动生成 SQL。</td><td>需要为每个操作编写 SQL，初期开发效率可能较低。</td></tr><tr><td><strong>性能</strong></td><td>对于简单操作足够好，但复杂查询可能生成低效 SQL。</td><td>可以通过优化 SQL 达到最佳性能。</td></tr><tr><td><strong>适用场景</strong></td><td>业务模型稳定、以 CRUD 为主、追求快速开发、需要高移植性的项目。</td><td>需要复杂 SQL、高性能要求、遗留系统、SQL 技能强的团队。</td></tr></tbody></table><p><strong>简单来说：</strong></p><ul><li><strong>用 Hibernate，你告诉框架“我要做什么”</strong>（比如“保存这个用户对象”），框架帮你生成并执行 SQL。</li><li><strong>用 MyBatis，你告诉框架“SQL 怎么做”</strong>，框架帮你执行并把结果给你。</li></ul><h4 id="mybatis-plus" tabindex="-1"><a class="header-anchor" href="#mybatis-plus"><span>MyBatis-Plus</span></a></h4><p><strong>MyBatis-Plus (MP) 本质上仍然是一个“半自动化”的 SQL 映射框架，它没有改变 MyBatis 的核心定位，因此不能算作像 Hibernate 那样的“全自动 ORM”。</strong></p><p>你可以把 MyBatis-Plus 理解为 <strong>“MyBatis 的超级增强版”</strong> 或 <strong>“MyBatis 的生产力工具集”</strong>。它在 MyBatis 的基础上，通过大量自动化和便捷的功能，<strong>极大地减少了开发者需要手写的 SQL 和代码量</strong>，使其在使用体验上更接近全自动 ORM 的便捷性，但其底层原理和核心思想依然是基于显式 SQL 映射的。</p><hr><h4 id="为什么说-mybatis-plus-不是全自动-orm" tabindex="-1"><a class="header-anchor" href="#为什么说-mybatis-plus-不是全自动-orm"><span>为什么说 MyBatis-Plus 不是全自动 ORM？</span></a></h4><ol><li><strong>核心依赖 MyBatis：</strong><ul><li>MP 的底层依然是 MyBatis。它所有的 CRUD 操作最终都是通过 MyBatis 的 <code>Mapper</code> 接口和 SQL 映射（XML 或注解）来执行的。</li><li>它只是帮你<strong>自动生成了这些基础的 SQL 映射</strong>，而不是像 Hibernate 那样在运行时动态解析 HQL 并生成 SQL。</li></ul></li><li><strong>SQL 依然存在且可见：</strong><ul><li>虽然 MP 的 <code>BaseMapper</code> 提供了 <code>selectById</code>, <code>insert</code>, <code>updateById</code>, <code>delete</code> 等方法，你不需要为这些通用操作写 SQL，但这些 SQL 是 MP <strong>在内部预先定义好</strong>的模板。</li><li>你可以通过日志清晰地看到 MP 为你生成和执行的 SQL 语句。SQL 是框架的一部分，而不是对开发者完全透明。</li></ul></li><li><strong>复杂查询仍需手写 SQL：</strong><ul><li>当遇到复杂的关联查询（JOIN）、子查询、特定数据库函数、存储过程等场景时，MP 的通用方法无法满足。</li><li>此时，你仍然需要像使用原生 MyBatis 一样，创建自定义的 Mapper 方法，并在 XML 中编写 SQL 或使用 <code>@Select</code> 等注解。这完全暴露了 SQL。</li></ul></li><li><strong>核心理念是“增强”而非“替代”：</strong><ul><li>MyBatis-Plus 的设计目标是“<strong>为简化开发而生</strong>”，它通过 <code>BaseMapper</code>、<code>Service</code> 层封装、<code>Lambda</code> 查询、<code>自动填充</code>、<code>逻辑删除</code> 等功能，<strong>消灭了 80% 的简单 CRUD SQL 编写工作</strong>。</li><li>但它保留了 MyBatis 对 SQL 的完全控制力，让开发者在需要时可以随时介入并编写高性能、复杂的 SQL。</li></ul></li></ol><hr><h4 id="mybatis-plus-如何实现-类全自动-的便捷性" tabindex="-1"><a class="header-anchor" href="#mybatis-plus-如何实现-类全自动-的便捷性"><span>MyBatis-Plus 如何实现“类全自动”的便捷性？</span></a></h4><p>尽管不是全自动 ORM，但 MP 通过以下方式实现了接近全自动的开发效率：</p><ul><li><p><strong>通用 Mapper (<code>BaseMapper</code>)：</strong> 提供了 <code>insert</code>, <code>delete</code>, <code>update</code>, <code>select</code> 等通用方法，无需任何 SQL 配置即可使用。</p></li><li><p><strong>通用 Service (<code>IService</code>)：</strong> 在 <code>BaseMapper</code> 基础上，封装了更复杂的业务逻辑方法，如 <code>saveOrUpdate</code>, <code>list</code>, <code>page</code> 等。</p></li><li><p><strong>条件构造器</strong> (QueryWrapper, LambdaQueryWrapper)：</p><p>允许你用 Java 代码链式编程的方式来构建查询条件，避免了拼接 SQL 字符串的麻烦。虽然最终会生成 SQL，但开发者无需直接写 SQL 文本。</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token comment">// 使用 MP 的 LambdaQueryWrapper，无需写 SQL</span></span>
<span class="line"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> users <span class="token operator">=</span> userMapper<span class="token punctuation">.</span><span class="token function">selectList</span><span class="token punctuation">(</span></span>
<span class="line">    <span class="token keyword">new</span> <span class="token class-name">LambdaQueryWrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line">        <span class="token punctuation">.</span><span class="token function">eq</span><span class="token punctuation">(</span><span class="token class-name">User</span><span class="token operator">::</span><span class="token function">getName</span><span class="token punctuation">,</span> <span class="token string">&quot;张三&quot;</span><span class="token punctuation">)</span></span>
<span class="line">        <span class="token punctuation">.</span><span class="token function">gt</span><span class="token punctuation">(</span><span class="token class-name">User</span><span class="token operator">::</span><span class="token function">getAge</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span></span>
<span class="line">        <span class="token punctuation">.</span><span class="token function">orderByDesc</span><span class="token punctuation">(</span><span class="token class-name">User</span><span class="token operator">::</span><span class="token function">getCreateTime</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token comment">// 这会被 MP 翻译成: SELECT * FROM user WHERE name = &#39;张三&#39; AND age &gt; 18 ORDER BY create_time DESC</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>代码生成器：</strong> 可以根据数据库表结构一键生成 Entity、Mapper、Service、Controller 等全套代码，包括基础的 Mapper XML。</p></li></ul><hr><h4 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h4><table><thead><tr><th>特性</th><th>Hibernate (全自动 ORM)</th><th>MyBatis-Plus (MyBatis 增强)</th></tr></thead><tbody><tr><td><strong>SQL 生成</strong></td><td>运行时动态生成，对开发者透明</td><td>使用预定义模板或条件构造器生成，SQL 可见</td></tr><tr><td><strong>SQL 控制</strong></td><td>弱，受限于 HQL 和框架生成能力</td><td><strong>强</strong>，可通过自定义 SQL 完全掌控</td></tr><tr><td><strong>开发便捷性 (简单CRUD)</strong></td><td>⭐⭐⭐⭐⭐</td><td>⭐⭐⭐⭐⭐ (借助 MP)</td></tr><tr><td><strong>开发便捷性 (复杂查询)</strong></td><td>⭐⭐⭐⭐</td><td>⭐⭐⭐ (仍需手写 SQL)</td></tr><tr><td><strong>性能优化</strong></td><td>依赖框架，较难深度优化</td><td>可直接优化 SQL，性能潜力高</td></tr><tr><td><strong>学习成本</strong></td><td>高 (需理解 ORM 概念)</td><td>中等 (熟悉 MyBatis + MP 特性)</td></tr></tbody></table><p><strong>结论：</strong> MyBatis-Plus <strong>不是</strong>全自动 ORM。它是在 MyBatis 这个半自动框架的基础上，通过提供强大的自动化工具和通用组件，<strong>极大地提升了开发效率，让开发者在享受 ORM 便捷性的同时，依然保留了对 SQL 的最终控制权</strong>。它更像是一个“<strong>智能化的 SQL 映射框架</strong>”，而非一个纯粹的“对象关系映射”框架。</p><h3 id="mvn的java版本为何与控制台输出的版本不同" tabindex="-1"><a class="header-anchor" href="#mvn的java版本为何与控制台输出的版本不同"><span>mvn的java版本为何与控制台输出的版本不同？</span></a></h3><p>这个问题涉及到系统中多个Java版本的共存和使用优先级。以下是详细解释：</p><h4 id="环境变量配置差异" tabindex="-1"><a class="header-anchor" href="#环境变量配置差异"><span>环境变量配置差异</span></a></h4><ul><li><strong><code>java -version</code></strong> 显示的是系统 <code>PATH</code> 环境变量中找到的第一个 <code>java</code> 命令，这里指向的是 Java 22</li><li><strong><code>mvn -v</code></strong> 显示的是 Maven 运行时使用的 Java 环境，这里通过 <code>JAVA_HOME</code> 指向了 Java 11</li></ul><h4 id="具体原因分析" tabindex="-1"><a class="header-anchor" href="#具体原因分析"><span>具体原因分析</span></a></h4><ol><li><p><strong>PATH环境变量优先级</strong></p><ul><li>系统 <code>PATH</code> 中 Java 22 的路径排在前面</li><li>所以在命令行直接执行 <code>java</code> 时使用的是 Java 22</li></ul></li><li><p><strong>Maven的Java版本选择机制</strong></p><ul><li>Maven 优先使用 <code>JAVA_HOME</code> 环境变量指定的Java版本</li><li>如果 <code>JAVA_HOME</code> 未设置，则使用 <code>PATH</code> 中的 <code>java</code> 命令</li></ul></li><li><p><strong>环境变量配置</strong></p><ul><li><code>JAVA_HOME</code> = <code>C:\\Program Files\\Java\\jdk-11</code></li><li><code>PATH</code> 中同时包含了 Java 22 和 Java 11 的路径</li></ul></li></ol><h4 id="验证方法" tabindex="-1"><a class="header-anchor" href="#验证方法"><span>验证方法</span></a></h4><p>可以使用以下命令验证环境变量配置：</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line"><span class="token builtin class-name">echo</span> %JAVA_HOME%</span>
<span class="line">where <span class="token function">java</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>这种配置方式在开发环境中很常见，允许不同工具使用不同版本的Java运行时。</p><h4 id="修改mvn的java版本" tabindex="-1"><a class="header-anchor" href="#修改mvn的java版本"><span>修改mvn的java版本</span></a></h4><ol><li><p>修改环境变量的<code>JAVA_HOME</code></p></li><li><p><code>mvn clean</code>并退出ide（如果使用ide）</p></li><li><p>重启后再次尝试install</p></li></ol><h3 id="spring-boot应用关闭时操作" tabindex="-1"><a class="header-anchor" href="#spring-boot应用关闭时操作"><span>Spring Boot应用关闭时操作</span></a></h3><p>在Spring Boot应用关闭时删除Redis缓存，你可以使用以下几种方式：</p><ol><li><strong>使用@PreDestroy注解</strong><ul><li>在任意Spring管理的Bean中添加一个带有<code>@PreDestroy</code>注解的方法，在应用关闭前会自动执行该方法</li></ul></li></ol><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token annotation punctuation">@Component</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RedisCleanupService</span> <span class="token punctuation">{</span></span>
<span class="line">    </span>
<span class="line">    <span class="token annotation punctuation">@Autowired</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token class-name">RedisTemplate</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> redisTemplate<span class="token punctuation">;</span></span>
<span class="line">    </span>
<span class="line">    <span class="token annotation punctuation">@PreDestroy</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">cleanUp</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token comment">// 删除指定的缓存键</span></span>
<span class="line">        redisTemplate<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token string">&quot;your-cache-key&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token comment">// 或者删除匹配模式的键</span></span>
<span class="line">        <span class="token comment">// Set&lt;String&gt; keys = redisTemplate.keys(&quot;pattern*&quot;);</span></span>
<span class="line">        <span class="token comment">// redisTemplate.delete(keys);</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li><strong>实现DisposableBean接口</strong></li></ol><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token annotation punctuation">@Component</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RedisCleanupService</span> <span class="token keyword">implements</span> <span class="token class-name">DisposableBean</span> <span class="token punctuation">{</span></span>
<span class="line">    </span>
<span class="line">    <span class="token annotation punctuation">@Autowired</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token class-name">RedisTemplate</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> redisTemplate<span class="token punctuation">;</span></span>
<span class="line">    </span>
<span class="line">    <span class="token annotation punctuation">@Override</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token comment">// 应用关闭时执行清理工作</span></span>
<span class="line">        redisTemplate<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token string">&quot;your-cache-key&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3"><li><strong>监听ContextClosedEvent事件</strong></li></ol><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token annotation punctuation">@Component</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RedisCleanupListener</span> <span class="token punctuation">{</span></span>
<span class="line">    </span>
<span class="line">    <span class="token annotation punctuation">@Autowired</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token class-name">RedisTemplate</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> redisTemplate<span class="token punctuation">;</span></span>
<span class="line">    </span>
<span class="line">    <span class="token annotation punctuation">@EventListener</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handleContextClosedEvent</span><span class="token punctuation">(</span><span class="token class-name">ContextClosedEvent</span> event<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token comment">// 应用关闭时删除Redis缓存</span></span>
<span class="line">        redisTemplate<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token string">&quot;your-cache-key&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>推荐使用第一种方式(<code>@PreDestroy</code>)，这是最简单且常用的方式。你需要将清理逻辑放在Spring管理的组件中，并注入<code>RedisTemplate</code>来操作Redis。</p><h3 id="延时双删解决缓存数据一致性" tabindex="-1"><a class="header-anchor" href="#延时双删解决缓存数据一致性"><span>延时双删解决缓存数据一致性</span></a></h3><h3 id="redis分布式锁解决缓存数据一致性" tabindex="-1"><a class="header-anchor" href="#redis分布式锁解决缓存数据一致性"><span>redis分布式锁解决缓存数据一致性</span></a></h3><h3 id="aop与代理-事务" tabindex="-1"><a class="header-anchor" href="#aop与代理-事务"><span>AOP与代理，事务</span></a></h3><table><thead><tr><th>概念</th><th>说明</th></tr></thead><tbody><tr><td><strong>AOP</strong></td><td>一种编程思想，用于解耦横切关注点</td></tr><tr><td><strong>代理（Proxy）</strong></td><td>Spring AOP 的底层实现机制</td></tr><tr><td><strong>JDK 动态代理</strong></td><td>基于接口，使用反射</td></tr><tr><td><strong>CGLIB 代理</strong></td><td>基于继承，生成子类</td></tr><tr><td><strong>关键限制</strong></td><td>自调用（self-invocation）不触发 AOP</td></tr></tbody></table><p>aop基于动态代理实现</p><p>代理：实现了一个或多个接口-&gt;jdk代理</p><p>​ 无实现接口-&gt;cglib代理</p><p>事务基于aop发现增强，当某一个bean内部发现事务注解（或其他aop增强）时，就会生成动态代理强化实现：</p><ol><li><p><strong>定义 Bean</strong></p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token annotation punctuation">@Service</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OrderService</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>→ Spring 扫描到它，准备将其注册为名为 <code>orderService</code> 的 Bean。</p></li><li><p><strong>发现需要 AOP 增强（比如有 <code>@Transactional</code>）</strong></p><p>→ Spring 决定：不能直接把原始 <code>OrderService</code> 实例放入容器，而是要<strong>包装成代理对象</strong>。</p></li><li><p><strong>创建代理对象</strong></p><ul><li>如果 <code>OrderService</code> 实现了接口 → 使用 JDK 动态代理；</li><li>否则 → 使用 CGLIB 生成子类代理；</li><li>代理对象内部持有对原始 <code>OrderService</code> 实例的引用。</li></ul></li><li><p><strong>将代理对象注册为 Bean</strong></p><ul><li>容器中 <code>orderService</code> 这个 Bean 的实际类型是 <code>OrderService$$EnhancerBySpringCGLIB...</code>；</li><li>但它的<strong>逻辑身份</strong>仍然是 <code>OrderService</code>；</li><li>所有 <code>@Autowired OrderService</code> 注入的都是这个代理对象。</li></ul></li></ol><p>一般我们将<code>@Service</code>注解放到impl实现类上，这时<strong>加了 AOP 相关注解（如 <code>@Transactional</code>）→ 会生成代理</strong></p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token annotation punctuation">@Service</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OrderServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">OrderService</span> <span class="token punctuation">{</span></span>
<span class="line"></span>
<span class="line">    <span class="token annotation punctuation">@Transactional</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">createOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>此时 Spring 检测到方法需要事务增强；</li><li>因为 <code>OrderServiceImpl</code> <strong>实现了接口 <code>OrderService</code></strong>，</li><li>Spring <strong>默认使用 JDK 动态代理</strong>（代理的是 <code>OrderService</code> 接口）。</li></ul><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">代理对象.createOrder() </span>
<span class="line">   → 执行前置增强（如开启事务）</span>
<span class="line">   → 调用 真实OrderService.createOrder()</span>
<span class="line">   → 执行后置增强（如提交事务）</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><table><thead><tr><th>条件</th><th>使用的代理</th></tr></thead><tbody><tr><td>目标类 <strong>实现了至少一个接口</strong></td><td><strong>JDK 动态代理</strong>（代理接口）</td></tr><tr><td>目标类 <strong>没有实现任何接口</strong></td><td><strong>CGLIB 代理</strong>（继承目标类）</td></tr></tbody></table><p>从新梳理一遍，我们一般使用的ioc容器中的<strong>bean对象</strong>默认被Spring控制的是<strong>原本的实例</strong>，而当发现需要<strong>aop增强</strong>（如事务注解）时，就会基于动态代理<strong>包装</strong>原本的bean（不会生成两个bean），使其具有原本实例所不具有的功能。</p><p>我们可以简单理解代理对象proxy为对原本bean的增强。</p><p>代理对象的应用：</p><table><thead><tr><th>应用场景</th><th>典型注解 / 技术</th><th>作用说明</th></tr></thead><tbody><tr><td><strong>事务管理</strong></td><td><code>@Transactional</code></td><td>方法执行前后自动开启、提交或回滚数据库事务</td></tr><tr><td><strong>缓存</strong></td><td><code>@Cacheable</code>, <code>@CacheEvict</code></td><td>自动缓存方法结果，避免重复计算或数据库查询</td></tr><tr><td><strong>安全控制</strong></td><td><code>@PreAuthorize</code>, <code>@Secured</code></td><td>方法调用前校验用户权限或角色</td></tr><tr><td><strong>日志与监控</strong></td><td>自定义 AOP 切面</td><td>记录方法执行时间、参数、异常等，用于调试或性能分析</td></tr><tr><td><strong>异步执行</strong></td><td><code>@Async</code></td><td>方法在独立线程中异步执行，不阻塞主线程</td></tr><tr><td><strong>延迟加载</strong></td><td>Hibernate / JPA 代理</td><td>关联对象在首次访问时才从数据库加载</td></tr><tr><td><strong>远程调用</strong></td><td>Feign, Dubbo, RMI</td><td>本地调用代理，代理负责网络通信和序列化</td></tr><tr><td><strong>重试机制</strong></td><td><code>@Retryable</code>（Spring Retry）</td><td>方法失败时自动按策略重试</td></tr><tr><td><strong>参数校验</strong></td><td>自定义 AOP 或 <code>@Valid</code> 配合</td><td>在方法执行前统一校验输入合法性</td></tr><tr><td><strong>资源管理</strong></td><td>自定义代理逻辑</td><td>自动获取/释放连接、文件等资源（较少见，多用 try-with-resources）</td></tr></tbody></table>`,76))])}const b=l(r,[["render",v]]),y=JSON.parse('{"path":"/docs/wx/houduanbufen/yudaodewenti（houduan.html","title":"遇到的问题（后端）","lang":"en-US","frontmatter":{"title":"遇到的问题（后端）","date":"2025-11-28T00:00:00.000Z"},"headers":[{"level":3,"title":"什么是枚举？","slug":"什么是枚举","link":"#什么是枚举","children":[]},{"level":3,"title":"如何避免生成用户ID时的重复问题","slug":"如何避免生成用户id时的重复问题","link":"#如何避免生成用户id时的重复问题","children":[]},{"level":3,"title":"如何实现登录挤掉其他正在使用该账户的人？","slug":"如何实现登录挤掉其他正在使用该账户的人","link":"#如何实现登录挤掉其他正在使用该账户的人","children":[]},{"level":3,"title":"跨域了怎么办？实际情况下怎么处理最妥当？","slug":"跨域了怎么办-实际情况下怎么处理最妥当","link":"#跨域了怎么办-实际情况下怎么处理最妥当","children":[]},{"level":3,"title":"怎么检查表头比较好？拦截器还是AOP？怎么实现？","slug":"怎么检查表头比较好-拦截器还是aop-怎么实现","link":"#怎么检查表头比较好-拦截器还是aop-怎么实现","children":[]},{"level":3,"title":"拦截器和AOP一块使用的情况下会冲突吗？执行顺序是什么？","slug":"拦截器和aop一块使用的情况下会冲突吗-执行顺序是什么","link":"#拦截器和aop一块使用的情况下会冲突吗-执行顺序是什么","children":[]},{"level":3,"title":"事务失效","slug":"事务失效","link":"#事务失效","children":[]},{"level":3,"title":"ThreadLocal是什么？怎么用？","slug":"threadlocal是什么-怎么用","link":"#threadlocal是什么-怎么用","children":[]},{"level":3,"title":"AOP无论什么都抛出UndeclaredThrowableException，无法声明受检抛出异常是怎么回事","slug":"aop无论什么都抛出undeclaredthrowableexception-无法声明受检抛出异常是怎么回事","link":"#aop无论什么都抛出undeclaredthrowableexception-无法声明受检抛出异常是怎么回事","children":[]},{"level":3,"title":"Validated干什么的","slug":"validated干什么的","link":"#validated干什么的","children":[]},{"level":3,"title":"乐观锁是什么？为什么需要他？怎么用？","slug":"乐观锁是什么-为什么需要他-怎么用","link":"#乐观锁是什么-为什么需要他-怎么用","children":[]},{"level":3,"title":"mysql数据库的隔离怎么实现的？事务隔离，MVCC，锁都是什么？","slug":"mysql数据库的隔离怎么实现的-事务隔离-mvcc-锁都是什么","link":"#mysql数据库的隔离怎么实现的-事务隔离-mvcc-锁都是什么","children":[]},{"level":3,"title":"mybatis基础","slug":"mybatis基础","link":"#mybatis基础","children":[]},{"level":3,"title":"为什么使用WebSocket实现信息通信？","slug":"为什么使用websocket实现信息通信","link":"#为什么使用websocket实现信息通信","children":[]},{"level":3,"title":"多机部署（集群环境）下，如何实现用户跨服务器通信？","slug":"多机部署-集群环境-下-如何实现用户跨服务器通信","link":"#多机部署-集群环境-下-如何实现用户跨服务器通信","children":[]},{"level":3,"title":"SpringBoot和netty对与线程的管理","slug":"springboot和netty对与线程的管理","link":"#springboot和netty对与线程的管理","children":[]},{"level":3,"title":"Session数据库缓存结构？怎么实现缓存用户消息的？","slug":"session数据库缓存结构-怎么实现缓存用户消息的","link":"#session数据库缓存结构-怎么实现缓存用户消息的","children":[]},{"level":3,"title":"为什么需要会话Session记录表？","slug":"为什么需要会话session记录表","link":"#为什么需要会话session记录表","children":[]},{"level":3,"title":"Redis 的 Hash 是怎么实现的？","slug":"redis-的-hash-是怎么实现的","link":"#redis-的-hash-是怎么实现的","children":[]},{"level":3,"title":"多个数据库的集群部署该如何设计以解决数据库之间消息通信的问题？redis呢？","slug":"多个数据库的集群部署该如何设计以解决数据库之间消息通信的问题-redis呢","link":"#多个数据库的集群部署该如何设计以解决数据库之间消息通信的问题-redis呢","children":[]},{"level":3,"title":"Redission怎么用？","slug":"redission怎么用","link":"#redission怎么用","children":[]},{"level":3,"title":"对于P30后端返回message格式的思考","slug":"对于p30后端返回message格式的思考","link":"#对于p30后端返回message格式的思考","children":[]},{"level":3,"title":"Java的stream流式传输文件","slug":"java的stream流式传输文件","link":"#java的stream流式传输文件","children":[]},{"level":3,"title":"B+树","slug":"b-树","link":"#b-树","children":[]},{"level":3,"title":"IO多路复用与多线程","slug":"io多路复用与多线程","link":"#io多路复用与多线程","children":[]},{"level":3,"title":"Multipart文件","slug":"multipart文件","link":"#multipart文件","children":[]},{"level":3,"title":"ORM框架","slug":"orm框架","link":"#orm框架","children":[]},{"level":3,"title":"mvn的java版本为何与控制台输出的版本不同？","slug":"mvn的java版本为何与控制台输出的版本不同","link":"#mvn的java版本为何与控制台输出的版本不同","children":[]},{"level":3,"title":"Spring Boot应用关闭时操作","slug":"spring-boot应用关闭时操作","link":"#spring-boot应用关闭时操作","children":[]},{"level":3,"title":"延时双删解决缓存数据一致性","slug":"延时双删解决缓存数据一致性","link":"#延时双删解决缓存数据一致性","children":[]},{"level":3,"title":"redis分布式锁解决缓存数据一致性","slug":"redis分布式锁解决缓存数据一致性","link":"#redis分布式锁解决缓存数据一致性","children":[]},{"level":3,"title":"AOP与代理，事务","slug":"aop与代理-事务","link":"#aop与代理-事务","children":[]}],"git":{"createdTime":1771155821000,"updatedTime":1771155821000,"contributors":[{"name":"SaltFishGC","email":"130335482+SaltFishGC@users.noreply.github.com","commits":1}]},"filePathRelative":"docs/wx/后端部分/遇到的问题（后端.md"}');export{b as comp,y as data};
