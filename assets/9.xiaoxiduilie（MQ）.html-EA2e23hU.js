import{_ as i,c as p,e as l,a,b as s,d as e,r as o,o as c}from"./app-ifxsENr-.js";const u={},r={href:"https://www.rabbitmq.com/",target:"_blank",rel:"noopener noreferrer"},d={href:"https://hub.docker.com/_/rabbitmq",target:"_blank",rel:"noopener noreferrer"},g={href:"http://192.168.0.200:15672/",target:"_blank",rel:"noopener noreferrer"},k={href:"http://192.168.0.200:15672/",target:"_blank",rel:"noopener noreferrer"},v={href:"https://www.rabbitmq.com/blog/2015/04/16/scheduling-messages-with-rabbitmq",target:"_blank",rel:"noopener noreferrer"},b={href:"https://github.com/rabbitmq/rabbitmq-delayed-message-exchange",target:"_blank",rel:"noopener noreferrer"};function m(h,n){const t=o("ExternalLinkIcon");return c(),p("div",null,[n[16]||(n[16]=l('<p><strong>消息队列</strong>（Message Queue，简称 MQ）是一种在分布式系统中广泛使用的中间件技术，它的核心作用是<strong>解耦、异步处理和削峰填谷</strong>。以下是需要消息队列的主要原因：</p><table><thead><tr><th style="text-align:left;"><strong>作用</strong></th><th style="text-align:left;"><strong>说明</strong></th><th style="text-align:left;"><strong>典型应用场景</strong></th></tr></thead><tbody><tr><td style="text-align:left;"><strong>系统解耦</strong></td><td style="text-align:left;">生产者与消费者无需直接通信，降低服务间依赖</td><td style="text-align:left;">订单服务 → 库存、物流、通知等多个下游服务</td></tr><tr><td style="text-align:left;"><strong>异步处理</strong></td><td style="text-align:left;">将耗时操作转为后台任务，提升响应速度和吞吐量</td><td style="text-align:left;">用户注册后异步发送邮件、初始化数据</td></tr><tr><td style="text-align:left;"><strong>流量削峰（缓冲）</strong></td><td style="text-align:left;">高并发请求暂存于队列，后端按能力消费，防止系统崩溃</td><td style="text-align:left;">秒杀、抢购、大促等突发流量场景</td></tr><tr><td style="text-align:left;"><strong>最终一致性</strong></td><td style="text-align:left;">通过可靠消息实现分布式事务的最终一致性，避免强一致性带来的复杂性</td><td style="text-align:left;">跨账户转账、订单支付后更新库存</td></tr><tr><td style="text-align:left;"><strong>事件驱动 &amp; 日志收集</strong></td><td style="text-align:left;">支持基于事件的架构，便于扩展；集中收集日志或行为数据用于分析</td><td style="text-align:left;">用户行为追踪、系统监控、大数据分析</td></tr></tbody></table><blockquote><p>💡 <strong>适用条件</strong>：当系统存在<strong>高耦合、同步阻塞、流量突刺或需异步/事件驱动</strong>等问题时，引入消息队列可显著提升稳定性与可维护性。</p></blockquote><p>几种MQ的对比：</p><table><thead><tr><th style="text-align:left;">特性 / 产品</th><th style="text-align:left;"><strong>RabbitMQ</strong></th><th style="text-align:left;"><strong>Apache Kafka</strong></th><th style="text-align:left;"><strong>Apache RocketMQ</strong></th><th style="text-align:left;"><strong>Apache Pulsar</strong></th></tr></thead><tbody><tr><td style="text-align:left;"><strong>开发语言</strong></td><td style="text-align:left;">Erlang</td><td style="text-align:left;">Scala / Java</td><td style="text-align:left;">Java</td><td style="text-align:left;">Java (Broker), C++ (BookKeeper)</td></tr><tr><td style="text-align:left;"><strong>消息模型</strong></td><td style="text-align:left;">AMQP（支持多种协议：STOMP、MQTT 等）</td><td style="text-align:left;">发布-订阅（基于日志的流式模型）</td><td style="text-align:left;">发布-订阅 + 点对点</td><td style="text-align:left;">统一支持 Queue 和 Stream（分层架构）</td></tr><tr><td style="text-align:left;"><strong>吞吐量</strong></td><td style="text-align:left;">中等（万级 QPS）</td><td style="text-align:left;">极高（百万级 QPS）</td><td style="text-align:left;">高（十万~百万级 QPS）</td><td style="text-align:left;">高（接近 Kafka，支持多租户）</td></tr><tr><td style="text-align:left;"><strong>延迟</strong></td><td style="text-align:left;">低（毫秒级）</td><td style="text-align:left;">中（通常几毫秒到几十毫秒）</td><td style="text-align:left;">低（毫秒级）</td><td style="text-align:left;">低（毫秒级）</td></tr><tr><td style="text-align:left;"><strong>持久化</strong></td><td style="text-align:left;">支持（可配置）</td><td style="text-align:left;">强持久化（写磁盘 + 分段日志）</td><td style="text-align:left;">强持久化（CommitLog + ConsumeQueue）</td><td style="text-align:left;">强持久化（基于 BookKeeper，分层存储）</td></tr><tr><td style="text-align:left;"><strong>可靠性</strong></td><td style="text-align:left;">高（支持 ACK、持久队列、镜像队列）</td><td style="text-align:left;">高（副本机制，但早期版本有数据丢失风险）</td><td style="text-align:left;">高（同步/异步刷盘，主从架构）</td><td style="text-align:left;">极高（计算与存储分离，自动故障恢复）</td></tr><tr><td style="text-align:left;"><strong>事务支持</strong></td><td style="text-align:left;">不支持原生事务（可通过插件或应用层实现）</td><td style="text-align:left;">仅支持幂等和 Exactly-Once（0.11+）</td><td style="text-align:left;">✅ 支持分布式事务消息</td><td style="text-align:left;">支持（通过 Pulsar Functions 或外部协调）</td></tr><tr><td style="text-align:left;"><strong>顺序消息</strong></td><td style="text-align:left;">不天然支持（需单队列单消费者模拟）</td><td style="text-align:left;">✅ 分区内严格有序</td><td style="text-align:left;">✅ 全局/分区顺序消息</td><td style="text-align:left;">✅ 分区内有序</td></tr><tr><td style="text-align:left;"><strong>扩展性</strong></td><td style="text-align:left;">一般（集群扩展较复杂）</td><td style="text-align:left;">高（水平扩展方便）</td><td style="text-align:left;">高（支持 NameServer 动态发现）</td><td style="text-align:left;">极高（无状态 Broker，存储独立扩展）</td></tr><tr><td style="text-align:left;"><strong>运维复杂度</strong></td><td style="text-align:left;">中等</td><td style="text-align:left;">中等（依赖 ZooKeeper）</td><td style="text-align:left;">中等</td><td style="text-align:left;">较高（依赖 BookKeeper，组件较多）</td></tr><tr><td style="text-align:left;"><strong>社区 &amp; 生态</strong></td><td style="text-align:left;">成熟，文档丰富，插件多</td><td style="text-align:left;">非常活跃，大数据生态集成好（如 Flink）</td><td style="text-align:left;">阿里系强大，国内生态好</td><td style="text-align:left;">新兴，云原生友好，增长迅速</td></tr><tr><td style="text-align:left;"><strong>典型使用场景</strong></td><td style="text-align:left;">企业应用、任务队列、中小规模异步解耦</td><td style="text-align:left;">日志收集、流处理、大数据管道</td><td style="text-align:left;">电商交易、金融支付、高可靠事务场景</td><td style="text-align:left;">多租户、混合负载（队列+流）、云原生架构</td></tr></tbody></table><p>简要总结：</p><table><thead><tr><th style="text-align:left;"><strong>需求场景</strong></th><th style="text-align:left;"><strong>推荐 MQ</strong></th></tr></thead><tbody><tr><td style="text-align:left;">需要灵活协议、强路由、低延迟</td><td style="text-align:left;"><strong>RabbitMQ</strong></td></tr><tr><td style="text-align:left;">高吞吐、日志/事件流、大数据处理</td><td style="text-align:left;"><strong>Kafka</strong></td></tr><tr><td style="text-align:left;">金融级事务、顺序消息、国产可控</td><td style="text-align:left;"><strong>RocketMQ</strong></td></tr><tr><td style="text-align:left;">云原生、多租户、统一队列与流处理</td><td style="text-align:left;"><strong>Pulsar</strong></td></tr></tbody></table><h2 id="rabbitmq" tabindex="-1"><a class="header-anchor" href="#rabbitmq"><span>RabbitMQ</span></a></h2><h3 id="安装与部署" tabindex="-1"><a class="header-anchor" href="#安装与部署"><span>安装与部署</span></a></h3>',9)),a("p",null,[n[1]||(n[1]=s("官网：",-1)),a("a",r,[n[0]||(n[0]=s("RabbitMQ: One broker to queue them all | RabbitMQ",-1)),e(t)])]),a("p",null,[n[3]||(n[3]=s("我们也可以直接用docker运行容器来完成部署：",-1)),a("a",d,[n[2]||(n[2]=s("rabbitmq - Official Image | Docker Hub",-1)),e(t)])]),n[17]||(n[17]=l(`<div class="language-Shell line-numbers-mode" data-highlighter="prismjs" data-ext="Shell" data-title="Shell"><pre><code><span class="line">docker run \\</span>
<span class="line"> -e RABBITMQ_DEFAULT_USER=itheima \\</span>
<span class="line"> -e RABBITMQ_DEFAULT_PASS=123321 \\</span>
<span class="line"> -v mq-plugins:/plugins \\				# 这里是挂载到数据卷上</span>
<span class="line"> --name mq \\</span>
<span class="line"> --hostname mq \\</span>
<span class="line"> -p 15672:15672 \\</span>
<span class="line"> -p 5672:5672 \\</span>
<span class="line"> --network hm-net\\</span>
<span class="line"> -d \\</span>
<span class="line"> rabbitmq:3.8-management</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>无法直连docker导致pull不下来，考虑使用网上提供的tar包，然后</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line"><span class="token function">docker</span> load <span class="token parameter variable">-i</span> <span class="token punctuation">[</span>tar包名称<span class="token punctuation">]</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></blockquote><p>可以看到在安装命令中有两个映射的端口：</p><ul><li>15672：RabbitMQ提供的管理控制台的端口</li><li>5672：RabbitMQ的消息发送处理接口</li></ul>`,4)),a("p",null,[n[5]||(n[5]=s("然后访问15672端口即可访问控制台界面：",-1)),a("a",g,[n[4]||(n[4]=s("RabbitMQ Management",-1)),e(t)]),n[6]||(n[6]=s("，输入设置的账号密码即可进入页面。",-1))]),n[18]||(n[18]=l(`<h3 id="整体架构" tabindex="-1"><a class="header-anchor" href="#整体架构"><span>整体架构</span></a></h3><div class="language-mermaid line-numbers-mode" data-highlighter="prismjs" data-ext="mermaid" data-title="mermaid"><pre><code><span class="line"><span class="token keyword">graph</span> TD</span>
<span class="line">    <span class="token keyword">subgraph</span> RabbitMQ_Server</span>
<span class="line">        <span class="token keyword">direction</span> LR</span>
<span class="line">        <span class="token keyword">subgraph</span> VirtualHost</span>
<span class="line">            <span class="token keyword">direction</span> TB</span>
<span class="line">            Exchange1<span class="token text string">((Exchange 1))</span></span>
<span class="line">            Queue1<span class="token text string">([Queue 1])</span></span>
<span class="line">            Queue2<span class="token text string">([Queue 2])</span></span>
<span class="line">            Exchange2<span class="token text string">((Exchange 2))</span></span>
<span class="line">            Queue3<span class="token text string">([Queue 3])</span></span>
<span class="line">            Exchange1 <span class="token arrow operator">--&gt;</span><span class="token label property">|Routing Key|</span> Queue1</span>
<span class="line">            Exchange1 <span class="token arrow operator">--&gt;</span><span class="token label property">|Routing Key|</span> Queue2</span>
<span class="line">            Exchange2 <span class="token arrow operator">--&gt;</span><span class="token label property">|Routing Key|</span> Queue2</span>
<span class="line">            Exchange2 <span class="token arrow operator">--&gt;</span><span class="token label property">|Routing Key|</span> Queue3</span>
<span class="line">        <span class="token keyword">end</span></span>
<span class="line">    <span class="token keyword">end</span></span>
<span class="line">    Publisher <span class="token arrow operator">--&gt;</span><span class="token label property">|Publish Message|</span> Exchange1</span>
<span class="line">    Publisher <span class="token arrow operator">--&gt;</span><span class="token label property">|Publish Message|</span> Exchange2</span>
<span class="line">    Queue1 <span class="token arrow operator">--&gt;</span><span class="token label property">|Consume Message|</span> Consumer1</span>
<span class="line">    Queue2 <span class="token arrow operator">--&gt;</span><span class="token label property">|Consume Message|</span> Consumer2</span>
<span class="line">    Queue3 <span class="token arrow operator">--&gt;</span><span class="token label property">|Consume Message|</span> Consumer3</span>
<span class="line"></span>
<span class="line">    <span class="token keyword">classDef</span> exchange <span class="token style"><span class="token property">fill</span><span class="token operator">:</span>#f96<span class="token punctuation">,</span><span class="token property">stroke</span><span class="token operator">:</span>#333<span class="token punctuation">,</span><span class="token property">stroke-width</span><span class="token operator">:</span>2px</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">classDef</span> queue <span class="token style"><span class="token property">fill</span><span class="token operator">:</span>#bbf<span class="token punctuation">,</span><span class="token property">stroke</span><span class="token operator">:</span>#333<span class="token punctuation">,</span><span class="token property">stroke-width</span><span class="token operator">:</span>2px</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">classDef</span> publisher <span class="token style"><span class="token property">fill</span><span class="token operator">:</span>#9f6<span class="token punctuation">,</span><span class="token property">stroke</span><span class="token operator">:</span>#333<span class="token punctuation">,</span><span class="token property">stroke-width</span><span class="token operator">:</span>2px</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">classDef</span> consumer <span class="token style"><span class="token property">fill</span><span class="token operator">:</span>#6bf<span class="token punctuation">,</span><span class="token property">stroke</span><span class="token operator">:</span>#333<span class="token punctuation">,</span><span class="token property">stroke-width</span><span class="token operator">:</span>2px</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">class</span> Exchange1,Exchange2 exchange<span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">class</span> Queue1,Queue2,Queue3 queue<span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">class</span> Publisher publisher<span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">class</span> Consumer1,Consumer2,Consumer3 consumer<span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>生产者——&gt;交换机——&gt;队列——&gt;消费者，<strong>生产者不会直接将消息发送到队列而是由交换机转接</strong>，可以简单将交换机理解为<strong>发送策略</strong>，指定发送消息的队列范围（和这个交换机绑定的队列）以及口令（根据RoutingKey通过绑定BingingKey选择队列）</p></blockquote><table><thead><tr><th>组件</th><th>说明</th></tr></thead><tbody><tr><td>1. <strong>Producer</strong>（生产者）</td><td>消息的发送方，通过Client将消息发布到 RabbitMQ 的 Exchange（交换机），不直接发送到队列。</td></tr><tr><td>2. <strong>Consumer</strong>（消费者）</td><td>消息的接收方，通过Client从 Queue（队列）中拉取或订阅消息进行处理。支持多个消费者并发消费（轮询或公平分发）。</td></tr><tr><td>3. Broker</td><td>RabbitMQ 服务实例本身，负责接收、路由、存储和投递消息。一个 Broker 可包含多个 Virtual Host。</td></tr><tr><td>4. Virtual Host（vhost）</td><td>虚拟主机，用于逻辑隔离不同应用或租户。每个 vhost 拥有独立的 Exchange、Queue、Binding 和权限体系，类似“命名空间”（<strong>一个MQ一般一个项目用不完，可复用于多个项目/团队，这时候就用这个“namespace”作为最高隔离等级区分一下空间</strong>）</td></tr><tr><td>5. <strong>Exchange</strong>（交换机）</td><td>消息的路由中心。接收生产者的消息，并根据类型 + 路由规则将消息分发到一个或多个队列。常见类型： - <code>Direct</code>：<strong>精确匹配 Routing Key</strong> - <code>Fanout</code>：<strong>广播到所有绑定队列</strong> - <code>Topic</code>：<strong>通配符匹配</strong>（如 <code>*.error</code>） - <code>Headers</code>：<strong>基于消息头属性匹配</strong>（较少用）</td></tr><tr><td>6. <strong>Queue</strong>（队列）</td><td>消息的存储容器。消息在被消费前持久化在此（可配置内存或磁盘）。每个队列可绑定多个 Exchange。</td></tr><tr><td>7. <strong>Binding</strong>（绑定）</td><td>定义 Exchange 与 Queue 之间的关联规则，通常包含 Routing Key 或匹配模式。</td></tr><tr><td>8. Connection &amp; Channel</td><td>- Connection：客户端（Producer/Consumer）与 Broker 之间的 TCP 长连接。 - Channel：轻量级虚拟连接，复用同一个 TCP 连接，用于并发操作（如同时声明多个队列）。</td></tr><tr><td>9. Message（消息）</td><td>由 Payload（数据体） + Properties（元数据，如 routing key、priority、TTL 等） 组成。</td></tr></tbody></table><hr><p><strong>简要流程：</strong></p><ol><li><strong>生产者</strong> 建立 <strong>Connection</strong>，创建 <strong>Channel</strong>；</li><li>通过 Channel 将 <strong>Message</strong> 发送到指定的 <strong>Exchange</strong>，并附带 <strong>Routing Key</strong>；</li><li><strong>Exchange</strong> 根据类型和 <strong>Binding 规则</strong>，将消息路由到一个或多个 <strong>Queue</strong>；</li><li><strong>消费者</strong> 建立 Connection/Channel，监听目标 Queue；</li><li>消费者从 Queue 中获取消息，处理完成后发送 <strong>ACK</strong>；</li><li>Broker 收到 ACK 后，从 Queue 中删除该消息（若未 ACK，可能重新入队或进入死信队列）。</li></ol><blockquote><p>✅ <strong>关键特性支持</strong>：</p><ul><li><strong>持久化</strong>：Exchange、Queue、Message 可设为持久化，防止 Broker 重启丢失。</li><li><strong>ACK 机制</strong>：确保消息被成功处理。</li><li><strong>死信队列（DLX）</strong>：处理失败/过期消息。</li><li><strong>优先级队列</strong>：VIP 用户消息优先处理。</li><li><strong>集群与高可用</strong>：支持普通集群、镜像队列、Quorum 队列。</li></ul></blockquote><hr><p><strong>部署类型：</strong></p><table><thead><tr><th style="text-align:left;">模式</th><th style="text-align:left;">说明</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>单机模式</strong></td><td style="text-align:left;">开发/测试使用，无高可用。</td></tr><tr><td style="text-align:left;"><strong>普通集群</strong></td><td style="text-align:left;">多节点共享元数据（Exchange/Binding），但 Queue 数据只存在于一个节点。</td></tr><tr><td style="text-align:left;"><strong>镜像队列集群</strong></td><td style="text-align:left;">Queue 数据在多个节点同步（主从复制），实现高可用（牺牲吞吐）。</td></tr><tr><td style="text-align:left;"><strong>Quorum 队列（推荐新项目）</strong></td><td style="text-align:left;">基于 Raft 协议，强一致性、自动故障转移，替代镜像队列。</td></tr></tbody></table><h3 id="简要理解" tabindex="-1"><a class="header-anchor" href="#简要理解"><span>简要理解</span></a></h3><p><strong>生产者（Producer）视角：</strong></p><blockquote><p>“我只管把消息发给「交换机」，不用知道谁会收到。”</p></blockquote><ol><li>创建一条消息</li><li>发给指定的 <strong>Exchange（交换机）</strong>，并附上一个 <strong>Routing Key</strong>（路由关键字）</li><li>完事！不关心消息去哪、有没有人收</li></ol><hr><p><strong>消费者（Consumer）视角：</strong></p><blockquote><p>“我只管从「队列」里拿消息，不用知道是谁发的。”</p></blockquote><ol><li>告诉 RabbitMQ：“我要监听某个 <strong>Queue（队列）</strong>”</li><li>一旦队列有消息，就取出来处理</li><li>处理完告诉 RabbitMQ：“收到了！”（ACK）</li><li>完事！不关心消息从哪来、谁发的</li></ol><hr><p><strong>🔗 中间发生了什么？（RabbitMQ 负责）</strong></p><ul><li>Exchange 根据 <strong>Routing Key + 绑定规则（Binding）</strong>，把消息自动投递到对应的 Queue</li><li>一个消息可以被多个队列收到（比如广播），也可以只进一个队列（比如点对点）</li></ul><hr><p><strong>✅ 一句话总结：</strong></p><blockquote><p><strong>生产者 → 发给交换机</strong>，<strong>消费者 ← 从队列取</strong>，中间路由由 RabbitMQ 自动搞定，双方完全解耦！</p></blockquote><h2 id="配置相关" tabindex="-1"><a class="header-anchor" href="#配置相关"><span>配置相关</span></a></h2><h3 id="配置队列以及交换机" tabindex="-1"><a class="header-anchor" href="#配置队列以及交换机"><span>配置队列以及交换机</span></a></h3>`,27)),a("p",null,[n[8]||(n[8]=s("在RabbitMQ提供的可视化web页面：",-1)),a("a",k,[n[7]||(n[7]=s("RabbitMQ Management",-1)),e(t)]),n[9]||(n[9]=s("，我们可以来到",-1)),n[10]||(n[10]=a("code",null,"Queues",-1)),n[11]||(n[11]=s("标签页，在下方的队列管理分页界面我们只需要点点点就可以完成队列的相关配置了。",-1))]),n[19]||(n[19]=l(`<p>然后我们来到<code>Exchanges</code>标签页，在这里的管理界面我们同样也可以通过点点点实现对交换机的管理，我们先前提到<strong>消息</strong>进入broker后去到生产者指定的<code>vhost</code>然后就是<code>Exchanges</code>了，但是接下来我们的消息要怎么去到<strong>消费者</strong>能够<strong>订阅获取</strong>的**<code>Queues</code>**呢？</p><p>RabbitMQ的方案是提供了**<code>Exchanges</code>与<code>Queues</code>之间的绑定关系：<code>Bindings</code>**，通过这个绑定，我们将<code>Exchanges</code>与<code>Queues</code>联系起来，以后<code>Exchanges</code>只要收到消息就根据生产者附带的<code>Routing Key</code>将消息交给指定的<code>Queues</code>了。</p><p>而想要**实现一个<code>Bindings</code>**也很简单，只需要在<code>Exchange</code>标签页点开需要设置的那个<code>Exchange</code>，然后再点开下方的<code>Bindings</code>，配置好<code>Binding</code>指定的<code>Queue</code>和<code>Routing Key</code>以及相关参数即可完成配置。</p><h3 id="配置数据隔离" tabindex="-1"><a class="header-anchor" href="#配置数据隔离"><span>配置数据隔离</span></a></h3><p>之前我们提到一般一个MQ会用于多个项目，这时候就需要我们去配置一个虚拟主机vhost来区分不同项目的空间环境，想要配置不同的vhost，我们只需要来到可视化web界面，点击最右侧的<code>Admin</code>标签页，然后就可以在这个页面完成配置了。</p><p>在RabbitMQ中，为了实现权限管理以及功能区分，专门配备了一个身份<code>User</code>，每个User都被指定了：</p><ul><li>能否访问某个 <strong>Virtual Host</strong></li><li>能否 <strong>读（消费）</strong> 队列</li><li>能否 <strong>写（发布）</strong> 到交换机</li><li>能否 <strong>配置（声明/删除）</strong> Exchange 或 Queue</li></ul><blockquote><p><strong>User 是访问 RabbitMQ 的“通行证”，用来控制“谁可以做什么”</strong>，可以理解为OSS的令牌。</p></blockquote><p>每个用户在每个 vhost 上都有三个权限位：</p><table><thead><tr><th style="text-align:left;">权限类型</th><th style="text-align:left;">作用</th><th style="text-align:left;">示例</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>Configure</strong></td><td style="text-align:left;">是否能声明/删除 Exchange、Queue、Binding</td><td style="text-align:left;">声明 <code>order.queue</code></td></tr><tr><td style="text-align:left;"><strong>Write</strong></td><td style="text-align:left;">是否能向 Exchange <strong>发送</strong>消息</td><td style="text-align:left;">发布消息到 <code>order.exchange</code></td></tr><tr><td style="text-align:left;"><strong>Read</strong></td><td style="text-align:left;">是否能从 Queue <strong>消费</strong>消息</td><td style="text-align:left;">从 <code>order.queue</code> 拉取消息</td></tr></tbody></table><blockquote><p>💡 默认情况下，RabbitMQ 只有一个用户：<code>guest</code> / <code>guest</code>，<strong>但该用户只能从 localhost 登录</strong>，生产环境必须创建新用户！</p></blockquote><p>那么现在我们想要去为一个项目配置一个<code>Virtual Host</code>，使得他的<code>User</code>能够访问这个空间里面的交换机<code>Exchange</code>，我们只需要来到MQ的可视化web界面：</p><ol><li>在<code>User</code>标签页为这个<strong>项目</strong>创建一个<code>Virtual Host</code>（这时已生成了默认的<code>Exchange</code>交换机）</li><li>为计划的几个业务配置对应的<code>User</code>，将自己的<code>Virtual Host</code>的相应访问access赋予这些用户</li><li>在<code>Queues</code>标签页配置对应的业务<code>Queue</code>，配置好其的<code>Virtual Host</code>（<code>Bindings</code>会自动绑定到默认的default交换机）</li><li>在<code>Exchange</code>标签页完成相应交换机的创建，<code>Bindings</code>配置与指定<code>Queue</code>的绑定关系</li></ol><p>然后生产者就可以发送消息到交换机；消费者就可以订阅对应的队列</p><blockquote><p>嫌其他项目的<code>Virtual Host</code>相关内容太多可以在右上角选择仅展示某一<code>Virtual Host</code>的内容</p></blockquote><h2 id="java-client" tabindex="-1"><a class="header-anchor" href="#java-client"><span>Java Client</span></a></h2><h3 id="引入依赖" tabindex="-1"><a class="header-anchor" href="#引入依赖"><span>引入依赖</span></a></h3><div class="language-xml line-numbers-mode" data-highlighter="prismjs" data-ext="xml" data-title="xml"><pre><code><span class="line">        <span class="token comment">&lt;!--AMQP依赖，包含RabbitMQ--&gt;</span></span>
<span class="line">        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span></span>
<span class="line">            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span></span>
<span class="line">            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-amqp<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span></span>
<span class="line">        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="配置yml" tabindex="-1"><a class="header-anchor" href="#配置yml"><span>配置YML</span></a></h3><p>在application中设置好client的用户信息：</p><div class="language-yaml line-numbers-mode" data-highlighter="prismjs" data-ext="yml" data-title="yml"><pre><code><span class="line"><span class="token key atrule">spring</span><span class="token punctuation">:</span></span>
<span class="line">  <span class="token key atrule">rabbitmq</span><span class="token punctuation">:</span></span>
<span class="line">    <span class="token key atrule">host</span><span class="token punctuation">:</span> 192.168.0.200 <span class="token comment"># 你的虚拟机IP</span></span>
<span class="line">    <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">5672</span> <span class="token comment"># 端口</span></span>
<span class="line">    <span class="token key atrule">virtual-host</span><span class="token punctuation">:</span> /hmall <span class="token comment"># 虚拟主机</span></span>
<span class="line">    <span class="token key atrule">username</span><span class="token punctuation">:</span> hmall <span class="token comment"># 用户名</span></span>
<span class="line">    <span class="token key atrule">password</span><span class="token punctuation">:</span> <span class="token number">123</span> <span class="token comment"># 密码</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>一般情况下一个项目只会使用一个虚拟主机，我们为不同的微服务配置指定的用户即可</p></blockquote><h3 id="生产者发送消息" tabindex="-1"><a class="header-anchor" href="#生产者发送消息"><span>生产者发送消息</span></a></h3><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token annotation punctuation">@SpringBootTest</span></span>
<span class="line"><span class="token keyword">class</span> <span class="token class-name">PublisherApplicationTest</span> <span class="token punctuation">{</span></span>
<span class="line"></span>
<span class="line">    <span class="token annotation punctuation">@Autowired</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token class-name">RabbitTemplate</span> rabbitTemplate<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token annotation punctuation">@Test</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testMain</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token class-name">String</span> queueName <span class="token operator">=</span> <span class="token string">&quot;simple.queue&quot;</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token class-name">String</span> message <span class="token operator">=</span> <span class="token string">&quot;Hello World!&quot;</span><span class="token punctuation">;</span></span>
<span class="line">        rabbitTemplate<span class="token punctuation">.</span><span class="token function">convertAndSend</span><span class="token punctuation">(</span>queueName<span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p><strong>生产者不应该发到交换机吗？为什么指定队列名就可以直接发送消息了？</strong></p><p>当你<strong>直接指定队列名</strong>发送消息时，<code>RabbitTemplate</code> 会自动使用 RabbitMQ 内置的「<strong>默认交换机（Default Exchange）</strong>」，并将 routing key 设为队列名。这是合法且常用的做法。</p><p><strong>默认交换机（Default Exchange）<strong>会在创建完成一个虚拟主机时也一同生成，其属于该虚拟主机，<strong>RabbitMQ 的默认交换机（Default Exchange）会自动绑定到每一个队列（Queue）</strong>，而且这个过程是</strong>隐式的、不可见的、无法删除或修改的</strong>。</p><p>底层实际等价于：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line">rabbitTemplate<span class="token punctuation">.</span><span class="token function">convertAndSend</span><span class="token punctuation">(</span><span class="token string">&quot;&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;simple.queue&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Hello!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token comment">//            				   ↑交换机   ↑routing key</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>交换机：<code>&quot;&quot;</code>（默认 direct 交换机）</li><li>Routing Key：<code>&quot;simple.queue&quot;</code></li><li>消息被路由到名为 <code>simple.queue</code> 的队列</li></ul><p>✅ 这完全符合 direct 交换机的匹配规则（精确匹配 routing key）。</p><p>这种方式能成功，<strong>必须满足</strong>：</p><ol><li><p>队列 <code>simple.queue</code>已经存在（RabbitMQ 不会自动创建队列！）</p><ul><li>如果队列不存在，消息会被<strong>静默丢弃</strong>（因为默认交换机无法路由）</li></ul></li><li><p>你确实想实现 <strong>“直接发到某个队列”</strong> 的简单模式（无 <strong>fanout广播</strong>/<strong>topic通配符匹配</strong> 等复杂路由）</p></li></ol></blockquote><h3 id="消费者订阅队列" tabindex="-1"><a class="header-anchor" href="#消费者订阅队列"><span>消费者订阅队列</span></a></h3><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token annotation punctuation">@Component</span></span>
<span class="line"><span class="token annotation punctuation">@Slf4j</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MQListener</span> <span class="token punctuation">{</span></span>
<span class="line">    </span>
<span class="line">    <span class="token annotation punctuation">@RabbitListener</span><span class="token punctuation">(</span>queues <span class="token operator">=</span> <span class="token string">&quot;simple.queue&quot;</span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">listen</span><span class="token punctuation">(</span><span class="token class-name">String</span> message<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;接收到消息：{}&quot;</span><span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在完成依赖导入后，我们只需要保证连接配置正确，就可以让这个Bean实例能够监听到指定消息队列的消息，实际上一个方法可以监听多条消息队列（传入<code>List&lt;String&gt;</code>即可）。</p><h3 id="消费者负载均衡" tabindex="-1"><a class="header-anchor" href="#消费者负载均衡"><span>消费者负载均衡</span></a></h3><p>在实际生产中我们会为一个队列配备多个消费者来完成多个生产者发布的任务，而就像Nacos选择微服务实例会通过LoadBalancer进行<strong>负载均衡</strong>一样，监听<strong>同一队列</strong>的消费者也会进行负载均衡，默认情况下是<strong>轮询</strong>，也即每个消费者<strong>轮流</strong>取出一个消息并<strong>完成业务以后</strong>下一个消费者取消息操作。但是实际环境中，并非所有消费者服务的性能是一样的，这就会导致有些性能好的消费者必须等待其他消费服务实例完成任务后才轮得到自己，使得他们的性能被<strong>浪费</strong>了。</p><p>针对这一种情况，RabbitMQ其实也提供了一种负载均衡模式：<strong>能者多劳</strong>：每个消费者服务每次只获取一条消息，处理完成就会获取下一条消息。想要配置这样一种模式，我们只需要到配置文件application中去修改模式：</p><div class="language-YAML line-numbers-mode" data-highlighter="prismjs" data-ext="YAML" data-title="YAML"><pre><code><span class="line">spring:</span>
<span class="line">  rabbitmq:</span>
<span class="line">    listener:</span>
<span class="line">      simple:</span>
<span class="line">        prefetch: 1 # 每次只能获取一条消息，处理完成才能获取下一个消息</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样就可以让性能更佳的消费者实例去尽可能的完成任务了。</p><p>实际上，RabbitMQ <strong>总是按顺序从队列头部取出消息，并依次尝试分发给消费者</strong> —— 这个过程<strong>本身是轮询式的</strong>。</p><p>但关键在于：<strong>是否允许把消息发给某个消费者？</strong></p><ul><li><strong>如果没有 prefetch 限制</strong>： RabbitMQ 会一口气把所有消息按轮询顺序推给消费者（比如 C1、C2、C1、C2...），但因为网络/缓冲区原因，往往第一个消费者拿走大部分。</li><li><strong>如果设置了 <code>prefetch = 1</code></strong>： RabbitMQ 仍然按轮询顺序尝试派发，但<strong>只有当消费者未确认消息数 &lt; 1 时，才真正发送</strong>。 → 如果 C1 还没 ACK，即使轮到它，也不发；转而发给 C2（如果 C2 空闲）。</li></ul><p>✅ 所以：<strong>底层仍是轮询尝试，但实际派发受 prefetch + ACK 状态控制</strong>。</p><blockquote><p><strong>RabbitMQ一个队列的多个消费者默认采用「轮询分发」（Round-Robin） + 「自动 ACK」或「手动 ACK」下的「公平分发」（Fair Dispatch）</strong></p><p><strong>情况 1：自动 ACK 模式（autoAck = true）</strong></p><ul><li>RabbitMQ 采用简单的轮询（Round-Robin）： <ul><li>消息 1 → Consumer A</li><li>消息 2 → Consumer B</li><li>消息 3 → Consumer A</li><li>...</li></ul></li><li>❌ <strong>问题</strong>：如果 Consumer A 处理慢，Consumer B 处理快，会导致 A 堆积、B 空闲 —— <strong>不公平！</strong></li></ul><p><strong>情况 2：手动 ACK 模式（autoAck = false） + 设置 prefetch（推荐！）</strong></p><ul><li>RabbitMQ 采用基于 prefetch 的公平分发（Fair Dispatch）： <ul><li>只有当消费者<strong>未确认的消息数 &lt; prefetch count</strong> 时，才给它发新消息</li><li>处理快的消费者会拿到更多消息，处理慢的则少拿</li><li>✅ 实现<strong>动态负载均衡</strong></li></ul></li></ul><p>📌 <strong>结论</strong>： <strong>真正的“负载均衡”依赖于 <code>manual ACK + prefetch</code>，而不是简单的轮询！</strong></p></blockquote><h2 id="三种发送类型" tabindex="-1"><a class="header-anchor" href="#三种发送类型"><span>三种发送类型</span></a></h2><h3 id="fanout交换机广播" tabindex="-1"><a class="header-anchor" href="#fanout交换机广播"><span>Fanout交换机广播</span></a></h3><p>先前我们完成了生产者对单队列的消息传递，但是如果我们希望将消息<strong>同时</strong>传递给多个队列怎么办？我们可以直接传一个<code>List&lt;String&gt;</code>参数进去直接让默认交换机进行广播吗？答案是<strong>不行</strong>！</p><blockquote><p><strong>默认交换机是 <code>direct</code> 类型，且每个队列只能通过「自己的名字」作为 routing key 被单独访问 —— 它根本不支持广播语义。</strong></p></blockquote><p>那么我们就需要去自制交换机，并将需要传递消息的队列与之绑定，然后再在client将信息发送给他以完成广播：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token annotation punctuation">@Test</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testMain</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token class-name">String</span> exchangename <span class="token operator">=</span> <span class="token string">&quot;hmall.fanout&quot;</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token class-name">String</span> message <span class="token operator">=</span> <span class="token string">&quot;H5165&quot;</span><span class="token punctuation">;</span></span>
<span class="line">    rabbitTemplate<span class="token punctuation">.</span><span class="token function">convertAndSend</span><span class="token punctuation">(</span>exchangename<span class="token punctuation">,</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p><strong>在 Fanout Exchange 中，<code>routing key</code> 完全被忽略 —— 无论你发什么 routing key（包括空字符串），消息都会广播给所有绑定的队列。</strong></p></blockquote><p><code>hmall.fanout</code>交换机绑定了<code>fanout.queue1</code>以及<code>fanout.queue2</code>，生产者将消息发送给<code>hmall.fanout</code>交换机即可将消息传递给两个队列。</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token annotation punctuation">@RabbitListener</span><span class="token punctuation">(</span>queues <span class="token operator">=</span> <span class="token string">&quot;fanout.queue1&quot;</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">listen2</span><span class="token punctuation">(</span><span class="token class-name">String</span> message<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;1接收到消息：{}&quot;</span><span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token annotation punctuation">@RabbitListener</span><span class="token punctuation">(</span>queues <span class="token operator">=</span> <span class="token string">&quot;fanout.queue2&quot;</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">listen3</span><span class="token punctuation">(</span><span class="token class-name">String</span> message<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;2接收到消息：{}&quot;</span><span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>消费者只需要正常监听即可。</p><h3 id="direct定向发送" tabindex="-1"><a class="header-anchor" href="#direct定向发送"><span>Direct定向发送</span></a></h3><p>我们说对于绑定的队列我们<strong>不希望进行无脑广播</strong>，我们要挑着来，有的队列我们要发，有的队列我们不发，那该怎么搞？RabbitMQ提供的方案是给<code>Bindings</code>加上属性<code>Routing Key</code>，倘若这个<code>Routing Key</code>符合要求那就发。</p><blockquote><p>注意一个交换机和一个队列之间可以<strong>多次绑定</strong>，<strong>绑定多种</strong><code>Routing Key</code>，总之就是很灵活</p></blockquote><p>如果我们对于<code>Routing Key</code>的要求是<strong>完全一致</strong>，那么我们就可以使用RabbitMQ提供的<strong>Direct</strong>类型交换机，他就会对自己绑定的所有队列通过<strong>内部索引快速查找</strong>符合要求的<code>Binding</code>并给其所对应的队列发送消息：</p><p>准备一个交换机hmall.direct，将之与队列direct.queue1和direct.queue2绑定，规则：</p><table><thead><tr><th style="text-align:left;">To</th><th style="text-align:left;">Routing key</th></tr></thead><tbody><tr><td style="text-align:left;">[direct.queue1]</td><td style="text-align:left;">123</td></tr><tr><td style="text-align:left;">[direct.queue1]</td><td style="text-align:left;">5</td></tr><tr><td style="text-align:left;">[direct.queue2]</td><td style="text-align:left;">321</td></tr><tr><td style="text-align:left;">[direct.queue2]</td><td style="text-align:left;">5</td></tr></tbody></table><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token annotation punctuation">@Test</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testMain</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token class-name">String</span> exchangename <span class="token operator">=</span> <span class="token string">&quot;hmall.direct&quot;</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token class-name">String</span> message <span class="token operator">=</span> <span class="token string">&quot;H5165&quot;</span><span class="token punctuation">;</span></span>
<span class="line">    rabbitTemplate<span class="token punctuation">.</span><span class="token function">convertAndSend</span><span class="token punctuation">(</span>exchangename<span class="token punctuation">,</span> <span class="token string">&quot;123&quot;</span><span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>rabbitTemplate.convertAndSend的参数为</p><ul><li>交换机name</li><li>Routing Key</li><li>消息Obj</li></ul></blockquote><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token annotation punctuation">@RabbitListener</span><span class="token punctuation">(</span>queues <span class="token operator">=</span> <span class="token string">&quot;direct.queue1&quot;</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">listen4</span><span class="token punctuation">(</span><span class="token class-name">String</span> message<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;1接收到消息：{}&quot;</span><span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token annotation punctuation">@RabbitListener</span><span class="token punctuation">(</span>queues <span class="token operator">=</span> <span class="token string">&quot;direct.queue2&quot;</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">listen5</span><span class="token punctuation">(</span><span class="token class-name">String</span> message<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;2接收到消息：{}&quot;</span><span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当使用5作为Routing Key时发现两个绑定的队列都收到消息，使用123或321就会发现只有一个收到了消息。</p><h3 id="topic话题通配发送" tabindex="-1"><a class="header-anchor" href="#topic话题通配发送"><span>Topic话题通配发送</span></a></h3><p>我们说RoutingKey直接完全相等还是太粗暴了，是否可以通配符来匹配RoutingKey实现指定队列的绑定呢？可以的xd，RabbitMQ就提供了Topic类型的交换机来指定通配规则RoutingKey：</p><ul><li><code>#</code>：匹配一个或多个词</li><li><code>*</code>：匹配不多不少恰好1个词</li></ul><p>RoutingKey举例：</p><ul><li><code>item.#</code>：能够匹配<code>item.spu.insert</code> 或者 <code>item.spu</code></li><li><code>item.*</code>：只能匹配<code>item.spu</code></li></ul><p>完成交换机以及队列的创建以及绑定后，在Client的使用上和前两种方式没什么区别。</p><h3 id="简单总结" tabindex="-1"><a class="header-anchor" href="#简单总结"><span>简单总结</span></a></h3><p><strong>生产者：<strong>对于只希望</strong>简单的</strong>发送到<strong>一个队列</strong>的生产者，实际上我们可以通过虚拟主机生成时的<strong>默认交换机</strong>直接发送到指定的队列，client中也不需要指定Exchange，只需要输入routing key（即队列name）以及消息内容接口。</p><blockquote><p>**默认交换机是 <code>direct</code> 类型，且每个队列只能通过「自己的名字」作为 routing key 被单独访问 —— 它根本不支持广播语义。**原文解释：</p><p><strong>Default exchange</strong></p><p>The default exchange is implicitly bound to <strong>every</strong> queue, with a <strong>routing key equal to the queue name</strong>. It is not possible to explicitly bind to, or unbind from the default exchange. It also cannot be deleted.</p></blockquote><p>如果希望<strong>复杂</strong>发送，比如进行虚拟主机内全广播或者指定多条队列传递消息，那就需要去自定义交换机并绑定那几条队列，然后用client将消息传递给这个Exchange以完成消息发送，RabbitMQ提供的几种交换机类型：</p><table><thead><tr><th style="text-align:left;">交换机类型</th><th style="text-align:left;">英文名</th><th style="text-align:left;">路由规则</th><th style="text-align:left;">典型用途</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>直连交换机</strong></td><td style="text-align:left;"><code>Direct</code></td><td style="text-align:left;"><strong>精确匹配</strong> routing key</td><td style="text-align:left;">点对点任务、按类型分发（如订单创建/取消）</td></tr><tr><td style="text-align:left;"><strong>扇出交换机</strong></td><td style="text-align:left;"><code>Fanout</code></td><td style="text-align:left;"><strong>忽略 routing key，广播到所有绑定队列</strong></td><td style="text-align:left;">广播通知（短信、邮件、日志）</td></tr><tr><td style="text-align:left;"><strong>主题交换机</strong></td><td style="text-align:left;"><code>Topic</code></td><td style="text-align:left;"><strong>通配符模糊匹配</strong> routing key</td><td style="text-align:left;">多维度分类（如 <code>log.error.api</code>、<code>stock.usd.nyse</code>）</td></tr><tr><td style="text-align:left;"><strong>头交换机</strong></td><td style="text-align:left;"><code>Headers</code></td><td style="text-align:left;"><strong>基于消息 headers 属性匹配</strong>（非 routing key）</td><td style="text-align:left;">复杂条件路由（极少使用）</td></tr></tbody></table><blockquote><p>其实可以将交换机看作一种给队列传递消息的<strong>策略</strong></p></blockquote><p>对于Java的Client，我们只需要使用<code>rabbitTemplate.convertAndSend()</code>去发送给<strong>交换机</strong>并带上<strong>RoutingKey</strong>和<strong>消息Obj</strong>即可。</p><p>**消费者：**只管监听自己负责消费的队列即可：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token annotation punctuation">@RabbitListener</span><span class="token punctuation">(</span>queues <span class="token operator">=</span> <span class="token string">&quot;{队列name}&quot;</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">listen4</span><span class="token punctuation">(</span><span class="token punctuation">{</span>设置的对应消息<span class="token class-name">Obj</span>类型<span class="token punctuation">}</span> message<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// 对应业务</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="代码声明队列及交换机" tabindex="-1"><a class="header-anchor" href="#代码声明队列及交换机"><span>代码声明队列及交换机</span></a></h2><p>人工到可视化web界面中去进行操作还是太慢太low了，其实我们可以通过amqp提供的接口实现交换机以及队列的生成，还可以管理他们之间的连接以及配置规则RoutingKey，这样我们只需要在消费者服务启动时生成即可。</p><h3 id="基于bean声明" tabindex="-1"><a class="header-anchor" href="#基于bean声明"><span>基于Bean声明</span></a></h3><p>废话不多说，见代码：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token annotation punctuation">@Configuration</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FanoutConfig</span> <span class="token punctuation">{</span></span>
<span class="line"></span>
<span class="line">    <span class="token annotation punctuation">@Bean</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token class-name">FanoutExchange</span> <span class="token function">fanoutExchange</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">FanoutExchange</span><span class="token punctuation">(</span><span class="token string">&quot;fanout.exchange&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token annotation punctuation">@Bean</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token class-name">Queue</span> <span class="token function">fanoutQueue1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Queue</span><span class="token punctuation">(</span><span class="token string">&quot;fanout.queue1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token annotation punctuation">@Bean</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token class-name">Binding</span> <span class="token function">fanoutBinding1</span><span class="token punctuation">(</span><span class="token class-name">Queue</span> fanoutQueue1<span class="token punctuation">,</span> <span class="token class-name">FanoutExchange</span> fanoutExchange<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">return</span> <span class="token class-name">BindingBuilder</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>fanoutQueue1<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">to</span><span class="token punctuation">(</span>fanoutExchange<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p><code>@Bean</code>注解必须在<code>@Configuration</code>类中才会被扫描</p></blockquote><p>可以看到甚至连<strong>Binding</strong>也是作为<strong>Bean实例</strong>被声明出来的。</p><hr><p>如果是<strong>Direct</strong>类型：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token annotation punctuation">@Bean</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token class-name">DirectExchange</span> <span class="token function">directExchange</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">DirectExchange</span><span class="token punctuation">(</span><span class="token string">&quot;direct.exchange&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token annotation punctuation">@Bean</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token class-name">Queue</span> <span class="token function">directQueue1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Queue</span><span class="token punctuation">(</span><span class="token string">&quot;direct.queue1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token annotation punctuation">@Bean</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token class-name">Binding</span> <span class="token function">directBinding1</span><span class="token punctuation">(</span><span class="token class-name">Queue</span> directQueue1<span class="token punctuation">,</span> <span class="token class-name">DirectExchange</span> directExchange<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">return</span> <span class="token class-name">BindingBuilder</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>directQueue1<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">to</span><span class="token punctuation">(</span>directExchange<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">with</span><span class="token punctuation">(</span><span class="token string">&quot;123&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>绑定时使用<strong>with</strong>指定<strong>RoutingKey</strong>即可。</p><hr><p>生成绑定时使用了Binding<strong>Builder</strong>返回一个新的实例，其实在交换机以及队列上也可以如此：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token annotation punctuation">@Bean</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token class-name">FanoutExchange</span> <span class="token function">fanoutExchange</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">return</span> <span class="token class-name">ExchangeBuilder</span><span class="token punctuation">.</span><span class="token function">fanoutExchange</span><span class="token punctuation">(</span><span class="token string">&quot;fanout.exchange&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">durable</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token annotation punctuation">@Bean</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token class-name">Queue</span> <span class="token function">fanoutQueue1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">return</span> <span class="token class-name">QueueBuilder</span><span class="token punctuation">.</span><span class="token function">durable</span><span class="token punctuation">(</span><span class="token string">&quot;fanout.queue1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="基于注解声明" tabindex="-1"><a class="header-anchor" href="#基于注解声明"><span>基于注解声明</span></a></h3><p>上面的Bean声明队列交换机以及绑定还要额外搞一个Configuration，有点麻烦，其实我们也可以直接在监听类中直接一步到位：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token annotation punctuation">@RabbitListener</span><span class="token punctuation">(</span>bindings <span class="token operator">=</span> <span class="token annotation punctuation">@QueueBinding</span><span class="token punctuation">(</span></span>
<span class="line">        value <span class="token operator">=</span> <span class="token annotation punctuation">@Queue</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">&quot;direct.queue1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span></span>
<span class="line">        exchange <span class="token operator">=</span> <span class="token annotation punctuation">@Exchange</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">&quot;hmall.direct&quot;</span><span class="token punctuation">,</span> type <span class="token operator">=</span> <span class="token class-name">ExchangeTypes</span><span class="token punctuation">.</span><span class="token constant">DIRECT</span><span class="token punctuation">)</span><span class="token punctuation">,</span></span>
<span class="line">        key <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">&quot;red&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;blue&quot;</span><span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">)</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">listenDirectQueue1</span><span class="token punctuation">(</span><span class="token class-name">String</span> msg<span class="token punctuation">)</span><span class="token punctuation">{</span></span>
<span class="line">    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;消费者1接收到direct.queue1的消息：【&quot;</span> <span class="token operator">+</span> msg <span class="token operator">+</span> <span class="token string">&quot;】&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token annotation punctuation">@RabbitListener</span><span class="token punctuation">(</span>bindings <span class="token operator">=</span> <span class="token annotation punctuation">@QueueBinding</span><span class="token punctuation">(</span></span>
<span class="line">        value <span class="token operator">=</span> <span class="token annotation punctuation">@Queue</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">&quot;direct.queue2&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span></span>
<span class="line">        exchange <span class="token operator">=</span> <span class="token annotation punctuation">@Exchange</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">&quot;hmall.direct&quot;</span><span class="token punctuation">,</span> type <span class="token operator">=</span> <span class="token class-name">ExchangeTypes</span><span class="token punctuation">.</span><span class="token constant">DIRECT</span><span class="token punctuation">)</span><span class="token punctuation">,</span></span>
<span class="line">        key <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">&quot;red&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;yellow&quot;</span><span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">)</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">listenDirectQueue2</span><span class="token punctuation">(</span><span class="token class-name">String</span> msg<span class="token punctuation">)</span><span class="token punctuation">{</span></span>
<span class="line">    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;消费者2接收到direct.queue2的消息：【&quot;</span> <span class="token operator">+</span> msg <span class="token operator">+</span> <span class="token string">&quot;】&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>类型默认为DIRECT</p></blockquote><p>也可以使用TOPIC：</p><div class="language-Java line-numbers-mode" data-highlighter="prismjs" data-ext="Java" data-title="Java"><pre><code><span class="line">@RabbitListener(bindings = @QueueBinding(</span>
<span class="line">    value = @Queue(name = &quot;topic.queue1&quot;),</span>
<span class="line">    exchange = @Exchange(name = &quot;hmall.topic&quot;, type = ExchangeTypes.TOPIC),</span>
<span class="line">    key = &quot;china.#&quot;</span>
<span class="line">))</span>
<span class="line">public void listenTopicQueue1(String msg){</span>
<span class="line">    System.out.println(&quot;消费者1接收到topic.queue1的消息：【&quot; + msg + &quot;】&quot;);</span>
<span class="line">}</span>
<span class="line"></span>
<span class="line">@RabbitListener(bindings = @QueueBinding(</span>
<span class="line">    value = @Queue(name = &quot;topic.queue2&quot;),</span>
<span class="line">    exchange = @Exchange(name = &quot;hmall.topic&quot;, type = ExchangeTypes.TOPIC),</span>
<span class="line">    key = &quot;#.news&quot;</span>
<span class="line">))</span>
<span class="line">public void listenTopicQueue2(String msg){</span>
<span class="line">    System.out.println(&quot;消费者2接收到topic.queue2的消息：【&quot; + msg + &quot;】&quot;);</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>FANOUT也是同理（且不需要key），只需根据交换机类型进行type的修改即可。</p><h2 id="消息内容序列化" tabindex="-1"><a class="header-anchor" href="#消息内容序列化"><span>消息内容序列化</span></a></h2><p>生产者使用convertAndSend发送消息时，我们发现消息内容是Object，这意味着我们不懂那可以使用String以及Integer等类型，还可以使用自定的数据结构来传输数据，这时候就需要序列化以及反序列化了。原版使用的是**<code>SimpleMessageConverter</code>**，这玩意基于JDK自己实现的序列化实现，JDK自带的序列化带有几个缺点：</p><ul><li>数据体积过大</li><li>有安全漏洞</li><li>可读性差</li></ul><p>那么我们就得换一个序列化器：Jackson2JsonMessageConverter，首先引入jackson的依赖：</p><div class="language-XML line-numbers-mode" data-highlighter="prismjs" data-ext="XML" data-title="XML"><pre><code><span class="line">&lt;dependency&gt;</span>
<span class="line">    &lt;groupId&gt;com.fasterxml.jackson.dataformat&lt;/groupId&gt;</span>
<span class="line">    &lt;artifactId&gt;jackson-dataformat-xml&lt;/artifactId&gt;</span>
<span class="line">    &lt;version&gt;2.9.10&lt;/version&gt;</span>
<span class="line">&lt;/dependency&gt;</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后在一个<code>@Configuration</code>类中注入一个Bean即可完成序列化器的配置：</p><div class="language-Java line-numbers-mode" data-highlighter="prismjs" data-ext="Java" data-title="Java"><pre><code><span class="line">@Bean</span>
<span class="line">public MessageConverter messageConverter(){</span>
<span class="line">    // 1.定义消息转换器</span>
<span class="line">    Jackson2JsonMessageConverter jackson2JsonMessageConverter = new Jackson2JsonMessageConverter();</span>
<span class="line">    // 2.配置自动创建消息id，用于识别不同消息，也可以在业务中基于ID判断是否是重复消息</span>
<span class="line">    jackson2JsonMessageConverter.setCreateMessageIds(true);</span>
<span class="line">    return jackson2JsonMessageConverter;</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>在 <code>spring-boot-starter-amqp</code> 中，默认使用：</p><ul><li><strong><code>SimpleMessageConverter</code></strong>（旧版）或</li><li><strong><code>Jackson2JsonMessageConverter</code></strong>（推荐，Spring Boot 2.0+ 自动配置）</li></ul><p>也即只要使用了2.0+的<code>spring-boot-starter-web</code>就自动配置Jackson了。</p></blockquote><h2 id="mq的应用场景" tabindex="-1"><a class="header-anchor" href="#mq的应用场景"><span>MQ的应用场景</span></a></h2><p>首先是<strong>不适合</strong>的场景：</p><table><thead><tr><th style="text-align:left;">场景</th><th style="text-align:left;">原因</th></tr></thead><tbody><tr><td style="text-align:left;">强一致性要求（如银行核心交易）</td><td style="text-align:left;">MQ 通常只保证最终一致</td></tr><tr><td style="text-align:left;">超低延迟要求（&lt;1ms）</td><td style="text-align:left;">网络 + 持久化带来额外开销</td></tr><tr><td style="text-align:left;">简单单体应用</td><td style="text-align:left;">引入 MQ 增加复杂度，得不偿失</td></tr></tbody></table><p><strong>这样的场景尽量避免使用MQ</strong>平白无故增加复杂度！</p><p>MQ的核心是<strong>异步</strong>，将本次业务逻辑中<strong>不是必须立刻完成并返回的操作</strong>交给消息队列，等后面再说，也即<strong>不阻塞当前线程</strong>。 符合这一要求的业务操作都可以考虑使用MQ进行优化：</p><table><thead><tr><th style="text-align:left;"><strong>场景需求</strong></th><th style="text-align:left;"><strong>核心目的</strong></th><th style="text-align:left;"><strong>典型示例</strong></th></tr></thead><tbody><tr><td style="text-align:left;"><strong>系统解耦</strong></td><td style="text-align:left;">消除服务间强依赖</td><td style="text-align:left;">用户注册 → 邮件服务、积分服务、日志服务各自独立消费</td></tr><tr><td style="text-align:left;"><strong>异步处理</strong></td><td style="text-align:left;">提升响应速度与吞吐量</td><td style="text-align:left;">下单后立即返回，后台异步扣库存、发通知</td></tr><tr><td style="text-align:left;"><strong>流量削峰</strong></td><td style="text-align:left;">抵御突发高并发</td><td style="text-align:left;">秒杀请求先入队，订单服务匀速处理</td></tr><tr><td style="text-align:left;"><strong>最终一致性</strong></td><td style="text-align:left;">跨服务数据一致</td><td style="text-align:left;">支付成功 → 发消息 → 库存服务扣减（失败可重试）</td></tr><tr><td style="text-align:left;"><strong>事件广播</strong></td><td style="text-align:left;">一对多通知</td><td style="text-align:left;">配置更新事件 → 所有微服务监听并刷新缓存</td></tr><tr><td style="text-align:left;"><strong>任务队列</strong></td><td style="text-align:left;">后台执行耗时作业</td><td style="text-align:left;">视频上传 → 入队 → 转码服务异步处理</td></tr><tr><td style="text-align:left;"><strong>日志/数据管道</strong></td><td style="text-align:left;">高吞吐数据收集</td><td style="text-align:left;">应用日志 → MQ → ELK 或 Flink 实时分析</td></tr></tbody></table><p>注意以下常踩的坑：</p><table><thead><tr><th style="text-align:left;">风险</th><th style="text-align:left;">解决方案</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>消息丢失</strong></td><td style="text-align:left;">- 消息持久化 - 生产者确认（Publisher Confirm） - 消费者手动 ACK</td></tr><tr><td style="text-align:left;"><strong>重复消费</strong></td><td style="text-align:left;">- 消费者实现<strong>幂等性</strong>（如用订单ID去重）</td></tr><tr><td style="text-align:left;"><strong>顺序错乱</strong></td><td style="text-align:left;">- 单队列单消费者保序 - 或用 RocketMQ/Kafka 分区保序</td></tr><tr><td style="text-align:left;"><strong>调试困难</strong></td><td style="text-align:left;">- 完善日志追踪（TraceID 透传） - 使用消息轨迹工具</td></tr><tr><td style="text-align:left;"><strong>过度异步</strong></td><td style="text-align:left;">- 不要所有操作都异步！核心步骤（如扣款）仍需同步校验</td></tr></tbody></table><p>最后虽然我们可以在消费者服务中进行二次校验，但还是尽量避免出现<strong>过早提交异步操作</strong>，结果后面当前线程业务<strong>出错导致需要回滚</strong>的情况出现，考虑将异步操作的提交放到<strong>完全校验的后面</strong>！</p><blockquote><p><strong>“只有当本地业务逻辑（包括数据库事务）完全成功提交后，才发送异步消息。”</strong><strong>绝不能在事务提交前发消息，否则会导致「数据不一致」。</strong></p></blockquote><h2 id="生产者可靠性" tabindex="-1"><a class="header-anchor" href="#生产者可靠性"><span>生产者可靠性</span></a></h2><p>有时<strong>生产者发送消息</strong>会出现意外，RabbitMQ提供了一些处理方案：</p><h3 id="生产者重试" tabindex="-1"><a class="header-anchor" href="#生产者重试"><span>生产者重试</span></a></h3><p>有时候生产者会和MQ断连，这时候就需要<strong>自动重连</strong>，而且生产者发送消息也会出现无法到达的情况，这时候也需要<strong>消息重试</strong>：</p><div class="language-YAML line-numbers-mode" data-highlighter="prismjs" data-ext="YAML" data-title="YAML"><pre><code><span class="line">spring:</span>
<span class="line">  rabbitmq:</span>
<span class="line">    connection-timeout: 1s # 设置MQ的连接超时时间</span>
<span class="line">    template:</span>
<span class="line">      retry:</span>
<span class="line">        enabled: true # 开启超时重试机制</span>
<span class="line">        initial-interval: 1000ms # 失败后的初始等待时间</span>
<span class="line">        multiplier: 1 # 失败后下次的等待时长倍数，下次等待时长 = initial-interval * multiplier</span>
<span class="line">        max-attempts: 3 # 最大重试次数</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>就是<strong>消息没发成功就重试</strong></p><blockquote><p>以上为默认配置，如有需求可以声明修改</p></blockquote><h3 id="生产者确认" tabindex="-1"><a class="header-anchor" href="#生产者确认"><span>生产者确认</span></a></h3><p>一般情况下，只要生产者与MQ之间的网路连接顺畅，基本不会出现发送消息丢失的情况，因此大多数情况下我们无需考虑这种问题。 不过，在少数情况下，也会出现消息发送到MQ之后丢失的现象，比如：</p><ul><li>生产者发送消息到达MQ后未找到<code>Exchange</code></li><li>生产者发送消息到达MQ的<code>Exchange</code>后，未找到合适的<code>Queue</code>，因此无法路由（<strong>路由失败</strong>）</li><li>MQ内部处理消息的进程发生了异常</li></ul><p>针对上述情况，RabbitMQ提供了生产者消息确认机制，包括<code>Publisher Confirm</code>和<code>Publisher Return</code>两种。在开启确认机制的情况下，当生产者发送消息给MQ后，MQ会根据消息处理的情况返回不同的<strong>回执</strong>。</p><ul><li>当消息投递到MQ，但是<strong>路由失败</strong>时，通过<strong>Publisher Return</strong>返回异常信息，同时返回ack的确认信息，代表投递成功</li><li>临时消息投递到了MQ，并且入队成功，返回ACK，告知投递成功</li><li>持久消息投递到了MQ，并且入队完成持久化，返回ACK ，告知投递成功</li><li>其它情况都会返回NACK，告知投递失败</li></ul><blockquote><p>其中<code>ack</code>和<code>nack</code>属于<strong>Publisher Confirm</strong>机制，<code>ack</code>是投递成功；<code>nack</code>是投递失败。 而<code>return</code>则属于<strong>Publisher Return</strong>机制。</p><p>注意！<strong><code>Return</code> 和 <code>Confirm</code> 可以同时发生</strong>，它们解决的是<strong>不同阶段的问题</strong>。</p></blockquote><p>要想开启生产者确认，只需要到yml配置文件中：</p><div class="language-YAML line-numbers-mode" data-highlighter="prismjs" data-ext="YAML" data-title="YAML"><pre><code><span class="line">spring:</span>
<span class="line">  rabbitmq:</span>
<span class="line">    publisher-confirm-type: correlated # 开启publisher confirm机制，并设置confirm类型</span>
<span class="line">    publisher-returns: true # 开启publisher return机制</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里<code>publisher-confirm-type</code>有三种模式可选：</p><ul><li><code>none</code>：关闭confirm机制</li><li><code>simple</code>：同步阻塞等待MQ的回执</li><li><code>correlated</code>：MQ异步回调返回回执</li></ul><p>同时amqp也提供了return callback的记录接口帮助我们记录日志：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token annotation punctuation">@Slf4j</span></span>
<span class="line"><span class="token annotation punctuation">@AllArgsConstructor</span></span>
<span class="line"><span class="token annotation punctuation">@Configuration</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MqConfig</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">RabbitTemplate</span> rabbitTemplate<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token annotation punctuation">@PostConstruct</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span></span>
<span class="line">        rabbitTemplate<span class="token punctuation">.</span><span class="token function">setReturnsCallback</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">RabbitTemplate<span class="token punctuation">.</span>ReturnsCallback</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">            <span class="token annotation punctuation">@Override</span></span>
<span class="line">            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">returnedMessage</span><span class="token punctuation">(</span><span class="token class-name">ReturnedMessage</span> returned<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">                log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">&quot;触发return callback,&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">                log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">&quot;exchange: {}&quot;</span><span class="token punctuation">,</span> returned<span class="token punctuation">.</span><span class="token function">getExchange</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">                log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">&quot;routingKey: {}&quot;</span><span class="token punctuation">,</span> returned<span class="token punctuation">.</span><span class="token function">getRoutingKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">                log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">&quot;message: {}&quot;</span><span class="token punctuation">,</span> returned<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">                log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">&quot;replyCode: {}&quot;</span><span class="token punctuation">,</span> returned<span class="token punctuation">.</span><span class="token function">getReplyCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">                log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">&quot;replyText: {}&quot;</span><span class="token punctuation">,</span> returned<span class="token punctuation">.</span><span class="token function">getReplyText</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">            <span class="token punctuation">}</span></span>
<span class="line">        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样Client就会在接收到return callback时将学习内容记录到log中。</p><p>同样的，也给confirm准备了封装好的对象以供我们查看ack：</p><div class="language-Java line-numbers-mode" data-highlighter="prismjs" data-ext="Java" data-title="Java"><pre><code><span class="line">@Test</span>
<span class="line">void testPublisherConfirm() {</span>
<span class="line">    // 1.创建CorrelationData</span>
<span class="line">    CorrelationData cd = new CorrelationData();</span>
<span class="line">    // 2.给Future添加ConfirmCallback</span>
<span class="line">    cd.getFuture().addCallback(new ListenableFutureCallback&lt;CorrelationData.Confirm&gt;() {</span>
<span class="line">        @Override</span>
<span class="line">        public void onFailure(Throwable ex) {</span>
<span class="line">            // 2.1.Future发生异常时的处理逻辑，基本不会触发</span>
<span class="line">            log.error(&quot;send message fail&quot;, ex);</span>
<span class="line">        }</span>
<span class="line">        @Override</span>
<span class="line">        public void onSuccess(CorrelationData.Confirm result) {</span>
<span class="line">            // 2.2.Future接收到回执的处理逻辑，参数中的result就是回执内容</span>
<span class="line">            if(result.isAck()){ // result.isAck()，boolean类型，true代表ack回执，false 代表 nack回执</span>
<span class="line">                log.debug(&quot;发送消息成功，收到 ack!&quot;);</span>
<span class="line">            }else{ // result.getReason()，String类型，返回nack时的异常描述</span>
<span class="line">                log.error(&quot;发送消息失败，收到 nack, reason : {}&quot;, result.getReason());</span>
<span class="line">            }</span>
<span class="line">        }</span>
<span class="line">    });</span>
<span class="line">    // 3.发送消息</span>
<span class="line">    rabbitTemplate.convertAndSend(&quot;hmall.direct&quot;, &quot;q&quot;, &quot;hello&quot;, cd);</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>就是对异步的阻塞获取结果，类似js的Promise：</p><table><thead><tr><th style="text-align:left;">概念</th><th style="text-align:left;">Java（Spring / RabbitMQ）</th><th style="text-align:left;">JavaScript / 通用并发模型</th><th style="text-align:left;">作用</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>异步操作发起者</strong></td><td style="text-align:left;"><code>rabbitTemplate.convertAndSend(..., correlationData)</code></td><td style="text-align:left;"><code>fetch(url)</code> / <code>someAsyncTask()</code></td><td style="text-align:left;">启动一个异步任务</td></tr><tr><td style="text-align:left;"><strong>结果占位符</strong></td><td style="text-align:left;"><code>CorrelationData.getFuture()</code> → <code>ListenableFuture&lt;Confirm&gt;</code></td><td style="text-align:left;"><code>Promise</code></td><td style="text-align:left;">代表“将来会有一个结果”</td></tr><tr><td style="text-align:left;"><strong>结果回调</strong></td><td style="text-align:left;"><code>addCallback(onSuccess, onFailure)</code></td><td style="text-align:left;"><code>.then().catch()</code> 或 <code>await</code></td><td style="text-align:left;">处理成功或失败</td></tr></tbody></table></blockquote><h2 id="mq可靠性" tabindex="-1"><a class="header-anchor" href="#mq可靠性"><span>MQ可靠性</span></a></h2><p>有时MQ收到了消息，但还是会出现一些意外导致消息丢失，RabbitMQ也提供了几个解决方案：</p><h3 id="数据持久化" tabindex="-1"><a class="header-anchor" href="#数据持久化"><span>数据持久化</span></a></h3><p>为了提升性能，默认情况下MQ的数据都是在内存存储的临时数据，重启后就会消失。为了保证数据的可靠性，必须配置数据持久化，包括：</p><ul><li>交换机持久化</li><li>队列持久化</li><li>消息持久化</li></ul><p>实际上在我们创建交换机，队列的时候默认都会配置持久化，因此不必太过在意。</p><h3 id="lazy-queue" tabindex="-1"><a class="header-anchor" href="#lazy-queue"><span>Lazy Queue</span></a></h3><p>在默认情况下，RabbitMQ会将接收到的信息保存在内存中以降低消息收发的延迟。但在某些特殊情况下，这会导致消息积压，比如：</p><ul><li>消费者宕机或出现网络故障</li><li>消息发送量激增，超过了消费者处理速度</li><li>消费者处理业务发生阻塞</li></ul><p>持久化的时候还需要磁盘IO，这时会占用一点资源导致处理能力下降，RabbitMQ提供了<strong>惰性队列</strong>的解决方案：</p><ul><li>接收到消息后<strong>直接存入磁盘</strong>而非内存</li><li>消费者要消费消息时才会<strong>从磁盘中读取并加载到内存</strong>（也就是懒加载，会<strong>部分缓存一些消息在内存</strong>）</li><li>支持数百万条的消息存储</li></ul><blockquote><p>而在3.12版本之后，LazyQueue已经成为所有队列的默认格式。因此官方推荐升级MQ为3.12版本或者所有队列都设置为LazyQueue模式。</p><p>旧版本想要设置惰性队列有两种方式：</p><ul><li>可视化web界面创建队列的时候可以指定Argument中带上Lazy Mode</li><li>代码中声明：</li></ul><div class="language-Java line-numbers-mode" data-highlighter="prismjs" data-ext="Java" data-title="Java"><pre><code><span class="line">@Bean</span>
<span class="line">public Queue lazyQueue(){</span>
<span class="line">    return QueueBuilder</span>
<span class="line">            .durable(&quot;lazy.queue&quot;)</span>
<span class="line">            .lazy() // 开启Lazy模式</span>
<span class="line">            .build();</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>或者是注解式：</p><div class="language-Java line-numbers-mode" data-highlighter="prismjs" data-ext="Java" data-title="Java"><pre><code><span class="line">@RabbitListener(queuesToDeclare = @Queue(</span>
<span class="line">        name = &quot;lazy.queue&quot;,</span>
<span class="line">        durable = &quot;true&quot;,</span>
<span class="line">        arguments = @Argument(name = &quot;x-queue-mode&quot;, value = &quot;lazy&quot;)</span>
<span class="line">))</span>
<span class="line">public void listenLazyQueue(String msg){</span>
<span class="line">    log.info(&quot;接收到 lazy.queue的消息：{}&quot;, msg);</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></blockquote><h2 id="消费者可靠性" tabindex="-1"><a class="header-anchor" href="#消费者可靠性"><span>消费者可靠性</span></a></h2><p>为了避免消息在消费者层面发生丢失的问题，RabbitMQ也提供了一套处理方案:</p><h3 id="消费者确认" tabindex="-1"><a class="header-anchor" href="#消费者确认"><span>消费者确认</span></a></h3><p>为了确认消费者是否成功处理消息，RabbitMQ提供了消费者确认机制（<strong>Consumer Acknowledgement</strong>）。即：当消费者处理消息结束后，应该向RabbitMQ发送一个回执，告知RabbitMQ自己消息处理状态。回执有三种可选值：</p><table><thead><tr><th style="text-align:left;">回执</th><th style="text-align:left;">方法</th><th style="text-align:left;">作用</th><th style="text-align:left;">是否删除消息</th><th style="text-align:left;">是否重入队</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>ACK</strong></td><td style="text-align:left;"><code>channel.basicAck(tag, false)</code></td><td style="text-align:left;">成功处理</td><td style="text-align:left;">✅ 删除</td><td style="text-align:left;">❌</td></tr><tr><td style="text-align:left;"><strong>NACK</strong></td><td style="text-align:left;"><code>channel.basicNack(tag, false, requeue)</code></td><td style="text-align:left;">处理失败</td><td style="text-align:left;">❌ 不删</td><td style="text-align:left;">✅ <code>requeue=true</code> 时重入队</td></tr><tr><td style="text-align:left;"><strong>Reject</strong></td><td style="text-align:left;"><code>channel.basicReject(tag, requeue)</code></td><td style="text-align:left;">拒绝消息（通常格式错误）</td><td style="text-align:left;">❌ 不删</td><td style="text-align:left;">✅ <code>requeue=true</code> 时重入</td></tr></tbody></table><blockquote><p>消费者从队列获取到消息后不会直接通知MQ删除该消息，待完成获取以及业务处理后再手动ack再会完成删除</p></blockquote><p>amqp中提供了几种ack确认处理机制：</p><table><thead><tr><th style="text-align:left;">模式</th><th style="text-align:left;">配置</th><th style="text-align:left;">行为</th><th style="text-align:left;">可靠性</th><th style="text-align:left;">适用场景</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>none</strong></td><td style="text-align:left;"><code>acknowledge-mode: none</code></td><td style="text-align:left;">消息一投递就删除</td><td style="text-align:left;">❌ 极低</td><td style="text-align:left;">测试/日志（可丢）</td></tr><tr><td style="text-align:left;"><strong>auto</strong></td><td style="text-align:left;"><code>acknowledge-mode: auto</code>（默认）</td><td style="text-align:left;">无异常 → 自动 ACK；有异常 → NACK（重入队）</td><td style="text-align:left;">⚠️ 中等</td><td style="text-align:left;">简单业务</td></tr><tr><td style="text-align:left;"><strong>manual</strong></td><td style="text-align:left;"><code>acknowledge-mode: manual</code></td><td style="text-align:left;"><strong>必须手动调用 <code>basicAck/Nack/Reject</code></strong></td><td style="text-align:left;">✅ 高</td><td style="text-align:left;"><strong>生产环境推荐</strong></td></tr></tbody></table><blockquote><p>📌 <strong>强烈建议生产环境使用 <code>manual</code> 模式</strong>，完全掌控消息生命周期。</p></blockquote><p>想要去修改模式也很简单，仅需到yml配置文件中修改：</p><div class="language-YAML line-numbers-mode" data-highlighter="prismjs" data-ext="YAML" data-title="YAML"><pre><code><span class="line">spring:</span>
<span class="line">  rabbitmq:</span>
<span class="line">    listener:</span>
<span class="line">      simple:</span>
<span class="line">        acknowledge-mode: manual # 手动处理，配合手动提交使用</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>手动模式需要自己调用接口返回回执：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token annotation punctuation">@RabbitListener</span><span class="token punctuation">(</span>queues <span class="token operator">=</span> <span class="token string">&quot;order.queue&quot;</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">listen</span><span class="token punctuation">(</span><span class="token class-name">Message</span> message<span class="token punctuation">,</span> <span class="token class-name">Channel</span> channel<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">long</span> deliveryTag <span class="token operator">=</span> message<span class="token punctuation">.</span><span class="token function">getMessageProperties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getDeliveryTag</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    </span>
<span class="line">    <span class="token keyword">try</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token comment">// 1. 业务处理（如扣库存、发通知）</span></span>
<span class="line">        <span class="token function">processOrder</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        </span>
<span class="line">        <span class="token comment">// 2. 成功 → 手动 ACK</span></span>
<span class="line">        channel<span class="token punctuation">.</span><span class="token function">basicAck</span><span class="token punctuation">(</span>deliveryTag<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        </span>
<span class="line">    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">BusinessException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token comment">// 3. 业务异常 → 拒绝并重入队（可重试）</span></span>
<span class="line">        channel<span class="token punctuation">.</span><span class="token function">basicNack</span><span class="token punctuation">(</span>deliveryTag<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        </span>
<span class="line">    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token comment">// 4. 严重异常 → 拒绝且不重入队（进死信队列）</span></span>
<span class="line">        channel<span class="token punctuation">.</span><span class="token function">basicNack</span><span class="token punctuation">(</span>deliveryTag<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>如无性能需求，尽量在<strong>完成所有业务后</strong>再手动ack掉消息</p></blockquote><h3 id="消费者重试" tabindex="-1"><a class="header-anchor" href="#消费者重试"><span>消费者重试</span></a></h3><p>当消费者出现异常后，消息会不断requeue（重入队）到队列，再重新发送给消费者。如果消费者再次执行依然出错，消息会再次requeue到队列，再次投递，直到消息处理成功为止。</p><p>极端情况就是消费者一直无法执行成功，那么消息requeue就会无限循环，导致mq的消息处理飙升，带来不必要的压力。为了应对上述情况Spring又提供了消费者失败重试机制：在消费者出现异常时利用本地重试，而不是无限制的requeue到mq队列。</p><div class="language-YAML line-numbers-mode" data-highlighter="prismjs" data-ext="YAML" data-title="YAML"><pre><code><span class="line">spring:</span>
<span class="line">  rabbitmq:</span>
<span class="line">    listener:</span>
<span class="line">      simple:</span>
<span class="line">        retry:</span>
<span class="line">          enabled: true # 开启消费者失败重试</span>
<span class="line">          initial-interval: 1000ms # 初识的失败等待时长为1秒</span>
<span class="line">          multiplier: 1 # 失败的等待时长倍数，下次等待时长 = multiplier * last-interval</span>
<span class="line">          max-attempts: 3 # 最大重试次数</span>
<span class="line">          stateless: true # true无状态；false有状态。如果业务中包含事务，这里改为false</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p><strong>为什么队列发送消息的重试设置是在消费者配置的？假如几个消费者重试配置不一样会怎么样？</strong></p><p><strong>这个 <code>retry</code> 配置确实是“消费者本地的重试”，不是“队列”的属性，也不是“生产者”的行为。</strong> 它控制的是：<strong>当某个消费者实例在处理消息时抛出异常，是否在本机重试，以及重试几次。</strong></p><ul><li><strong>它属于消费者应用的配置</strong></li><li><strong>不同消费者可以有不同的重试策略</strong></li><li><strong>RabbitMQ 队列本身完全不知道这个配置的存在</strong></li></ul><p><strong><code>spring.rabbitmq.listener.simple.retry</code> 是“消费者对自己说：我再试几次”，而不是“队列要求所有消费者重试”。</strong></p></blockquote><p>在重试达到最大次数后消息就会丢失，这时候需要日志记录之类的我们就需要到amqp提供的接口中进行操作，Spring允许我们自定义重试次数耗尽后的消息处理策略，这个策略是由<code>MessageRecovery</code>接口来定义的，它有3个不同实现：</p><ul><li><code>RejectAndDontRequeueRecoverer</code>：重试耗尽后，直接<code>reject</code>，丢弃消息。<strong>默认就是这种方式</strong></li><li><code>ImmediateRequeueMessageRecoverer</code>：重试耗尽后，返回<code>nack</code>，消息重新入队</li><li><code>RepublishMessageRecoverer</code>：重试耗尽后，将失败消息投递到指定的交换机</li></ul><p>比较优雅的一种处理方案是<code>RepublishMessageRecoverer</code>，失败后将消息投递到一个指定的，专门存放异常消息的队列（<strong>死信队列</strong>），后续由人工集中处理。</p><p>想要使用这个<code>RepublishMessageRecoverer</code>，我们需要先配置一个消息队列（<strong>死信队列</strong>）专门用于存储这些失败消息，而要配置这个消息队列要求我们一定得先搞个direct的交换机（<strong>死信交换机</strong>），因为<code>RepublishMessageRecoverer</code>只接受交换机和<code>RoutingKey</code>作为传入参数：</p><div class="language-Java line-numbers-mode" data-highlighter="prismjs" data-ext="Java" data-title="Java"><pre><code><span class="line">@Configuration</span>
<span class="line">@ConditionalOnProperty(name = &quot;spring.rabbitmq.listener.simple.retry.enabled&quot;, havingValue = &quot;true&quot;)</span>
<span class="line">public class ErrorMessageConfig {</span>
<span class="line">    @Bean</span>
<span class="line">    public DirectExchange errorMessageExchange(){</span>
<span class="line">        return new DirectExchange(&quot;error.direct&quot;);</span>
<span class="line">    }</span>
<span class="line">    @Bean</span>
<span class="line">    public Queue errorQueue(){</span>
<span class="line">        return new Queue(&quot;error.queue&quot;, true);</span>
<span class="line">    }</span>
<span class="line">    @Bean</span>
<span class="line">    public Binding errorBinding(Queue errorQueue, DirectExchange errorMessageExchange){</span>
<span class="line">        return BindingBuilder.bind(errorQueue).to(errorMessageExchange).with(&quot;error&quot;);</span>
<span class="line">    }</span>
<span class="line">	// 配置重试失败处理器</span>
<span class="line">    @Bean</span>
<span class="line">    public MessageRecoverer republishMessageRecoverer(RabbitTemplate rabbitTemplate){</span>
<span class="line">        return new RepublishMessageRecoverer(rabbitTemplate, &quot;error.direct&quot;, &quot;error&quot;);</span>
<span class="line">    }</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>❌ <strong>死信队列（DLQ）不能直接使用 RabbitMQ 的「默认交换机（Default Exchange）」进行绑定。</strong> ✅ <strong>必须显式声明一个交换机（如 <code>DirectExchange</code>、<code>TopicExchange</code> 等）并绑定到 DLQ。</strong></p></blockquote><h3 id="消息幂等性" tabindex="-1"><a class="header-anchor" href="#消息幂等性"><span>消息幂等性</span></a></h3><p>理解<strong>消息幂等性</strong>，关键在于抓住一句话：</p><blockquote><p><strong>“同一条消息被消费多次，对系统产生的最终结果与只消费一次完全相同。”</strong></p></blockquote><p>它不是 MQ 的功能，而是<strong>消费者业务逻辑必须具备的性质</strong>，用来应对<strong>消息重复投递</strong>这一分布式系统的常态。</p><p>在 RabbitMQ、Kafka 等消息队列中，<strong>消息重复是不可避免的</strong>，常见原因包括：</p><table><thead><tr><th style="text-align:left;">场景</th><th style="text-align:left;">说明</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>消费者处理成功，但 ACK 丢失</strong></td><td style="text-align:left;">消费者处理完消息 → 网络闪断 → ACK 未送达 Broker → Broker 重发</td></tr><tr><td style="text-align:left;"><strong>消费者处理中宕机</strong></td><td style="text-align:left;">消息已取出但未 ACK → 消费者挂掉 → Broker 重新投递</td></tr><tr><td style="text-align:left;"><strong>生产者重试</strong></td><td style="text-align:left;">生产者未收到 confirm → 重发 → 实际 Broker 已接收（导致重复）</td></tr><tr><td style="text-align:left;"><strong>MQ 自身重试机制</strong></td><td style="text-align:left;">如 RabbitMQ 的 <code>requeue=true</code> 导致消息重回队列</td></tr></tbody></table><blockquote><p>📌 <strong>结论：任何基于“至少一次”（At-Least-Once）语义的 MQ，都可能产生重复消息。</strong></p></blockquote><p>说了这么多，其实我们就是想要业务不会因为<strong>意外的多次执行</strong>导致错误的发生（也即消息幂等性），或者至少避免出现这种<strong>意外的多次执行</strong>，常见的实现方式：</p><table><thead><tr><th style="text-align:left;">方法</th><th style="text-align:left;">适用场景</th><th style="text-align:left;">原理</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>1. 唯一业务 ID + 去重表</strong></td><td style="text-align:left;">订单创建、支付</td><td style="text-align:left;">数据库唯一索引 / Redis SETNX</td></tr><tr><td style="text-align:left;"><strong>2. 状态机校验</strong></td><td style="text-align:left;">订单状态流转</td><td style="text-align:left;">只允许“待支付 → 已支付”，重复“已支付”消息被忽略</td></tr><tr><td style="text-align:left;"><strong>3. 乐观锁CAP（版本号）</strong></td><td style="text-align:left;">更新操作</td><td style="text-align:left;"><code>UPDATE ... WHERE version = oldVersion</code></td></tr><tr><td style="text-align:left;"><strong>4. Token 机制</strong></td><td style="text-align:left;">前端防重提交</td><td style="text-align:left;">提交时携带 token，服务端校验后失效</td></tr></tbody></table><blockquote><p><strong>“MQ 不保证不重复，你必须保证不怕重复。”</strong></p></blockquote><h2 id="延迟消息" tabindex="-1"><a class="header-anchor" href="#延迟消息"><span>延迟消息</span></a></h2><h3 id="死信交换机" tabindex="-1"><a class="header-anchor" href="#死信交换机"><span>死信交换机</span></a></h3><p>一条消息在以下 <strong>任意一种情况</strong> 下会变成“<strong>死信</strong>”：</p><table><thead><tr><th style="text-align:left;">触发条件</th><th style="text-align:left;">说明</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>1. 消息被拒绝（Reject / Nack）且 <code>requeue=false</code></strong></td><td style="text-align:left;">消费者明确表示“我不处理这条消息，也不要它重回队列”（重试失败）</td></tr><tr><td style="text-align:left;"><strong>2. 消息 TTL（Time-To-Live）过期</strong></td><td style="text-align:left;">消息在队列中存活时间超过设定值（如 10 秒未被消费）</td></tr><tr><td style="text-align:left;"><strong>3. 队列达到最大长度（x-max-length）</strong></td><td style="text-align:left;">队列满了，新消息进来会挤掉队首消息 → 被挤掉的消息变死信</td></tr></tbody></table><blockquote><p>📌 注意：<strong>只有配置了死信交换机（DLX）的队列，才会将死信转发；否则直接丢弃！</strong></p></blockquote><p>死信流程：</p><div class="language-mermaid line-numbers-mode" data-highlighter="prismjs" data-ext="mermaid" data-title="mermaid"><pre><code><span class="line"><span class="token keyword">graph</span> LR</span>
<span class="line">A<span class="token text string">[生产者]</span> <span class="token arrow operator">--&gt;</span><span class="token label property">|发送消息|</span> B<span class="token text string">(业务队列: order.queue)</span></span>
<span class="line">B <span class="token arrow operator">--&gt;</span><span class="token label property">|正常消费|</span> C<span class="token text string">[消费者]</span></span>
<span class="line">B <span class="token arrow operator">--&gt;</span><span class="token label property">|消息变死信|</span> D<span class="token text string">[死信交换机: dlx]</span></span>
<span class="line">D <span class="token arrow operator">--&gt;</span><span class="token label property">|路由|</span> E<span class="token text string">[死信队列: dlq.order]</span></span>
<span class="line">E <span class="token arrow operator">--&gt;</span> F<span class="token text string">[监控/重试/人工处理]</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>要想在代码中处理死信，只需要准备好死信交换机以及死信队列，然后将需要处理死信的队列与死信交换机绑定即可：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token annotation punctuation">@Configuration</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DirectConfig</span> <span class="token punctuation">{</span></span>
<span class="line"></span>
<span class="line">    <span class="token annotation punctuation">@Bean</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token class-name">DirectExchange</span> <span class="token function">dlxExchange</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment">// 创建死信交换机</span></span>
<span class="line">        <span class="token keyword">return</span> <span class="token class-name">ExchangeBuilder</span><span class="token punctuation">.</span></span>
<span class="line">                <span class="token function">directExchange</span><span class="token punctuation">(</span><span class="token string">&quot;dlx.direct&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span></span>
<span class="line">                <span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">    </span>
<span class="line">    <span class="token annotation punctuation">@Bean</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token class-name">Queue</span> <span class="token function">dlxQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment">// 创建死信队列</span></span>
<span class="line">        <span class="token keyword">return</span> <span class="token class-name">QueueBuilder</span><span class="token punctuation">.</span></span>
<span class="line">                <span class="token function">durable</span><span class="token punctuation">(</span><span class="token string">&quot;dlx.queue&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span></span>
<span class="line">                <span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">    </span>
<span class="line">    <span class="token annotation punctuation">@Bean</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token class-name">Binding</span> <span class="token function">bindingDlxQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 绑定死信队列</span></span>
<span class="line">        <span class="token keyword">return</span> <span class="token class-name">BindingBuilder</span><span class="token punctuation">.</span></span>
<span class="line">                <span class="token function">bind</span><span class="token punctuation">(</span><span class="token function">dlxQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span></span>
<span class="line">                <span class="token keyword">to</span><span class="token punctuation">(</span><span class="token function">dlxExchange</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span></span>
<span class="line">                <span class="token keyword">with</span><span class="token punctuation">(</span><span class="token string">&quot;dlx&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token annotation punctuation">@Bean</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token class-name">DirectExchange</span> <span class="token function">directExchange</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">return</span> <span class="token class-name">ExchangeBuilder</span><span class="token punctuation">.</span></span>
<span class="line">                <span class="token function">directExchange</span><span class="token punctuation">(</span><span class="token string">&quot;hmall.direct&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span></span>
<span class="line">                <span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token annotation punctuation">@Bean</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token class-name">Queue</span> <span class="token function">directQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 创建队列，绑定死信交换机</span></span>
<span class="line">        <span class="token keyword">return</span> <span class="token class-name">QueueBuilder</span><span class="token punctuation">.</span></span>
<span class="line">                <span class="token function">durable</span><span class="token punctuation">(</span><span class="token string">&quot;direct.queue&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span></span>
<span class="line">                <span class="token function">deadLetterExchange</span><span class="token punctuation">(</span><span class="token string">&quot;dlx.direct&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span>			<span class="token comment">// 绑定死信交换机</span></span>
<span class="line">                <span class="token function">deadLetterRoutingKey</span><span class="token punctuation">(</span><span class="token string">&quot;dlx&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span>				<span class="token comment">// 声明RoutingKey导向指定的死信队列</span></span>
<span class="line">                <span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">    </span>
<span class="line">    <span class="token annotation punctuation">@Bean</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token class-name">Binding</span> <span class="token function">bindingDirectQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">return</span> <span class="token class-name">BindingBuilder</span><span class="token punctuation">.</span></span>
<span class="line">                <span class="token function">bind</span><span class="token punctuation">(</span><span class="token function">directQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span></span>
<span class="line">                <span class="token keyword">to</span><span class="token punctuation">(</span><span class="token function">directExchange</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span></span>
<span class="line">                <span class="token keyword">with</span><span class="token punctuation">(</span><span class="token string">&quot;red&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过<code>deadLetterExchange</code>就可以将自制的队列和死信交换机绑定了。</p><p>而想要实现延迟消息，我们就只需要在一个设置了ttl的正常队列（<strong>但是没人监听导致必定过期</strong>），ttl到期后触发死信机制，将消息发给死信交换机，交换机根据RoutingKey发给指定的死信队列，这个死信队列是有消费者监听处理的，现在我们只需要将无人监听的队列加个ttl即可实现延迟消息：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token annotation punctuation">@Bean</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token class-name">Queue</span> <span class="token function">directQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    					<span class="token comment">// 创建无人监听的ttl队列</span></span>
<span class="line">    <span class="token keyword">return</span> <span class="token class-name">QueueBuilder</span><span class="token punctuation">.</span></span>
<span class="line">            <span class="token function">durable</span><span class="token punctuation">(</span><span class="token string">&quot;direct.queue&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span></span>
<span class="line">            <span class="token function">deadLetterExchange</span><span class="token punctuation">(</span><span class="token string">&quot;dlx.direct&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span>		<span class="token comment">// 绑定死信交换机</span></span>
<span class="line">            <span class="token function">deadLetterRoutingKey</span><span class="token punctuation">(</span><span class="token string">&quot;dlx&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span>			<span class="token comment">// 设置RoutingKey</span></span>
<span class="line">            <span class="token function">ttl</span><span class="token punctuation">(</span><span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">.</span>								<span class="token comment">// 设置延迟时间ttl</span></span>
<span class="line">            <span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>普通的队列可以绑定多个交换机，那<strong>可以绑定多个死信交换机吗？</strong></p><p><strong>不可以。一个 RabbitMQ 队列只能绑定一个死信交换机（DLX）。</strong></p><table><thead><tr><th style="text-align:left;">参数</th><th style="text-align:left;">类型</th><th style="text-align:left;">说明</th></tr></thead><tbody><tr><td style="text-align:left;"><code>x-dead-letter-exchange</code></td><td style="text-align:left;"><strong>String</strong></td><td style="text-align:left;">死信目标交换机名称（只能一个）</td></tr><tr><td style="text-align:left;"><code>x-dead-letter-routing-key</code></td><td style="text-align:left;">String</td><td style="text-align:left;">转发死信时使用的 routing key（可选，默认用原消息的 routing key）</td></tr></tbody></table><p>📌 你无法为一个队列设置多个 <code>x-dead-letter-exchange</code>。</p><p><strong>那如果我想把死信路由到多个地方怎么办？</strong></p><p>虽然<strong>一个队列只能有一个 DLX</strong>，但你可以通过将死信交换机设置为<strong>fanout</strong>或者准备<strong>多个RoutingKey相同的死信队列的Direct</strong>来实现<strong>将死信发送给多个队列</strong>。</p><p>交换机只是发送给队列的<strong>策略</strong>，最终我们还是要发给干实事的<strong>队列</strong></p></blockquote><h3 id="延迟消息插件" tabindex="-1"><a class="header-anchor" href="#延迟消息插件"><span>延迟消息插件</span></a></h3><p>基于死信队列虽然可以实现延迟消息，但是太麻烦了。因此RabbitMQ社区提供了一个延迟消息插件来实现相同的效果，其允许消息被暂时存储在交换机中，延时投递到指定的队列中：</p>`,197)),a("p",null,[n[13]||(n[13]=s("官方文档说明：",-1)),a("a",v,[n[12]||(n[12]=s("Scheduling Messages with RabbitMQ | RabbitMQ",-1)),e(t)])]),a("p",null,[n[15]||(n[15]=s("下载地址：",-1)),a("a",b,[n[14]||(n[14]=s("rabbitmq/rabbitmq-delayed-message-exchange: Delayed Messaging for RabbitMQ",-1)),e(t)])]),n[20]||(n[20]=l(`<blockquote><p>已经<strong>archived</strong>了</p></blockquote><p>使用docker部署，我们需要看一下挂载的数据卷：</p><div class="language-Shell line-numbers-mode" data-highlighter="prismjs" data-ext="Shell" data-title="Shell"><pre><code><span class="line">docker volume inspect mq-plugins</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><div class="language-JSON line-numbers-mode" data-highlighter="prismjs" data-ext="JSON" data-title="JSON"><pre><code><span class="line">[</span>
<span class="line">    {</span>
<span class="line">        &quot;CreatedAt&quot;: &quot;2024-06-19T09:22:59+08:00&quot;,</span>
<span class="line">        &quot;Driver&quot;: &quot;local&quot;,</span>
<span class="line">        &quot;Labels&quot;: null,</span>
<span class="line">        &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/mq-plugins/_data&quot;,</span>
<span class="line">        &quot;Name&quot;: &quot;mq-plugins&quot;,</span>
<span class="line">        &quot;Options&quot;: null,</span>
<span class="line">        &quot;Scope&quot;: &quot;local&quot;</span>
<span class="line">    }</span>
<span class="line">]</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line"><span class="token builtin class-name">cd</span> /var/lib/docker/volumes/mq-plugins/_data</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>然后将插件文件传到数据卷中，并安装插件：</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line"><span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> mq rabbitmq-plugins <span class="token builtin class-name">enable</span> rabbitmq_delayed_message_exchange</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>现在我们就可以用代码创建几个交换机以及队列了：</p><p><strong>注解一步到位：</strong></p><div class="language-Java line-numbers-mode" data-highlighter="prismjs" data-ext="Java" data-title="Java"><pre><code><span class="line">@RabbitListener(bindings = @QueueBinding(</span>
<span class="line">        value = @Queue(name = &quot;delay.queue&quot;, durable = &quot;true&quot;),</span>
<span class="line">        exchange = @Exchange(name = &quot;delay.direct&quot;, delayed = &quot;true&quot;),</span>
<span class="line">        key = &quot;delay&quot;</span>
<span class="line">))</span>
<span class="line">public void listenDelayMessage(String msg){</span>
<span class="line">    log.info(&quot;接收到delay.queue的延迟消息：{}&quot;, msg);</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>Bean声明：</strong></p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token annotation punctuation">@Slf4j</span></span>
<span class="line"><span class="token annotation punctuation">@Configuration</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DelayExchangeConfig</span> <span class="token punctuation">{</span></span>
<span class="line"></span>
<span class="line">    <span class="token annotation punctuation">@Bean</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token class-name">DirectExchange</span> <span class="token function">delayExchange</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">return</span> <span class="token class-name">ExchangeBuilder</span></span>
<span class="line">                <span class="token punctuation">.</span><span class="token function">directExchange</span><span class="token punctuation">(</span><span class="token string">&quot;delay.direct&quot;</span><span class="token punctuation">)</span> <span class="token comment">// 指定交换机类型和名称</span></span>
<span class="line">                <span class="token punctuation">.</span><span class="token function">delayed</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 设置delay的属性为true</span></span>
<span class="line">                <span class="token punctuation">.</span><span class="token function">durable</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token comment">// 持久化</span></span>
<span class="line">                <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token annotation punctuation">@Bean</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token class-name">Queue</span> <span class="token function">delayedQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Queue</span><span class="token punctuation">(</span><span class="token string">&quot;delay.queue&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">    </span>
<span class="line">    <span class="token annotation punctuation">@Bean</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token class-name">Binding</span> <span class="token function">delayQueueBinding</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">return</span> <span class="token class-name">BindingBuilder</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token function">delayedQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">to</span><span class="token punctuation">(</span><span class="token function">delayExchange</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">with</span><span class="token punctuation">(</span><span class="token string">&quot;delay&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>后续发送消息时注意带上ttl：</p><div class="language-Java line-numbers-mode" data-highlighter="prismjs" data-ext="Java" data-title="Java"><pre><code><span class="line">@Test</span>
<span class="line">void testPublisherDelayMessage() {</span>
<span class="line">    // 1.创建消息</span>
<span class="line">    String message = &quot;hello, delayed message&quot;;</span>
<span class="line">    // 2.发送消息，利用消息后置处理器添加消息头</span>
<span class="line">    rabbitTemplate.convertAndSend(&quot;delay.direct&quot;, &quot;delay&quot;, message, new MessagePostProcessor() {</span>
<span class="line">        @Override</span>
<span class="line">        public Message postProcessMessage(Message message) throws AmqpException {</span>
<span class="line">            // 添加延迟消息属性</span>
<span class="line">            message.getMessageProperties().setDelay(5000);</span>
<span class="line">            return message;</span>
<span class="line">        }</span>
<span class="line">    });</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>延迟消息插件内部会维护一个本地数据库表，同时使用Elang Timers功能实现计时。如果消息的延迟时间设置较长，可能会导致堆积的延迟消息非常多，会带来较大的CPU开销，同时延迟消息的时间会存在误差。</p><p>因此，<strong>不建议设置延迟时间过长的延迟消息</strong>。</p></blockquote>`,15))])}const f=i(u,[["render",m]]),x=JSON.parse('{"path":"/docs/heimashangcheng/weifuwu/9.xiaoxiduilie（MQ）.html","title":"消息队列","lang":"en-US","frontmatter":{"title":"消息队列","date":"2026-2-11"},"headers":[{"level":2,"title":"RabbitMQ","slug":"rabbitmq","link":"#rabbitmq","children":[{"level":3,"title":"安装与部署","slug":"安装与部署","link":"#安装与部署","children":[]},{"level":3,"title":"整体架构","slug":"整体架构","link":"#整体架构","children":[]},{"level":3,"title":"简要理解","slug":"简要理解","link":"#简要理解","children":[]}]},{"level":2,"title":"配置相关","slug":"配置相关","link":"#配置相关","children":[{"level":3,"title":"配置队列以及交换机","slug":"配置队列以及交换机","link":"#配置队列以及交换机","children":[]},{"level":3,"title":"配置数据隔离","slug":"配置数据隔离","link":"#配置数据隔离","children":[]}]},{"level":2,"title":"Java Client","slug":"java-client","link":"#java-client","children":[{"level":3,"title":"引入依赖","slug":"引入依赖","link":"#引入依赖","children":[]},{"level":3,"title":"配置YML","slug":"配置yml","link":"#配置yml","children":[]},{"level":3,"title":"生产者发送消息","slug":"生产者发送消息","link":"#生产者发送消息","children":[]},{"level":3,"title":"消费者订阅队列","slug":"消费者订阅队列","link":"#消费者订阅队列","children":[]},{"level":3,"title":"消费者负载均衡","slug":"消费者负载均衡","link":"#消费者负载均衡","children":[]}]},{"level":2,"title":"三种发送类型","slug":"三种发送类型","link":"#三种发送类型","children":[{"level":3,"title":"Fanout交换机广播","slug":"fanout交换机广播","link":"#fanout交换机广播","children":[]},{"level":3,"title":"Direct定向发送","slug":"direct定向发送","link":"#direct定向发送","children":[]},{"level":3,"title":"Topic话题通配发送","slug":"topic话题通配发送","link":"#topic话题通配发送","children":[]},{"level":3,"title":"简单总结","slug":"简单总结","link":"#简单总结","children":[]}]},{"level":2,"title":"代码声明队列及交换机","slug":"代码声明队列及交换机","link":"#代码声明队列及交换机","children":[{"level":3,"title":"基于Bean声明","slug":"基于bean声明","link":"#基于bean声明","children":[]},{"level":3,"title":"基于注解声明","slug":"基于注解声明","link":"#基于注解声明","children":[]}]},{"level":2,"title":"消息内容序列化","slug":"消息内容序列化","link":"#消息内容序列化","children":[]},{"level":2,"title":"MQ的应用场景","slug":"mq的应用场景","link":"#mq的应用场景","children":[]},{"level":2,"title":"生产者可靠性","slug":"生产者可靠性","link":"#生产者可靠性","children":[{"level":3,"title":"生产者重试","slug":"生产者重试","link":"#生产者重试","children":[]},{"level":3,"title":"生产者确认","slug":"生产者确认","link":"#生产者确认","children":[]}]},{"level":2,"title":"MQ可靠性","slug":"mq可靠性","link":"#mq可靠性","children":[{"level":3,"title":"数据持久化","slug":"数据持久化","link":"#数据持久化","children":[]},{"level":3,"title":"Lazy Queue","slug":"lazy-queue","link":"#lazy-queue","children":[]}]},{"level":2,"title":"消费者可靠性","slug":"消费者可靠性","link":"#消费者可靠性","children":[{"level":3,"title":"消费者确认","slug":"消费者确认","link":"#消费者确认","children":[]},{"level":3,"title":"消费者重试","slug":"消费者重试","link":"#消费者重试","children":[]},{"level":3,"title":"消息幂等性","slug":"消息幂等性","link":"#消息幂等性","children":[]}]},{"level":2,"title":"延迟消息","slug":"延迟消息","link":"#延迟消息","children":[{"level":3,"title":"死信交换机","slug":"死信交换机","link":"#死信交换机","children":[]},{"level":3,"title":"延迟消息插件","slug":"延迟消息插件","link":"#延迟消息插件","children":[]}]}],"git":{"createdTime":1771171838000,"updatedTime":1771171838000,"contributors":[{"name":"SaltFishGC","email":"130335482+SaltFishGC@users.noreply.github.com","commits":1}]},"filePathRelative":"docs/黑马商城/微服务/9.消息队列（MQ）.md"}');export{f as comp,x as data};
