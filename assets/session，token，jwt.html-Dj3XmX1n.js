import{_ as e,c as l,e as o,o as s}from"./app-CohX4sgD.js";const n={};function i(r,t){return s(),l("div",null,[...t[0]||(t[0]=[o(`<p>它们的核心目标都是解决同一个问题：<strong>如何在无状态的 HTTP 协议下，识别并保持用户的登录状态。</strong></p><hr><h3 id="_1-session-会话" tabindex="-1"><a class="header-anchor" href="#_1-session-会话"><span>1. Session (会话)</span></a></h3><p><strong>核心思想：服务端存储状态</strong></p><p>当用户成功登录后：</p><ol><li><strong>服务器生成 Session ID</strong>： <ul><li>服务器创建一个唯一的、随机的字符串作为 <code>Session ID</code>。</li></ul></li><li><strong>服务器存储 Session 数据</strong>： <ul><li>服务器将这个 <code>Session ID</code> 与该用户的相关信息（如用户ID、角色、登录时间等）一起存储在<strong>服务器端</strong>。存储位置可以是内存（如 Redis）、数据库或文件系统。</li></ul></li><li><strong>返回 Session ID 给客户端</strong>： <ul><li>服务器通过 <code>Set-Cookie</code> 响应头，将 <code>Session ID</code> 发送给浏览器。</li></ul></li><li><strong>客户端保存并发送</strong>： <ul><li>浏览器自动将这个 <code>Session ID</code> 保存为 Cookie，并且在后续每次请求中，都会自动把这个 Cookie（包含 Session ID）发送给服务器。</li></ul></li><li><strong>服务器验证</strong>： <ul><li>服务器收到请求后，从 Cookie 中提取 <code>Session ID</code>，然后去自己的存储中查找对应的用户数据。如果找到，就认为用户已登录。</li></ul></li></ol><p><strong>特点：</strong></p><ul><li><strong>优点</strong>： <ul><li><strong>安全性较高</strong>：敏感的用户信息存储在服务端，客户端只持有 ID。</li><li><strong>易于管理</strong>：服务器可以随时销毁 Session（如用户注销），实现立即失效。</li></ul></li><li><strong>缺点</strong>： <ul><li><strong>服务器压力大</strong>：需要在服务端存储所有活跃的 Session 数据，占用内存/存储空间。</li><li><strong>可扩展性差</strong>：在分布式系统或多台服务器部署时，需要保证 Session 数据在所有服务器间共享（如使用 Redis 集中存储），增加了复杂性。</li><li><strong>依赖 Cookie</strong>：如果客户端禁用 Cookie，则无法正常工作（虽然可以通过 URL 重写传递，但不安全）。</li></ul></li></ul><hr><h3 id="_2-token-令牌" tabindex="-1"><a class="header-anchor" href="#_2-token-令牌"><span>2. Token (令牌)</span></a></h3><p><strong>核心思想：客户端存储状态</strong></p><p>这里的 &quot;Token&quot; 是一个广义概念，指代一种由服务器签发、客户端携带的凭证。JWT 是 Token 的一种具体实现。</p><p>基本流程：</p><ol><li><strong>用户登录</strong>：用户提供凭证（用户名/密码）。</li><li><strong>服务器验证并签发 Token</strong>： <ul><li>服务器验证凭证正确后，生成一个 Token 字符串。</li><li>这个 Token 可以是简单的随机字符串，也可以是包含加密信息的结构化数据（如 JWT）。</li></ul></li><li><strong>返回 Token 给客户端</strong>： <ul><li>服务器将 Token 返回给客户端（通常放在响应体中，而不是 Cookie）。</li></ul></li><li><strong>客户端存储并发送</strong>： <ul><li>客户端（如前端应用）将 Token 存储起来（常用 <code>localStorage</code> 或 <code>sessionStorage</code>）。</li><li>在后续请求中，客户端需要手动将 Token 放在请求头（通常是 <code>Authorization: Bearer &lt;token&gt;</code>）中发送给服务器。</li></ul></li><li><strong>服务器验证</strong>： <ul><li>服务器收到请求后，从请求头中提取 Token。</li><li>服务器根据 Token 的类型进行验证： <ul><li>如果是简单随机 Token，服务器需要查询数据库或缓存（如 Redis）来确认 Token 是否有效以及对应哪个用户。</li><li>如果是 JWT，服务器可以直接通过签名验证其完整性和有效性（见下文）。</li></ul></li></ul></li></ol><p><strong>特点：</strong></p><ul><li><strong>优点</strong>： <ul><li><strong>服务端无状态</strong>：服务器不需要存储 Token 本身（如果是 JWT），减轻了服务器存储压力。</li><li><strong>跨域友好</strong>：不依赖 Cookie，更容易实现跨域认证。</li><li><strong>适合分布式系统</strong>：天然支持多服务器部署，因为验证逻辑可以内置于 Token 中。</li></ul></li><li><strong>缺点</strong>： <ul><li><strong>Token 失效困难</strong>：一旦签发，在过期前很难主动使其失效（除非使用黑名单机制，但这又增加了服务端存储）。JWT 尤其明显。</li><li><strong>安全性依赖存储</strong>：如果 Token 存储在 <code>localStorage</code>，可能面临 XSS 攻击的风险。</li><li><strong>Token 可能较大</strong>：尤其是 JWT，如果包含较多信息，会增加网络传输开销。</li></ul></li></ul><hr><h3 id="_3-jwt-json-web-token" tabindex="-1"><a class="header-anchor" href="#_3-jwt-json-web-token"><span>3. JWT (JSON Web Token)</span></a></h3><p><strong>核心思想：自包含、可验证的 Token</strong></p><p>JWT 是 Token 的一种开放标准（RFC 7519），它定义了一种紧凑且自包含的方式，用于在各方之间安全地传输信息作为 JSON 对象。</p><p>一个 JWT 字符串通常由三部分组成，用点 <code>.</code> 分隔：</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">xxxxx.yyyyy.zzzzz</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ol><li><strong>Header (头部)</strong>： <ul><li>包含令牌的类型（即 JWT）和所使用的签名算法（如 HMAC SHA256 或 RSA）。</li><li>例如：<code>{&quot;alg&quot;: &quot;HS256&quot;, &quot;typ&quot;: &quot;JWT&quot;}</code></li></ul></li><li><strong>Payload (负载)</strong>： <ul><li>包含声明（claims），即要传输的数据。</li><li>声明分为三类： <ul><li><strong>注册声明</strong>（Registered claims）：预定义的，如 <code>iss</code> (issuer), <code>exp</code> (expiration time), <code>sub</code> (subject), <code>aud</code> (audience) 等。</li><li><strong>公共声明</strong>（Public claims）：可以自定义，但为了避免冲突，应该使用 URI 格式。</li><li><strong>私有声明</strong>（Private claims）：自定义的，用于在双方之间共享信息，如 <code>userId</code>, <code>role</code> 等。</li></ul></li><li><strong>注意</strong>：Payload 是 Base64Url 编码的，<strong>不是加密的</strong>！任何人都可以解码查看内容，所以不要放敏感信息（如密码）。</li></ul></li><li><strong>Signature (签名)</strong>： <ul><li>用于验证消息在传输过程中没有被更改，并且对于使用私钥签名的令牌，还可以验证 JWT 的发送方是否是它声称的那个人。</li><li>签名的生成方式：对 <code>base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload)</code> 这个字符串，使用 Header 中指定的算法和一个密钥（secret）进行加密。</li></ul></li></ol><p><strong>验证过程</strong>：</p><p>服务器收到 JWT 后：</p><ol><li>拆分三部分。</li><li>使用相同的密钥和算法，对第一部分和第二部分重新计算签名。</li><li>将计算出的签名与 JWT 中的第三部分签名进行比较。</li><li>如果一致，说明 Token 未被篡改；再检查 <code>exp</code> 等声明是否有效。</li></ol><p><strong>特点：</strong></p><ul><li><strong>优点</strong>： <ul><li><strong>自包含</strong>：所有必要信息都在 Token 内，服务器无需查询数据库即可验证用户身份（前提是信任签发方）。</li><li><strong>跨语言/平台</strong>：基于 JSON，易于在不同系统间解析。</li><li><strong>标准化</strong>：有明确的规范，工具库丰富。</li></ul></li><li><strong>缺点</strong>： <ul><li><strong>无法主动失效</strong>：这是最大的痛点。一旦签发，只能等待其过期。如果需要更灵活的控制，必须结合其他机制（如短期 JWT + Refresh Token，或维护一个失效列表）。</li><li><strong>信息暴露风险</strong>：Payload 可被解码，不能存放敏感信息。</li><li><strong>性能考虑</strong>：每次请求都需要解析和验证签名，对于高并发场景，计算开销比简单的 Session ID 查找要大。</li></ul></li></ul><hr><h3 id="总结对比" tabindex="-1"><a class="header-anchor" href="#总结对比"><span>总结对比</span></a></h3><table><thead><tr><th style="text-align:left;">特性</th><th style="text-align:left;">Session</th><th style="text-align:left;">Token (通用)</th><th style="text-align:left;">JWT</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>存储位置</strong></td><td style="text-align:left;">服务端</td><td style="text-align:left;">客户端</td><td style="text-align:left;">客户端</td></tr><tr><td style="text-align:left;"><strong>状态性</strong></td><td style="text-align:left;">有状态</td><td style="text-align:left;">无状态（理想情况）</td><td style="text-align:left;">无状态</td></tr><tr><td style="text-align:left;"><strong>扩展性</strong></td><td style="text-align:left;">差（需共享存储）</td><td style="text-align:left;">好</td><td style="text-align:left;">很好</td></tr><tr><td style="text-align:left;"><strong>安全性</strong></td><td style="text-align:left;">较高（信息在服务端）</td><td style="text-align:left;">依赖实现</td><td style="text-align:left;">依赖签名和存储，Payload 明文</td></tr><tr><td style="text-align:left;"><strong>失效控制</strong></td><td style="text-align:left;">容易（删除服务端记录）</td><td style="text-align:left;">较难（需额外机制）</td><td style="text-align:left;">难（主要靠过期时间）</td></tr><tr><td style="text-align:left;"><strong>传输方式</strong></td><td style="text-align:left;">Cookie（自动）</td><td style="text-align:left;">Authorization Header</td><td style="text-align:left;">Authorization Header</td></tr><tr><td style="text-align:left;"><strong>典型场景</strong></td><td style="text-align:left;">传统 Web 应用</td><td style="text-align:left;">API 认证、单点登录</td><td style="text-align:left;">API 认证、微服务、单点登录</td></tr></tbody></table><p><strong>选择建议</strong>：</p><ul><li>对于传统的、以页面跳转为主的 Web 应用，<strong>Session</strong> 仍然是简单可靠的选择。</li><li>对于现代的前后端分离应用、API 接口服务、移动应用后端，<strong>Token</strong>（特别是 <strong>JWT</strong>）更为流行，因为它无状态、易于扩展。</li><li>使用 JWT 时，务必注意设置合理的过期时间，并考虑使用 <strong>Refresh Token</strong> 机制来平衡安全性和用户体验。</li></ul>`,33)])])}const d=e(n,[["render",i]]),a=JSON.parse('{"path":"/docs/wx/qianduanbufen/session，token，jwt.html","title":"session，token，jwt","lang":"en-US","frontmatter":{"title":"session，token，jwt","date":"2025-11-28T00:00:00.000Z"},"headers":[{"level":3,"title":"1. Session (会话)","slug":"_1-session-会话","link":"#_1-session-会话","children":[]},{"level":3,"title":"2. Token (令牌)","slug":"_2-token-令牌","link":"#_2-token-令牌","children":[]},{"level":3,"title":"3. JWT (JSON Web Token)","slug":"_3-jwt-json-web-token","link":"#_3-jwt-json-web-token","children":[]},{"level":3,"title":"总结对比","slug":"总结对比","link":"#总结对比","children":[]}],"git":{"createdTime":1771171588000,"updatedTime":1771171588000,"contributors":[{"name":"SaltFishGC","email":"130335482+SaltFishGC@users.noreply.github.com","commits":1}]},"filePathRelative":"docs/wx/前端部分/session，token，jwt.md"}');export{d as comp,a as data};
