import{_ as n,c as e,e as a,o as t}from"./app-DzrUeaTh.js";const l={};function i(o,s){return t(),e("div",null,[...s[0]||(s[0]=[a(`<h3 id="过期key策略" tabindex="-1"><a class="header-anchor" href="#过期key策略"><span>过期key策略</span></a></h3><h4 id="确定过期时间" tabindex="-1"><a class="header-anchor" href="#确定过期时间"><span>确定过期时间</span></a></h4><p>Redis 为每个数据库维护两个字典：</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">redisDb</span> <span class="token punctuation">{</span></span>
<span class="line">    dict <span class="token operator">*</span>dict<span class="token punctuation">;</span>      <span class="token comment">// 主键空间：key → value</span></span>
<span class="line">    dict <span class="token operator">*</span>expires<span class="token punctuation">;</span>   <span class="token comment">// 过期字典：key → expire_time (Unix timestamp)</span></span>
<span class="line"><span class="token punctuation">}</span> redisDb<span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>SET key value EX 10</code> → 同时写入 <code>dict</code> 和 <code>expires</code></li><li><code>TTL key</code> → 查询 <code>expires</code> 字典</li><li>删除时，同时从两个字典中移除</li></ul><blockquote><p>💡 <strong>只有 <code>expires</code> 中的 key 才会被定期删除扫描！</strong></p></blockquote><h4 id="惰性删除" tabindex="-1"><a class="header-anchor" href="#惰性删除"><span>惰性删除</span></a></h4><p><strong>📌 原理：</strong></p><ul><li><strong>只在访问 key 时检查是否过期</strong></li><li>如果过期 → 立即删除，并返回空（如 <code>GET</code> 返回 <code>nil</code>）</li></ul><p><strong>📌 触发时机：</strong></p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token comment">// Redis 源码：db.c</span></span>
<span class="line">robj <span class="token operator">*</span><span class="token function">lookupKeyRead</span><span class="token punctuation">(</span>redisDb <span class="token operator">*</span>db<span class="token punctuation">,</span> robj <span class="token operator">*</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">expireIfNeeded</span><span class="token punctuation">(</span>db<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">// 检查并删除过期 key</span></span>
<span class="line">    <span class="token keyword">return</span> <span class="token function">lookupKey</span><span class="token punctuation">(</span>db<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>所有读写命令（<code>GET</code>、<code>SET</code>、<code>HGET</code> 等）都会触发此检查</li></ul><p><strong>✅ 优点：</strong></p><ul><li><strong>零 CPU 开销</strong>（不访问就不检查）</li><li><strong>保证一致性</strong>：永远不会返回过期数据</li></ul><p><strong>❌ 缺点：</strong></p><ul><li><strong>过期 key 可能长期驻留内存</strong>（如果 never accessed）</li><li>极端情况下导致内存泄漏（如大量冷 key 设置了 TTL）</li></ul><h4 id="定期删除" tabindex="-1"><a class="header-anchor" href="#定期删除"><span><strong>定期删除</strong></span></a></h4><p><strong>📌 原理：</strong></p><ul><li>Redis <strong>每秒进行 10 次</strong>（可配置）主动扫描</li><li>每次<strong>随机抽查</strong> <strong>20 个</strong>设置了过期时间的 key</li><li>删除其中已过期的 key</li><li><strong>如果过期比例 &gt; 25%</strong>，则继续抽查下一批（避免漏删）</li></ul><p><strong>📌 配置参数：</strong></p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line"><span class="token comment"># redis.conf</span></span>
<span class="line">hz <span class="token number">10</span>          <span class="token comment"># 默认每秒 10 次（范围 1～500）</span></span>
<span class="line">dynamic-hz <span class="token function">yes</span> <span class="token comment"># 高负载时自动提高频率（6.0+）</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>📌 扫描流程（简化）：</strong></p><div class="language-python line-numbers-mode" data-highlighter="prismjs" data-ext="py" data-title="py"><pre><code><span class="line"><span class="token keyword">def</span> <span class="token function">activeExpireCycle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span></span>
<span class="line">    <span class="token keyword">for</span> db <span class="token keyword">in</span> all_dbs<span class="token punctuation">:</span></span>
<span class="line">        sampled <span class="token operator">=</span> <span class="token number">0</span></span>
<span class="line">        expired <span class="token operator">=</span> <span class="token number">0</span></span>
<span class="line">        <span class="token keyword">while</span> sampled <span class="token operator">&lt;</span> <span class="token number">20</span><span class="token punctuation">:</span></span>
<span class="line">            key <span class="token operator">=</span> random_pick_from_expired_dict<span class="token punctuation">(</span>db<span class="token punctuation">)</span></span>
<span class="line">            <span class="token keyword">if</span> key<span class="token punctuation">.</span>ttl <span class="token operator">&lt;=</span> now<span class="token punctuation">:</span></span>
<span class="line">                delete<span class="token punctuation">(</span>key<span class="token punctuation">)</span></span>
<span class="line">                expired <span class="token operator">+=</span> <span class="token number">1</span></span>
<span class="line">            sampled <span class="token operator">+=</span> <span class="token number">1</span></span>
<span class="line">        </span>
<span class="line">        <span class="token keyword">if</span> expired <span class="token operator">/</span> sampled <span class="token operator">&gt;</span> <span class="token number">0.25</span><span class="token punctuation">:</span></span>
<span class="line">            <span class="token keyword">continue</span>  <span class="token comment"># 继续抽查</span></span>
<span class="line">        <span class="token keyword">else</span><span class="token punctuation">:</span></span>
<span class="line">            <span class="token keyword">break</span>     <span class="token comment"># 本轮结束</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>✅ 优点：</strong></p><ul><li><strong>主动清理</strong>，防止过期 key 积压</li><li>即使 key never accessed，最终也会被删除</li></ul><p><strong>❌ 缺点：</strong></p><ul><li><strong>占用 CPU 时间</strong>（但通过限制次数/比例控制开销）</li><li><strong>不能保证实时性</strong>（可能延迟数百毫秒到数秒）</li></ul><h3 id="内存淘汰策略" tabindex="-1"><a class="header-anchor" href="#内存淘汰策略"><span>内存淘汰策略</span></a></h3><p>除了ttl超时过期删除键值对，当我们的内存压力过大时，Redis也会删除键值对以缓解压力：</p><p>Redis 的 <strong>内存淘汰策略（Memory Eviction Policy）</strong> 是其作为缓存系统的核心机制之一。当 Redis 内存使用达到上限（<code>maxmemory</code>）时，它会根据配置的策略自动删除部分数据，以腾出空间给新写入的数据。</p><h4 id="触发条件" tabindex="-1"><a class="header-anchor" href="#触发条件"><span>触发条件</span></a></h4><p>只有在以下两个条件<strong>同时满足</strong>时，才会触发内存淘汰：</p><ol><li><p>配置了 <code>maxmemory</code>（单位：bytes）</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line">maxmemory 2gb</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li><li><p><strong>当前内存使用 ≥ <code>maxmemory</code></strong></p></li></ol><blockquote><p>⚠️ 如果未设置 <code>maxmemory</code>，Redis 会持续使用内存直到系统 OOM（Out-Of-Memory）被 kill。</p></blockquote><h4 id="淘汰策略" tabindex="-1"><a class="header-anchor" href="#淘汰策略"><span>淘汰策略</span></a></h4><table><thead><tr><th style="text-align:left;">策略名称</th><th style="text-align:left;">含义</th><th style="text-align:left;">适用场景</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>noeviction</strong></td><td style="text-align:left;">默认策略。<strong>不淘汰</strong>，写命令返回错误（如 <code>OOM command not allowed</code>）</td><td style="text-align:left;">不希望丢失数据（如持久化存储）</td></tr><tr><td style="text-align:left;"><strong>volatile-lru</strong></td><td style="text-align:left;">从<strong>设置了过期时间（TTL）的 key</strong>中，用 LRU 算法淘汰</td><td style="text-align:left;">缓存 + 有明确过期时间</td></tr><tr><td style="text-align:left;"><strong>volatile-lfu</strong></td><td style="text-align:left;">从<strong>设置了 TTL 的 key</strong>中，用 LFU 算法淘汰（Redis 4.0+）</td><td style="text-align:left;">热点缓存，区分访问频率</td></tr><tr><td style="text-align:left;"><strong>volatile-random</strong></td><td style="text-align:left;">从<strong>设置了 TTL 的 key</strong>中，随机淘汰</td><td style="text-align:left;">简单场景，无访问模式</td></tr><tr><td style="text-align:left;"><strong>volatile-ttl</strong></td><td style="text-align:left;">从<strong>设置了 TTL 的 key</strong>中，优先淘汰<strong>剩余时间最短</strong>的</td><td style="text-align:left;">临时数据，越快过期越先删</td></tr><tr><td style="text-align:left;"><strong>allkeys-lru</strong></td><td style="text-align:left;">从<strong>所有 key</strong>中，用 LRU 淘汰</td><td style="text-align:left;">通用缓存（最常用）</td></tr><tr><td style="text-align:left;"><strong>allkeys-lfu</strong></td><td style="text-align:left;">从<strong>所有 key</strong>中，用 LFU 淘汰（Redis 4.0+）</td><td style="text-align:left;">高频访问热点数据</td></tr><tr><td style="text-align:left;"><strong>allkeys-random</strong></td><td style="text-align:left;">从<strong>所有 key</strong>中，随机淘汰</td><td style="text-align:left;">极简场景，性能最高</td></tr></tbody></table><blockquote><p>🔑 <strong>关键区别</strong>：</p><ul><li><code>volatile-*</code>：只淘汰<strong>有 TTL 的 key</strong></li><li><code>allkeys-*</code>：淘汰<strong>任意 key</strong>（包括永不过期的）</li></ul></blockquote><h4 id="淘汰算法" tabindex="-1"><a class="header-anchor" href="#淘汰算法"><span>淘汰算法</span></a></h4><p><strong>LRU——最久未被访问/最近最少使用</strong></p><p><strong>原理：</strong></p><ul><li><p>淘汰<strong>最久未被访问</strong>的 key</p></li><li><p>Redis 使用</p><p>近似 LRU</p><p>（非精确）：</p><ul><li>每个 key 记录一个 24 位的“最近访问时间戳”（<code>lru</code> 字段）</li><li>淘汰时随机采样 N 个 key（默认 5 个），选其中 <code>lru</code> 最小的淘汰</li></ul></li></ul><p><strong>配置采样数（提高精度）：</strong></p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line">maxmemory-samples <span class="token number">10</span>  <span class="token comment"># 默认 5，值越大越接近真实 LRU，但 CPU 开销增加</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><strong>优点：</strong></p><ul><li>符合“局部性原理”，适合大多数缓存场景</li></ul><p><strong>LFU——一段时间使用频次最少/最不经常使用</strong></p><p><strong>原理：</strong></p><ul><li>淘汰<strong>访问频率最低</strong>的 key</li><li>Redis 使用近似 LFU： <ul><li>每个 key 的 <code>lru</code> 字段改为存储 <strong>访问频次 + 衰减时间</strong></li><li>频次会随时间衰减（避免历史热点永远不被淘汰）</li></ul></li></ul><p><strong>配置参数：</strong></p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">lfu-log-factor 10    # 控制频次增长速度（越大越平滑）</span>
<span class="line">lfu-decay-time 1     # 多少分钟衰减一次（默认 1 分钟）</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>适用场景：</strong></p><ul><li>区分“偶尔访问” vs “持续高频访问”</li><li>例如：首页 banner（每天刷 1 次） vs 商品详情页（每秒刷 100 次）</li></ul><p><strong>Random——随机淘汰</strong></p><ul><li>完全随机选择 key 删除</li><li><strong>CPU 开销最小</strong>，但可能误删热点数据</li><li>仅用于对一致性要求极低的场景</li></ul>`,54)])])}const r=n(l,[["render",i]]),c=JSON.parse('{"path":"/docs/heimadianping/yuanlibaguwen/nacuntaihuan.html","title":"内存回收","lang":"en-US","frontmatter":{"title":"内存回收","date":"2026-1-28"},"headers":[{"level":3,"title":"过期key策略","slug":"过期key策略","link":"#过期key策略","children":[]},{"level":3,"title":"内存淘汰策略","slug":"内存淘汰策略","link":"#内存淘汰策略","children":[]}],"git":{"createdTime":1769607330000,"updatedTime":1769607330000,"contributors":[{"name":"SaltFishGC","email":"130335482+SaltFishGC@users.noreply.github.com","commits":1}]},"filePathRelative":"docs/黑马点评/原理八股文/内存汰换.md"}');export{r as comp,c as data};
