import{_ as p,c as l,e as a,a as e,b as s,d as i,r as c,o}from"./app-Cm4IjFjh.js";const d={},r={href:"https://projectlombok.org/",target:"_blank",rel:"noopener noreferrer"};function u(k,n){const t=c("ExternalLinkIcon");return o(),l("div",null,[n[3]||(n[3]=a(`<h2 id="为什么不推荐使用-autoweird了" tabindex="-1"><a class="header-anchor" href="#为什么不推荐使用-autoweird了"><span>为什么不推荐使用<code>@Autoweird</code>了？</span></a></h2><hr><h3 id="一、什么是-依赖注入-dependency-injection-di" tabindex="-1"><a class="header-anchor" href="#一、什么是-依赖注入-dependency-injection-di"><span>一、什么是 <strong>依赖注入（Dependency Injection, DI）</strong>？</span></a></h3><p><strong>依赖注入是一种设计模式</strong>，属于“控制反转（IoC）”的一种实现方式。</p><h4 id="核心思想" tabindex="-1"><a class="header-anchor" href="#核心思想"><span>核心思想：</span></a></h4><blockquote><p><strong>一个对象的依赖（即它需要使用的其他对象），不由它自己创建，而是由外部“注入”进来。</strong></p></blockquote><h4 id="举个例子-不用-spring" tabindex="-1"><a class="header-anchor" href="#举个例子-不用-spring"><span>举个例子（不用 Spring）：</span></a></h4><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token comment">// 不好的做法：自己 new 依赖</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OrderService</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token class-name">PaymentService</span> payment <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AlipayPaymentService</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 紧耦合！</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// 好的做法：依赖由外部提供（注入）</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OrderService</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token class-name">PaymentService</span> payment<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token comment">// 通过构造器注入</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token class-name">OrderService</span><span class="token punctuation">(</span><span class="token class-name">PaymentService</span> payment<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">this</span><span class="token punctuation">.</span>payment <span class="token operator">=</span> payment<span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样，<code>OrderService</code> 不再绑定具体实现，可以轻松切换为 <code>WechatPaymentService</code>，也更容易测试（传 mock 对象即可）。</p><p>✅ <strong>这就是依赖注入的本质——解耦 + 可配置 + 可测试。</strong></p><hr><h3 id="二、-autowired-是依赖注入吗" tabindex="-1"><a class="header-anchor" href="#二、-autowired-是依赖注入吗"><span>二、<code>@Autowired</code> 是依赖注入吗？</span></a></h3><p>✅ <strong>是的！但它是 Spring 框架提供的“自动依赖注入”的一种实现方式。</strong></p><p>Spring 通过 <code>@Autowired</code> 注解，<strong>自动查找容器中匹配类型的 Bean，并把它注入到目标位置</strong>（字段、构造器、方法等）。</p><p>所以：</p><ul><li><strong>依赖注入</strong> 是 <strong>概念/模式</strong></li><li><strong><code>@Autowired</code></strong> 是 Spring 实现该模式的 <strong>具体技术手段</strong></li></ul><blockquote><p>类比： “交通工具” 是概念， “汽车” 是具体实现。 同理，“依赖注入” 是概念，“<code>@Autowired</code>” 是 Spring 的实现方式之一。</p></blockquote><hr><h3 id="三、为什么又叫-字段注入-field-injection" tabindex="-1"><a class="header-anchor" href="#三、为什么又叫-字段注入-field-injection"><span>三、为什么又叫 <strong>字段注入（Field Injection）</strong>？</span></a></h3><p>因为 <code>@Autowired</code> <strong>可以写在字段上</strong>，这种用法就叫“字段注入”：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token annotation punctuation">@Service</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OrderService</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token annotation punctuation">@Autowired</span>               <span class="token comment">// ← 注解直接写在字段上</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token class-name">PaymentService</span> paymentService<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>除了字段，<code>@Autowired</code> 还可以用在：</p><ul><li><strong>构造器上</strong> → 构造器注入</li><li><strong>Setter 方法上</strong> → Setter 注入</li></ul><p>所以：</p><table><thead><tr><th>写法</th><th>名称</th></tr></thead><tbody><tr><td><code>@Autowired</code> on field</td><td>字段注入（Field Injection）</td></tr><tr><td><code>@Autowired</code> on constructor</td><td>构造器注入（Constructor Injection）</td></tr><tr><td><code>@Autowired</code> on setter method</td><td>Setter 注入（Setter Injection）</td></tr></tbody></table><p>它们都是 <strong>依赖注入的不同实现形式</strong>，而 <code>@Autowired</code> 是触发 Spring 自动注入的“开关”。</p><hr><h3 id="四、为什么不推荐字段注入" tabindex="-1"><a class="header-anchor" href="#四、为什么不推荐字段注入"><span>四、为什么不推荐字段注入？</span></a></h3><p>虽然字段注入代码简洁，但<strong>存在严重缺陷</strong>，因此 Spring 官方和主流架构师都<strong>不推荐在生产代码中使用</strong>。</p><h4 id="❌-主要问题" tabindex="-1"><a class="header-anchor" href="#❌-主要问题"><span>❌ 主要问题：</span></a></h4><h4 id="_1-隐藏了类的真实依赖" tabindex="-1"><a class="header-anchor" href="#_1-隐藏了类的真实依赖"><span>1. <strong>隐藏了类的真实依赖</strong></span></a></h4><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OrderService</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token annotation punctuation">@Autowired</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token class-name">PaymentService</span> payment<span class="token punctuation">;</span></span>
<span class="line">    <span class="token annotation punctuation">@Autowired</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token class-name">NotificationService</span> notifier<span class="token punctuation">;</span></span>
<span class="line">    <span class="token annotation punctuation">@Autowired</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token class-name">InventoryService</span> inventory<span class="token punctuation">;</span></span>
<span class="line">    <span class="token comment">// ... 可能还有更多</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>从类的 public 接口（构造器/方法）<strong>看不出它依赖什么</strong></li><li>别人阅读代码时无法快速理解其依赖关系</li><li>违反了“显式优于隐式”的设计原则</li></ul><blockquote><p>对比构造器注入：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token keyword">public</span> <span class="token class-name">OrderService</span><span class="token punctuation">(</span><span class="token class-name">PaymentService</span> p<span class="token punctuation">,</span> <span class="token class-name">NotificationService</span> n<span class="token punctuation">,</span> <span class="token class-name">InventoryService</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>一眼就知道需要哪些依赖！</p></blockquote><hr><h4 id="_2-无法将依赖设为-final" tabindex="-1"><a class="header-anchor" href="#_2-无法将依赖设为-final"><span>2. <strong>无法将依赖设为 <code>final</code></strong></span></a></h4><p>字段注入的字段必须是非 final 的（因为 Spring 通过反射赋值）：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token annotation punctuation">@Autowired</span></span>
<span class="line"><span class="token keyword">private</span> <span class="token class-name">PaymentService</span> payment<span class="token punctuation">;</span> <span class="token comment">// 不能加 final</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>而构造器注入可以：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">PaymentService</span> payment<span class="token punctuation">;</span> <span class="token comment">// ✅ 安全、不可变</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>不可变对象更安全，尤其在并发环境下。</p><hr><h4 id="_3-难以单元测试" tabindex="-1"><a class="header-anchor" href="#_3-难以单元测试"><span>3. <strong>难以单元测试</strong></span></a></h4><p>字段注入的类<strong>无法在不启动 Spring 容器的情况下被正确实例化</strong>：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token annotation punctuation">@Test</span></span>
<span class="line"><span class="token keyword">void</span> <span class="token function">testOrderService</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// ❌ paymentService 是 null！</span></span>
<span class="line">    <span class="token class-name">OrderService</span> service <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">OrderService</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    service<span class="token punctuation">.</span><span class="token function">processOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// NPE!</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>你必须：</p><ul><li>使用 <code>@SpringBootTest</code>（慢）</li><li>或用反射手动设值（丑陋）</li><li>或用 Mockito 的 <code>@InjectMocks</code>（有局限）</li></ul><p>而构造器注入：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token annotation punctuation">@Test</span></span>
<span class="line"><span class="token keyword">void</span> <span class="token function">testOrderService</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token class-name">PaymentService</span> mock <span class="token operator">=</span> <span class="token class-name">Mockito</span><span class="token punctuation">.</span><span class="token function">mock</span><span class="token punctuation">(</span><span class="token class-name">PaymentService</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token class-name">OrderService</span> service <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">OrderService</span><span class="token punctuation">(</span>mock<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ✅ 直接传参，简单干净</span></span>
<span class="line">    service<span class="token punctuation">.</span><span class="token function">processOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h4 id="_4-可能导致-nullpointerexception" tabindex="-1"><a class="header-anchor" href="#_4-可能导致-nullpointerexception"><span>4. <strong>可能导致 <code>NullPointerException</code></strong></span></a></h4><p>如果某个字段注入失败（比如 Bean 未定义），Spring 启动时可能不报错（尤其是可选依赖），运行时才 NPE。</p><p>而构造器注入：<strong>只要依赖缺失，应用启动就失败</strong>，问题尽早暴露。</p><hr><h4 id="_5-容易违反单一职责原则" tabindex="-1"><a class="header-anchor" href="#_5-容易违反单一职责原则"><span>5. <strong>容易违反单一职责原则</strong></span></a></h4><p>因为字段注入太方便，开发者可能不知不觉注入 10 个、20 个依赖，导致类变得臃肿。</p><p>而构造器注入参数太多时，你会立刻意识到：“这个类是不是做得太多了？” → 促使你重构。</p><hr><h3 id="✅-正确做法-优先使用-构造器注入" tabindex="-1"><a class="header-anchor" href="#✅-正确做法-优先使用-构造器注入"><span>✅ 正确做法：优先使用 <strong>构造器注入</strong></span></a></h3><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token annotation punctuation">@Service</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OrderService</span> <span class="token punctuation">{</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">PaymentService</span> paymentService<span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">NotificationService</span> notificationService<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">public</span> <span class="token class-name">OrderService</span><span class="token punctuation">(</span></span>
<span class="line">        <span class="token class-name">PaymentService</span> paymentService<span class="token punctuation">,</span></span>
<span class="line">        <span class="token class-name">NotificationService</span> notificationService</span>
<span class="line">    <span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">this</span><span class="token punctuation">.</span>paymentService <span class="token operator">=</span> paymentService<span class="token punctuation">;</span></span>
<span class="line">        <span class="token keyword">this</span><span class="token punctuation">.</span>notificationService <span class="token operator">=</span> notificationService<span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>🎉 从 Spring 4.3 开始，<strong>如果只有一个构造器，连 <code>@Autowired</code> 都可以省略！</strong></p></blockquote><hr><h3 id="🔚-总结" tabindex="-1"><a class="header-anchor" href="#🔚-总结"><span>🔚 总结</span></a></h3><table><thead><tr><th>问题</th><th>回答</th></tr></thead><tbody><tr><td><strong>什么是依赖注入？</strong></td><td>一种设计模式：依赖由外部提供，而非自己创建</td></tr><tr><td><strong><code>@Autowired</code> 是依赖注入吗？</strong></td><td>是，它是 Spring 实现依赖注入的注解</td></tr><tr><td><strong>为什么叫字段注入？</strong></td><td>因为 <code>@Autowired</code> 写在字段上，通过反射赋值</td></tr><tr><td><strong>为什么不推荐字段注入？</strong></td><td>隐藏依赖、不能 final、难测试、易出错、鼓励坏设计</td></tr><tr><td><strong>应该用什么？</strong></td><td><strong>构造器注入</strong>（必需依赖） + <strong>Setter 注入</strong>（可选依赖）</td></tr></tbody></table><blockquote><p>💡 记住：<strong>依赖注入 ≠ 字段注入</strong>。字段注入只是依赖注入的一种（不推荐的）实现方式。</p></blockquote><h3 id="🔧-补充-配合-lombok-使用-超简洁" tabindex="-1"><a class="header-anchor" href="#🔧-补充-配合-lombok-使用-超简洁"><span><strong>🔧 补充：配合 Lombok 使用（超简洁！）</strong></span></a></h3>`,66)),e("p",null,[n[1]||(n[1]=s("如果你用 ",-1)),e("a",r,[n[0]||(n[0]=s("Lombok",-1)),i(t)]),n[2]||(n[2]=s("，代码可以更干净：",-1))]),n[4]||(n[4]=a(`<div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token annotation punctuation">@Service</span></span>
<span class="line"><span class="token annotation punctuation">@RequiredArgsConstructor</span> <span class="token comment">// 自动生成包含 final 字段的构造器</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OrderService</span> <span class="token punctuation">{</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">PaymentService</span> paymentService<span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">NotificationService</span> notificationService<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>等价于：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token keyword">public</span> <span class="token class-name">OrderService</span><span class="token punctuation">(</span><span class="token class-name">PaymentService</span> paymentService<span class="token punctuation">,</span> <span class="token class-name">NotificationService</span> notificationService<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">this</span><span class="token punctuation">.</span>paymentService <span class="token operator">=</span> paymentService<span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">this</span><span class="token punctuation">.</span>notificationService <span class="token operator">=</span> notificationService<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>✅ Spring 会自动注入，<strong>完全不需要 <code>@Autowired</code></strong>！</p><blockquote><p>💡 这是现代 Spring Boot 项目的常见写法。</p></blockquote><h3 id="对于循环依赖的处理" tabindex="-1"><a class="header-anchor" href="#对于循环依赖的处理"><span>对于循环依赖的处理</span></a></h3><h2 id="synchronized" tabindex="-1"><a class="header-anchor" href="#synchronized"><span>synchronized</span></a></h2><p><code>synchronized</code> 是 Java 中用于实现<strong>线程同步</strong>的关键字，它可以修饰 <strong>方法（Method）</strong> 或 <strong>代码块（Block）</strong>，但<strong>不能修饰变量、类或构造器</strong>。</p><p>下面详细说明 <code>synchronized</code> 的两种使用位置及其区别：</p><hr><h3 id="一、1️⃣-修饰实例方法-instance-method" tabindex="-1"><a class="header-anchor" href="#一、1️⃣-修饰实例方法-instance-method"><span>一、1️⃣ 修饰实例方法（Instance Method）</span></a></h3><h4 id="✅-语法" tabindex="-1"><a class="header-anchor" href="#✅-语法"><span>✅ 语法：</span></a></h4><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// 同步代码</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="🔒-锁对象" tabindex="-1"><a class="header-anchor" href="#🔒-锁对象"><span>🔒 锁对象：</span></a></h4><ul><li><strong>当前实例对象（this）</strong></li><li>多个线程调用<strong>同一个对象</strong>的该方法时，会互斥执行</li><li>调用<strong>不同对象</strong>的该方法，<strong>不互斥</strong>（因为锁的是各自 this）</li></ul><h4 id="📌-示例" tabindex="-1"><a class="header-anchor" href="#📌-示例"><span>📌 示例：</span></a></h4><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Counter</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        count<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">// 线程安全</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// 使用</span></span>
<span class="line"><span class="token class-name">Counter</span> c1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Counter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">Counter</span> c2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Counter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// t1 和 t2 操作 c1 → 互斥</span></span>
<span class="line"><span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> c1<span class="token punctuation">.</span><span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> c1<span class="token punctuation">.</span><span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// t3 和 t4 操作 c2 → 互斥</span></span>
<span class="line"><span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> c2<span class="token punctuation">.</span><span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> c2<span class="token punctuation">.</span><span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// 但 c1 和 c2 之间不互斥！</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>⚠️ 注意：如果方法是 <code>private</code>、<code>protected</code> 或包私有，也可以加 <code>synchronized</code>。</p></blockquote><hr><h3 id="二、2️⃣-修饰静态方法-static-method" tabindex="-1"><a class="header-anchor" href="#二、2️⃣-修饰静态方法-static-method"><span>二、2️⃣ 修饰静态方法（Static Method）</span></a></h3><h4 id="✅-语法-1" tabindex="-1"><a class="header-anchor" href="#✅-语法-1"><span>✅ 语法：</span></a></h4><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">staticMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// 同步代码</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="🔒-锁对象-1" tabindex="-1"><a class="header-anchor" href="#🔒-锁对象-1"><span>🔒 锁对象：</span></a></h4><ul><li><strong>当前类的 Class 对象（如 <code>Counter.class</code>）</strong></li><li>所有线程调用该静态方法时，<strong>全局互斥</strong></li></ul><h4 id="📌-示例-1" tabindex="-1"><a class="header-anchor" href="#📌-示例-1"><span>📌 示例：</span></a></h4><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Counter</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> totalCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">addTotal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        totalCount<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">// 全局线程安全</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// 所有线程调用 Counter.addTotal() 都会竞争同一把锁</span></span>
<span class="line"><span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token class-name">Counter</span><span class="token operator">::</span><span class="token function">addTotal</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token class-name">Counter</span><span class="token operator">::</span><span class="token function">addTotal</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>💡 本质等价于：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">addTotal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">Counter</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        totalCount<span class="token operator">++</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></blockquote><hr><h3 id="三、3️⃣-修饰代码块-synchronized-block" tabindex="-1"><a class="header-anchor" href="#三、3️⃣-修饰代码块-synchronized-block"><span>三、3️⃣ 修饰代码块（Synchronized Block）</span></a></h3><h4 id="✅-语法-2" tabindex="-1"><a class="header-anchor" href="#✅-语法-2"><span>✅ 语法：</span></a></h4><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token keyword">synchronized</span> <span class="token punctuation">(</span>lockObject<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// 同步代码</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="🔒-锁对象-2" tabindex="-1"><a class="header-anchor" href="#🔒-锁对象-2"><span>🔒 锁对象：</span></a></h4><ul><li><strong>任意非 null 对象</strong>（由你指定）</li><li>最灵活的方式，可精确控制锁粒度</li></ul><h4 id="📌-常见用法" tabindex="-1"><a class="header-anchor" href="#📌-常见用法"><span>📌 常见用法：</span></a></h4><h4 id="_1-锁当前实例" tabindex="-1"><a class="header-anchor" href="#_1-锁当前实例"><span>（1）锁当前实例</span></a></h4><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token comment">// 等价于 synchronized 实例方法</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_2-锁-class-对象-等价于静态方法同步" tabindex="-1"><a class="header-anchor" href="#_2-锁-class-对象-等价于静态方法同步"><span>（2）锁 Class 对象（等价于静态方法同步）</span></a></h4><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">Counter</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token comment">// 全局同步</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_3-锁私有对象-推荐-避免外部干扰" tabindex="-1"><a class="header-anchor" href="#_3-锁私有对象-推荐-避免外部干扰"><span>（3）锁私有对象（推荐！避免外部干扰）</span></a></h4><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SafeTask</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Object</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 私有锁对象</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doWork</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>lock<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">            <span class="token comment">// 只有本类能拿到这把锁，安全！</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>✅ <strong>最佳实践</strong>：优先使用私有锁对象，避免使用 <code>this</code> 或 <code>String</code>/<code>Integer</code> 等可能被外部共享的对象作为锁。</p></blockquote><hr><h3 id="❌-不能用的地方-常见误区" tabindex="-1"><a class="header-anchor" href="#❌-不能用的地方-常见误区"><span>❌ 不能用的地方（常见误区）</span></a></h3><table><thead><tr><th>位置</th><th>是否允许</th><th>说明</th></tr></thead><tbody><tr><td><strong>变量</strong></td><td>❌</td><td><code>synchronized int x;</code> → 编译错误</td></tr><tr><td><strong>构造器</strong></td><td>❌</td><td><code>public synchronized MyClass()</code> → 编译错误（构造器只被一个线程调用，无需同步）</td></tr><tr><td><strong>类</strong></td><td>❌</td><td><code>synchronized class A {}</code> → 语法错误</td></tr><tr><td><strong>接口方法</strong></td><td>❌</td><td>接口方法不能有实现，无法加 synchronized</td></tr><tr><td><strong>Lambda 表达式内部</strong></td><td>⚠️ 可以写，但无意义</td><td>Lambda 本身不是方法声明</td></tr></tbody></table><hr><h3 id="🔑-核心总结" tabindex="-1"><a class="header-anchor" href="#🔑-核心总结"><span>🔑 核心总结</span></a></h3><table><thead><tr><th>使用方式</th><th>锁对象</th><th>适用场景</th></tr></thead><tbody><tr><td><code>synchronized void method()</code></td><td><code>this</code></td><td>保护实例状态</td></tr><tr><td><code>static synchronized void method()</code></td><td><code>Class</code> 对象</td><td>保护静态/全局状态</td></tr><tr><td><code>synchronized (obj) { ... }</code></td><td>任意对象</td><td>精细控制、避免死锁、提高并发度</td></tr></tbody></table><hr><h3 id="💡-高级建议" tabindex="-1"><a class="header-anchor" href="#💡-高级建议"><span>💡 高级建议</span></a></h3><ol><li><p><strong>尽量缩小同步范围</strong>：只同步必要代码，减少锁持有时间。</p></li><li><p><strong>避免锁嵌套</strong>：容易引发死锁。</p></li><li><p>不要用字符串常量作锁：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token string">&quot;lock&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span> <span class="token comment">// 危险！字符串常量池共享</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li><li><p><strong>考虑使用 <code>java.util.concurrent</code> 包</strong>：如 <code>ReentrantLock</code>、<code>AtomicInteger</code> 等，功能更强大。</p></li></ol><blockquote><p>✅ <strong>记住</strong>： <strong>“同步方法是语法糖，底层都是 synchronized 块；锁什么对象，决定谁在排队。”</strong></p></blockquote><h2 id="volatile" tabindex="-1"><a class="header-anchor" href="#volatile"><span>volatile</span></a></h2><p><code>volatile</code> 是 Java 中一个<strong>轻量级的同步机制</strong>关键字，用于修饰<strong>共享变量</strong>，主要解决 <strong>多线程环境下的可见性（Visibility）和有序性（Ordering）问题</strong>，但<strong>不保证原子性（Atomicity）</strong>。</p><hr><h3 id="一、核心作用-三大特性中的两个" tabindex="-1"><a class="header-anchor" href="#一、核心作用-三大特性中的两个"><span>一、核心作用：三大特性中的两个</span></a></h3><p>Java 内存模型（JMM）定义了线程与主内存之间的交互规则。<code>volatile</code> 主要影响以下两点：</p><table><thead><tr><th>特性</th><th>是否保证</th><th>说明</th></tr></thead><tbody><tr><td><strong>可见性（Visibility）</strong></td><td>✅ 保证</td><td>一个线程修改 <code>volatile</code> 变量后，其他线程能立即看到最新值</td></tr><tr><td><strong>有序性（Ordering）</strong></td><td>✅ 保证</td><td>禁止指令重排序（通过内存屏障实现）</td></tr><tr><td><strong>原子性（Atomicity）</strong></td><td>❌ 不保证</td><td>如 <code>volatile int count; count++</code> 仍非原子操作</td></tr></tbody></table><blockquote><p>🔑 <strong>一句话总结</strong>： <strong><code>volatile</code> = 可见性 + 禁止重排序，≠ 原子性</strong></p></blockquote><hr><h3 id="二、可见性问题示例-不用-volatile-的后果" tabindex="-1"><a class="header-anchor" href="#二、可见性问题示例-不用-volatile-的后果"><span>二、可见性问题示例（不用 volatile 的后果）</span></a></h3><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">VolatileDemo</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token keyword">boolean</span> running <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">// 没加 volatile！</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">this</span><span class="token punctuation">.</span>running <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">while</span> <span class="token punctuation">(</span>running<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 可能永远循环！</span></span>
<span class="line">            <span class="token comment">// do something</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line">        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Thread stopped&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="❌-问题" tabindex="-1"><a class="header-anchor" href="#❌-问题"><span>❌ 问题：</span></a></h4><ul><li>线程 A 执行 <code>run()</code>，读取 <code>running</code> 到<strong>工作内存（CPU 缓存）</strong></li><li>线程 B 调用 <code>stop()</code>，修改主内存中的 <code>running = false</code></li><li>但线程 A <strong>看不到更新</strong>，继续使用缓存中的 <code>true</code> → 死循环！</li></ul><h4 id="✅-解决" tabindex="-1"><a class="header-anchor" href="#✅-解决"><span>✅ 解决：</span></a></h4><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">boolean</span> running <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">// 加 volatile</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>→ 线程 B 修改后，线程 A 会<strong>强制从主内存重新读取</strong>最新值。</p><hr><h3 id="三、禁止指令重排序-有序性" tabindex="-1"><a class="header-anchor" href="#三、禁止指令重排序-有序性"><span>三、禁止指令重排序（有序性）</span></a></h3><p>编译器和 CPU 为了优化性能，可能对指令重排，但在多线程下可能导致逻辑错误。</p><h4 id="经典案例-单例模式-dcl" tabindex="-1"><a class="header-anchor" href="#经典案例-单例模式-dcl"><span>经典案例：单例模式（DCL）</span></a></h4><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> instance<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">                <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">                    instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 这行可能被重排序！</span></span>
<span class="line">                <span class="token punctuation">}</span></span>
<span class="line">            <span class="token punctuation">}</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line">        <span class="token keyword">return</span> instance<span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="⚠️-问题" tabindex="-1"><a class="header-anchor" href="#⚠️-问题"><span>⚠️ 问题：</span></a></h4><p><code>new Singleton()</code> 实际分三步：</p><ol><li>分配内存</li><li>初始化对象</li><li>将 <code>instance</code> 指向内存地址</li></ol><p><strong>若发生重排序（1 → 3 → 2）</strong>，其他线程可能拿到一个<strong>未初始化完成的对象</strong>！</p><h4 id="✅-解决-加-volatile" tabindex="-1"><a class="header-anchor" href="#✅-解决-加-volatile"><span>✅ 解决：加 <code>volatile</code></span></a></h4><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">volatile</span> <span class="token class-name">Singleton</span> instance<span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>→ 禁止重排序，确保“初始化完成”后再赋值。</p><hr><h3 id="四、什么场景适合用-volatile" tabindex="-1"><a class="header-anchor" href="#四、什么场景适合用-volatile"><span>四、什么场景适合用 <code>volatile</code>？</span></a></h3><h4 id="✅-适用条件-必须同时满足" tabindex="-1"><a class="header-anchor" href="#✅-适用条件-必须同时满足"><span>✅ 适用条件（必须同时满足）：</span></a></h4><ol><li><strong>写操作不依赖当前值</strong>（如 <code>flag = true</code>，而不是 <code>count++</code>）</li><li><strong>变量是独立的</strong>（不与其他变量构成不变性条件）</li><li><strong>只被一个线程写，多个线程读</strong>（或写操作本身是原子的）</li></ol><h4 id="🌰-典型用法" tabindex="-1"><a class="header-anchor" href="#🌰-典型用法"><span>🌰 典型用法：</span></a></h4><table><thead><tr><th>场景</th><th>示例</th></tr></thead><tbody><tr><td><strong>状态标志位</strong></td><td><code>volatile boolean shutdownRequested;</code></td></tr><tr><td><strong>一次性安全发布</strong></td><td><code>volatile Config config = loadConfig();</code></td></tr><tr><td><strong>DCL 单例</strong></td><td><code>private static volatile Singleton instance;</code></td></tr><tr><td><strong>计数器（仅读）</strong></td><td><code>volatile long lastModified;</code></td></tr></tbody></table><hr><h3 id="五、什么场景不能用-volatile" tabindex="-1"><a class="header-anchor" href="#五、什么场景不能用-volatile"><span>五、什么场景不能用 <code>volatile</code>？</span></a></h3><h4 id="❌-错误示例-自增操作" tabindex="-1"><a class="header-anchor" href="#❌-错误示例-自增操作"><span>❌ 错误示例：自增操作</span></a></h4><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Counter</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        count<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">// 等价于: read → add → write（三步！）</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>→ 多线程下仍会丢失更新！</p><h4 id="✅-正确做法" tabindex="-1"><a class="header-anchor" href="#✅-正确做法"><span>✅ 正确做法：</span></a></h4><ul><li>使用 <code>synchronized</code></li><li>使用 <code>AtomicInteger</code></li><li>使用 <code>ReentrantLock</code></li></ul><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token comment">// 推荐</span></span>
<span class="line"><span class="token keyword">private</span> <span class="token class-name">AtomicInteger</span> count <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    count<span class="token punctuation">.</span><span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h3 id="六、volatile-vs-synchronized-对比" tabindex="-1"><a class="header-anchor" href="#六、volatile-vs-synchronized-对比"><span>六、<code>volatile</code> vs <code>synchronized</code> 对比</span></a></h3><table><thead><tr><th>特性</th><th><code>volatile</code></th><th><code>synchronized</code></th></tr></thead><tbody><tr><td><strong>可见性</strong></td><td>✅</td><td>✅</td></tr><tr><td><strong>原子性</strong></td><td>❌</td><td>✅</td></tr><tr><td><strong>有序性</strong></td><td>✅（禁止重排序）</td><td>✅（隐式包含）</td></tr><tr><td><strong>性能</strong></td><td>⚡ 高（无锁）</td><td>⏳ 较低（有锁开销）</td></tr><tr><td><strong>阻塞</strong></td><td>❌ 非阻塞</td><td>✅ 阻塞</td></tr><tr><td><strong>适用范围</strong></td><td>仅变量</td><td>方法/代码块</td></tr></tbody></table><blockquote><p>💡 <strong>选择原则</strong>：</p><ul><li>如果只是<strong>状态标记或简单赋值</strong> → 用 <code>volatile</code></li><li>如果涉及<strong>复合操作（如 i++）</strong> → 用 <code>synchronized</code> 或原子类</li></ul></blockquote><hr><h3 id="七、底层原理-jvm-层面" tabindex="-1"><a class="header-anchor" href="#七、底层原理-jvm-层面"><span>七、底层原理（JVM 层面）</span></a></h3><p><code>volatile</code> 通过 <strong>内存屏障（Memory Barrier）</strong> 实现：</p><ul><li><strong>写屏障（Store Barrier）</strong>：写 <code>volatile</code> 变量前，刷新所有之前写操作到主内存</li><li><strong>读屏障（Load Barrier）</strong>：读 <code>volatile</code> 变量后，使后续读操作从主内存加载</li></ul><p>这保证了：</p><ol><li><strong>写后立即可见</strong></li><li><strong>禁止编译器/CPU 重排序跨越屏障</strong></li></ol><hr><h3 id="✅-总结-volatile-使用口诀" tabindex="-1"><a class="header-anchor" href="#✅-总结-volatile-使用口诀"><span>✅ 总结：<code>volatile</code> 使用口诀</span></a></h3><blockquote><p><strong>“可见有序它来保，原子操作它不行； 状态标志用它好，自增自减别靠它。”</strong></p></blockquote><h4 id="最佳实践" tabindex="-1"><a class="header-anchor" href="#最佳实践"><span>最佳实践：</span></a></h4><ul><li>✅ 用作<strong>布尔开关、配置更新通知、一次性发布</strong></li><li>❌ 不要用在<strong>计数器、累加器、复合操作</strong></li><li>🔒 复杂同步场景 → 优先考虑 <code>java.util.concurrent</code> 包（如 <code>AtomicXXX</code>, <code>CountDownLatch</code>）</li></ul><p>理解 <code>volatile</code> 能帮你写出更高效、正确的并发代码，但务必清楚它的能力边界！</p>`,108))])}const h=p(d,[["render",u]]),m=JSON.parse('{"path":"/docs/heimashangcheng/bagu/1.Spring.html","title":"Spring八股","lang":"en-US","frontmatter":{"title":"Spring八股","date":"2026-1-30"},"headers":[{"level":2,"title":"为什么不推荐使用@Autoweird了？","slug":"为什么不推荐使用-autoweird了","link":"#为什么不推荐使用-autoweird了","children":[{"level":3,"title":"一、什么是 依赖注入（Dependency Injection, DI）？","slug":"一、什么是-依赖注入-dependency-injection-di","link":"#一、什么是-依赖注入-dependency-injection-di","children":[]},{"level":3,"title":"二、@Autowired 是依赖注入吗？","slug":"二、-autowired-是依赖注入吗","link":"#二、-autowired-是依赖注入吗","children":[]},{"level":3,"title":"三、为什么又叫 字段注入（Field Injection）？","slug":"三、为什么又叫-字段注入-field-injection","link":"#三、为什么又叫-字段注入-field-injection","children":[]},{"level":3,"title":"四、为什么不推荐字段注入？","slug":"四、为什么不推荐字段注入","link":"#四、为什么不推荐字段注入","children":[]},{"level":3,"title":"✅ 正确做法：优先使用 构造器注入","slug":"✅-正确做法-优先使用-构造器注入","link":"#✅-正确做法-优先使用-构造器注入","children":[]},{"level":3,"title":"🔚 总结","slug":"🔚-总结","link":"#🔚-总结","children":[]},{"level":3,"title":"🔧 补充：配合 Lombok 使用（超简洁！）","slug":"🔧-补充-配合-lombok-使用-超简洁","link":"#🔧-补充-配合-lombok-使用-超简洁","children":[]},{"level":3,"title":"对于循环依赖的处理","slug":"对于循环依赖的处理","link":"#对于循环依赖的处理","children":[]}]},{"level":2,"title":"synchronized","slug":"synchronized","link":"#synchronized","children":[{"level":3,"title":"一、1️⃣ 修饰实例方法（Instance Method）","slug":"一、1️⃣-修饰实例方法-instance-method","link":"#一、1️⃣-修饰实例方法-instance-method","children":[]},{"level":3,"title":"二、2️⃣ 修饰静态方法（Static Method）","slug":"二、2️⃣-修饰静态方法-static-method","link":"#二、2️⃣-修饰静态方法-static-method","children":[]},{"level":3,"title":"三、3️⃣ 修饰代码块（Synchronized Block）","slug":"三、3️⃣-修饰代码块-synchronized-block","link":"#三、3️⃣-修饰代码块-synchronized-block","children":[]},{"level":3,"title":"❌ 不能用的地方（常见误区）","slug":"❌-不能用的地方-常见误区","link":"#❌-不能用的地方-常见误区","children":[]},{"level":3,"title":"🔑 核心总结","slug":"🔑-核心总结","link":"#🔑-核心总结","children":[]},{"level":3,"title":"💡 高级建议","slug":"💡-高级建议","link":"#💡-高级建议","children":[]}]},{"level":2,"title":"volatile","slug":"volatile","link":"#volatile","children":[{"level":3,"title":"一、核心作用：三大特性中的两个","slug":"一、核心作用-三大特性中的两个","link":"#一、核心作用-三大特性中的两个","children":[]},{"level":3,"title":"二、可见性问题示例（不用 volatile 的后果）","slug":"二、可见性问题示例-不用-volatile-的后果","link":"#二、可见性问题示例-不用-volatile-的后果","children":[]},{"level":3,"title":"三、禁止指令重排序（有序性）","slug":"三、禁止指令重排序-有序性","link":"#三、禁止指令重排序-有序性","children":[]},{"level":3,"title":"四、什么场景适合用 volatile？","slug":"四、什么场景适合用-volatile","link":"#四、什么场景适合用-volatile","children":[]},{"level":3,"title":"五、什么场景不能用 volatile？","slug":"五、什么场景不能用-volatile","link":"#五、什么场景不能用-volatile","children":[]},{"level":3,"title":"六、volatile vs synchronized 对比","slug":"六、volatile-vs-synchronized-对比","link":"#六、volatile-vs-synchronized-对比","children":[]},{"level":3,"title":"七、底层原理（JVM 层面）","slug":"七、底层原理-jvm-层面","link":"#七、底层原理-jvm-层面","children":[]},{"level":3,"title":"✅ 总结：volatile 使用口诀","slug":"✅-总结-volatile-使用口诀","link":"#✅-总结-volatile-使用口诀","children":[]}]}],"git":{"createdTime":1771237270000,"updatedTime":1771237270000,"contributors":[{"name":"SaltFishGC","email":"130335482+SaltFishGC@users.noreply.github.com","commits":1}]},"filePathRelative":"docs/黑马商城/八股/1.Spring.md"}');export{h as comp,m as data};
